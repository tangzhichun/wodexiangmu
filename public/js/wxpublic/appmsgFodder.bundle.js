/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 719);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(3);
var isBuffer = __webpack_require__(15);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ 10:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_axios__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__error__ = __webpack_require__(9);
/* jshint esversion: 6 */




let err = {
    code: "810",
    message: 'é¡µé¢æ‰“å¼€äººå‘˜ä¸å½“å‰æ“ä½œäººå‘˜ä¸ä¸€è‡´',
    success: false
};

__WEBPACK_IMPORTED_MODULE_0_axios___default.a.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';

__WEBPACK_IMPORTED_MODULE_0_axios___default.a.interceptors.request.use(function (config) {

    //é€çº§éå†å¯¹è±¡çš„å±æ€§ï¼Œå»é™¤ç©ºæ ¼
    let trim = function (obj) {
        for (let key in obj) {
            if (obj[key] || obj[key] == 0) {
                if (typeof obj[key] === 'string') {
                    obj[key] = obj[key].trim();

                    //ç©ºå­—ç¬¦ä¸²æ›¿æ¢æˆnull
                    if (obj[key] == '') {
                        delete obj[key];
                    }
                } else if (typeof obj[key] === 'object') {
                    trim(obj[key]);
                }
            } else {
                delete obj[key];
            }
        }
    };

    //æäº¤æ•°æ®å‰ï¼Œå»é™¤é¦–å°¾ç©ºæ ¼
    let data = config.params || config.data || {};
    trim(data);

    return config;
}, function (error) {
    // Do something with request error
    return Promise.reject(error);
});

__WEBPACK_IMPORTED_MODULE_0_axios___default.a.interceptors.response.use(function (response) {
    //å¤„ç†200è¿”å›ç 
    if (response && response.status == '200' && response.data) {
        let result = response.data;
        if (result.success) {
            return result;
        } else {
            //å¤„ç†å…¨å±€é”™è¯¯
            if (result.code == '811' || result.code == '810') {
                //å–å‰ç«¯ç¿»è¯‘åçš„é”™è¯¯ç ã€æˆ–è€…åç«¯ç›´æ¥æŠ›å‡ºçš„é”™è¯¯æ¶ˆæ¯ï¼Œéƒ½æ²¡æœ‰å€¼ï¼Œåˆ™æç¤ºé»˜è®¤é”™è¯¯æ¶ˆæ¯
                let errorMsg = __WEBPACK_IMPORTED_MODULE_1__error__["default"].SYSTEM_ERROR[result.code] || result.message || __WEBPACK_IMPORTED_MODULE_1__error__["default"].SYSTEM_ERROR.DEFAULT;
                if (Vue && Vue.prototype.$message) {
                    Vue.prototype.$message({
                        message: errorMsg,
                        type: 'error',
                        duration: 5000,
                        onClose: function () {
                            window.location.href = '/logout';
                        }
                    });
                }
            } else {
                //å–å‰ç«¯ç¿»è¯‘åçš„é”™è¯¯ç ã€æˆ–è€…åç«¯ç›´æ¥æŠ›å‡ºçš„é”™è¯¯æ¶ˆæ¯ï¼Œéƒ½æ²¡æœ‰å€¼ï¼Œåˆ™æç¤ºé»˜è®¤é”™è¯¯æ¶ˆæ¯
                let errorMsg = __WEBPACK_IMPORTED_MODULE_1__error__["default"].SYSTEM_ERROR[result.code] || result.message || __WEBPACK_IMPORTED_MODULE_1__error__["default"].SYSTEM_ERROR.DEFAULT;
                if (Vue && Vue.prototype.$message) {
                    Vue.prototype.$message.error(errorMsg);
                }
                return result;
            }
        }
    } else {
        return response;
    }
}, function (err) {
    //å–å‰ç«¯ç¿»è¯‘åçš„é”™è¯¯ç ï¼Œå¦‚æ²¡æœ‰å€¼ï¼Œåˆ™æç¤ºé»˜è®¤é”™è¯¯æ¶ˆæ¯ã€‚ä¸ç›´æ¥å–åç«¯ç›´æ¥æŠ›å‡ºçš„é”™è¯¯æ¶ˆæ¯ï¼Œå› ä¸ºå¯èƒ½åŒ…å«å¼‚å¸¸å †æ ˆç­‰æ•æ„Ÿä¸”ä¸å‹å¥½çš„æç¤ºä¿¡æ¯ã€‚
    let errorMsg = __WEBPACK_IMPORTED_MODULE_1__error__["default"].NETWORK_ERROR[err.response && err.response.status] || __WEBPACK_IMPORTED_MODULE_1__error__["default"].SYSTEM_ERROR.DEFAULT;
    console.error(errorMsg + ': %o', {
        status: err.response && err.response.status,
        message: err.message,
        stack: err.stack
    });

    if (Vue && Vue.prototype.$message) {
        Vue.prototype.$message.error(errorMsg);
    }
    return Promise.reject(err);
});

/* harmony default export */ __webpack_exports__["default"] = (__WEBPACK_IMPORTED_MODULE_0_axios___default.a);

/***/ }),

/***/ 11:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* jshint esversion: 6 */

/* harmony default export */ __webpack_exports__["default"] = ({

    /**
     * è·å–å¯¹è±¡çš„å±æ€§å€¼
     * @param obj       å¯¹è±¡
     * @param prop      å¯ä»¥æ˜¯'prop.prop[i].prop'çš„æ ¼å¼
     * @returns {*}
     */
    getProp: function (obj, prop) {
        let self = this;

        if (!obj || !prop) {
            return obj;
        }

        if (typeof prop != 'string') {
            throw new Error('prop must be a string');
        }

        if (prop.startsWith('.')) {
            prop = prop.substr(1);
            return self.getProp(obj, prop);
        }

        if (prop.endsWith('.')) {
            prop = prop.substr(0, prop.length - 1);
            return self.getProp(obj, prop);
        }

        if (obj[prop]) {
            return obj[prop];
        }

        //æ•°ç»„å–å€¼
        let i1 = prop.indexOf('[');
        let i2 = prop.indexOf('.');
        if (i1 != -1 && i2 != -1 && i1 < i2 || i1 != -1 && i2 == -1) {
            let p1 = prop.substr(0, i1);
            let p2 = prop.substr(i1, prop.length);
            let v1 = obj[p1];
            if (!v1) {
                return v1;
            } else if (typeof v1 != 'object' || !(v1 instanceof Array)) {
                //éæ•°ç»„
                return null;
            } else {
                let props = p2.split('.');
                prop = props.shift().replace('[', '').replace(']', '');

                if (props.length > 0) {
                    return self.getProp(v1[prop], props.join('.'));
                } else {
                    return v1[prop];
                }
            }
        }

        //å¯¹è±¡å–å€¼
        let props = prop.split('.');
        prop = props.shift();

        if (props.length > 0) {
            return self.getProp(obj[prop], props.join('.'));
        } else {
            return obj[prop];
        }
    },

    /**
     * è®¾ç½®å¯¹è±¡çš„å±æ€§å€¼
     * @param obj       å¯¹è±¡
     * @param prop      å¯ä»¥æ˜¯'prop.prop.prop'çš„æ ¼å¼
     * @param prop      å€¼
     * @returns {*}
     */
    setProp: function (obj, prop, val) {
        let self = this;

        if (!obj || !prop) {
            return obj;
        }

        if (typeof prop != 'string') {
            throw new Error('prop must be a string');
        }

        if (prop.startsWith('.')) {
            prop = prop.substr(1);
            self.setProp(obj, prop, val);
            return;
        }

        if (prop.endsWith('.')) {
            prop = prop.substr(0, prop.length - 1);
            self.setProp(obj, prop, val);
            return;
        }

        let props = prop.split('.');
        prop = props.shift();

        if (props.length > 0) {
            if (obj[prop] && typeof obj[prop] == 'object' && !(obj[prop] instanceof Array)) {
                self.setProp(obj[prop], props.join('.'), val);
            } else {
                obj[prop] = {};
                self.setProp(obj[prop], props.join('.'), val);
                return;
            }
        } else {
            obj[prop] = val;
        }
    }
});

/***/ }),

/***/ 12:
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ 13:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(14);

/***/ }),

/***/ 14:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var bind = __webpack_require__(3);
var Axios = __webpack_require__(16);
var defaults = __webpack_require__(2);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(8);
axios.CancelToken = __webpack_require__(30);
axios.isCancel = __webpack_require__(7);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(31);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ 15:
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ 16:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(2);
var utils = __webpack_require__(0);
var InterceptorManager = __webpack_require__(25);
var dispatchRequest = __webpack_require__(26);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ 167:
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.wangEditor = factory());
}(this, (function () { 'use strict';

/*
    poly-fill
*/

var polyfill = function () {

    // Object.assign
    if (typeof Object.assign != 'function') {
        Object.assign = function (target, varArgs) {
            // .length of function is 2
            if (target == null) {
                // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];

                if (nextSource != null) {
                    // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        };
    }

    // IE ä¸­å…¼å®¹ Element.prototype.matches
    if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
                i = matches.length;
            while (--i >= 0 && matches.item(i) !== this) {}
            return i > -1;
        };
    }
};

/*
    DOM æ“ä½œ API
*/

// æ ¹æ® html ä»£ç ç‰‡æ®µåˆ›å»º dom å¯¹è±¡
function createElemByHTML(html) {
    var div = void 0;
    div = document.createElement('div');
    div.innerHTML = html;
    return div.children;
}

// æ˜¯å¦æ˜¯ DOM List
function isDOMList(selector) {
    if (!selector) {
        return false;
    }
    if (selector instanceof HTMLCollection || selector instanceof NodeList) {
        return true;
    }
    return false;
}

// å°è£… document.querySelectorAll
function querySelectorAll(selector) {
    var result = document.querySelectorAll(selector);
    if (isDOMList(result)) {
        return result;
    } else {
        return [result];
    }
}

// è®°å½•æ‰€æœ‰çš„äº‹ä»¶ç»‘å®š
var eventList = [];

// åˆ›å»ºæ„é€ å‡½æ•°
function DomElement(selector) {
    if (!selector) {
        return;
    }

    // selector æœ¬æ¥å°±æ˜¯ DomElement å¯¹è±¡ï¼Œç›´æ¥è¿”å›
    if (selector instanceof DomElement) {
        return selector;
    }

    this.selector = selector;
    var nodeType = selector.nodeType;

    // æ ¹æ® selector å¾—å‡ºçš„ç»“æœï¼ˆå¦‚ DOMï¼ŒDOM Listï¼‰
    var selectorResult = [];
    if (nodeType === 9) {
        // document èŠ‚ç‚¹
        selectorResult = [selector];
    } else if (nodeType === 1) {
        // å•ä¸ª DOM èŠ‚ç‚¹
        selectorResult = [selector];
    } else if (isDOMList(selector) || selector instanceof Array) {
        // DOM List æˆ–è€…æ•°ç»„
        selectorResult = selector;
    } else if (typeof selector === 'string') {
        // å­—ç¬¦ä¸²
        selector = selector.replace('/\n/mg', '').trim();
        if (selector.indexOf('<') === 0) {
            // å¦‚ <div>
            selectorResult = createElemByHTML(selector);
        } else {
            // å¦‚ #id .class
            selectorResult = querySelectorAll(selector);
        }
    }

    var length = selectorResult.length;
    if (!length) {
        // ç©ºæ•°ç»„
        return this;
    }

    // åŠ å…¥ DOM èŠ‚ç‚¹
    var i = void 0;
    for (i = 0; i < length; i++) {
        this[i] = selectorResult[i];
    }
    this.length = length;
}

// ä¿®æ”¹åŸå‹
DomElement.prototype = {
    constructor: DomElement,

    // ç±»æ•°ç»„ï¼ŒforEach
    forEach: function forEach(fn) {
        var i = void 0;
        for (i = 0; i < this.length; i++) {
            var elem = this[i];
            var result = fn.call(elem, elem, i);
            if (result === false) {
                break;
            }
        }
        return this;
    },

    // clone
    clone: function clone(deep) {
        var cloneList = [];
        this.forEach(function (elem) {
            cloneList.push(elem.cloneNode(!!deep));
        });
        return $(cloneList);
    },

    // è·å–ç¬¬å‡ ä¸ªå…ƒç´ 
    get: function get(index) {
        var length = this.length;
        if (index >= length) {
            index = index % length;
        }
        return $(this[index]);
    },

    // ç¬¬ä¸€ä¸ª
    first: function first() {
        return this.get(0);
    },

    // æœ€åä¸€ä¸ª
    last: function last() {
        var length = this.length;
        return this.get(length - 1);
    },

    // ç»‘å®šäº‹ä»¶
    on: function on(type, selector, fn) {
        // selector ä¸ä¸ºç©ºï¼Œè¯æ˜ç»‘å®šäº‹ä»¶è¦åŠ ä»£ç†
        if (!fn) {
            fn = selector;
            selector = null;
        }

        // type æ˜¯å¦æœ‰å¤šä¸ª
        var types = [];
        types = type.split(/\s+/);

        return this.forEach(function (elem) {
            types.forEach(function (type) {
                if (!type) {
                    return;
                }

                // è®°å½•ä¸‹ï¼Œæ–¹ä¾¿åé¢è§£ç»‘
                eventList.push({
                    elem: elem,
                    type: type,
                    fn: fn
                });

                if (!selector) {
                    // æ— ä»£ç†
                    elem.addEventListener(type, fn);
                    return;
                }

                // æœ‰ä»£ç†
                elem.addEventListener(type, function (e) {
                    var target = e.target;
                    if (target.matches(selector)) {
                        fn.call(target, e);
                    }
                });
            });
        });
    },

    // å–æ¶ˆäº‹ä»¶ç»‘å®š
    off: function off(type, fn) {
        return this.forEach(function (elem) {
            elem.removeEventListener(type, fn);
        });
    },

    // è·å–/è®¾ç½® å±æ€§
    attr: function attr(key, val) {
        if (val == null) {
            // è·å–å€¼
            return this[0].getAttribute(key);
        } else {
            // è®¾ç½®å€¼
            return this.forEach(function (elem) {
                elem.setAttribute(key, val);
            });
        }
    },

    // æ·»åŠ  class
    addClass: function addClass(className) {
        if (!className) {
            return this;
        }
        return this.forEach(function (elem) {
            var arr = void 0;
            if (elem.className) {
                // è§£æå½“å‰ className è½¬æ¢ä¸ºæ•°ç»„
                arr = elem.className.split(/\s/);
                arr = arr.filter(function (item) {
                    return !!item.trim();
                });
                // æ·»åŠ  class
                if (arr.indexOf(className) < 0) {
                    arr.push(className);
                }
                // ä¿®æ”¹ elem.class
                elem.className = arr.join(' ');
            } else {
                elem.className = className;
            }
        });
    },

    // åˆ é™¤ class
    removeClass: function removeClass(className) {
        if (!className) {
            return this;
        }
        return this.forEach(function (elem) {
            var arr = void 0;
            if (elem.className) {
                // è§£æå½“å‰ className è½¬æ¢ä¸ºæ•°ç»„
                arr = elem.className.split(/\s/);
                arr = arr.filter(function (item) {
                    item = item.trim();
                    // åˆ é™¤ class
                    if (!item || item === className) {
                        return false;
                    }
                    return true;
                });
                // ä¿®æ”¹ elem.class
                elem.className = arr.join(' ');
            }
        });
    },

    // ä¿®æ”¹ css
    css: function css(key, val) {
        var currentStyle = key + ':' + val + ';';
        return this.forEach(function (elem) {
            var style = (elem.getAttribute('style') || '').trim();
            var styleArr = void 0,
                resultArr = [];
            if (style) {
                // å°† style æŒ‰ç…§ ; æ‹†åˆ†ä¸ºæ•°ç»„
                styleArr = style.split(';');
                styleArr.forEach(function (item) {
                    // å¯¹æ¯é¡¹æ ·å¼ï¼ŒæŒ‰ç…§ : æ‹†åˆ†ä¸º key å’Œ value
                    var arr = item.split(':').map(function (i) {
                        return i.trim();
                    });
                    if (arr.length === 2) {
                        resultArr.push(arr[0] + ':' + arr[1]);
                    }
                });
                // æ›¿æ¢æˆ–è€…æ–°å¢
                resultArr = resultArr.map(function (item) {
                    if (item.indexOf(key) === 0) {
                        return currentStyle;
                    } else {
                        return item;
                    }
                });
                if (resultArr.indexOf(currentStyle) < 0) {
                    resultArr.push(currentStyle);
                }
                // ç»“æœ
                elem.setAttribute('style', resultArr.join('; '));
            } else {
                // style æ— å€¼
                elem.setAttribute('style', currentStyle);
            }
        });
    },

    // æ˜¾ç¤º
    show: function show() {
        return this.css('display', 'block');
    },

    // éšè—
    hide: function hide() {
        return this.css('display', 'none');
    },

    // è·å–å­èŠ‚ç‚¹
    children: function children() {
        var elem = this[0];
        if (!elem) {
            return null;
        }

        return $(elem.children);
    },

    // è·å–å­èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬æ–‡æœ¬èŠ‚ç‚¹ï¼‰
    childNodes: function childNodes() {
        var elem = this[0];
        if (!elem) {
            return null;
        }

        return $(elem.childNodes);
    },

    // å¢åŠ å­èŠ‚ç‚¹
    append: function append($children) {
        return this.forEach(function (elem) {
            $children.forEach(function (child) {
                elem.appendChild(child);
            });
        });
    },

    // ç§»é™¤å½“å‰èŠ‚ç‚¹
    remove: function remove() {
        return this.forEach(function (elem) {
            if (elem.remove) {
                elem.remove();
            } else {
                var parent = elem.parentElement;
                parent && parent.removeChild(elem);
            }
        });
    },

    // æ˜¯å¦åŒ…å«æŸä¸ªå­èŠ‚ç‚¹
    isContain: function isContain($child) {
        var elem = this[0];
        var child = $child[0];
        return elem.contains(child);
    },

    // å°ºå¯¸æ•°æ®
    getSizeData: function getSizeData() {
        var elem = this[0];
        return elem.getBoundingClientRect(); // å¯å¾—åˆ° bottom height left right top width çš„æ•°æ®
    },

    // å°è£… nodeName
    getNodeName: function getNodeName() {
        var elem = this[0];
        return elem.nodeName;
    },

    // ä»å½“å‰å…ƒç´ æŸ¥æ‰¾
    find: function find(selector) {
        var elem = this[0];
        return $(elem.querySelectorAll(selector));
    },

    // è·å–å½“å‰å…ƒç´ çš„ text
    text: function text(val) {
        if (!val) {
            // è·å– text
            var elem = this[0];
            return elem.innerHTML.replace(/<.*?>/g, function () {
                return '';
            });
        } else {
            // è®¾ç½® text
            return this.forEach(function (elem) {
                elem.innerHTML = val;
            });
        }
    },

    // è·å– html
    html: function html(value) {
        var elem = this[0];
        if (value == null) {
            return elem.innerHTML;
        } else {
            elem.innerHTML = value;
            return this;
        }
    },

    // è·å– value
    val: function val() {
        var elem = this[0];
        return elem.value.trim();
    },

    // focus
    focus: function focus() {
        return this.forEach(function (elem) {
            elem.focus();
        });
    },

    // parent
    parent: function parent() {
        var elem = this[0];
        return $(elem.parentElement);
    },

    // parentUntil æ‰¾åˆ°ç¬¦åˆ selector çš„çˆ¶èŠ‚ç‚¹
    parentUntil: function parentUntil(selector, _currentElem) {
        var results = document.querySelectorAll(selector);
        var length = results.length;
        if (!length) {
            // ä¼ å…¥çš„ selector æ— æ•ˆ
            return null;
        }

        var elem = _currentElem || this[0];
        if (elem.nodeName === 'BODY') {
            return null;
        }

        var parent = elem.parentElement;
        var i = void 0;
        for (i = 0; i < length; i++) {
            if (parent === results[i]) {
                // æ‰¾åˆ°ï¼Œå¹¶è¿”å›
                return $(parent);
            }
        }

        // ç»§ç»­æŸ¥æ‰¾
        return this.parentUntil(selector, parent);
    },

    // åˆ¤æ–­ä¸¤ä¸ª elem æ˜¯å¦ç›¸ç­‰
    equal: function equal($elem) {
        if ($elem.nodeType === 1) {
            return this[0] === $elem;
        } else {
            return this[0] === $elem[0];
        }
    },

    // å°†è¯¥å…ƒç´ æ’å…¥åˆ°æŸä¸ªå…ƒç´ å‰é¢
    insertBefore: function insertBefore(selector) {
        var $referenceNode = $(selector);
        var referenceNode = $referenceNode[0];
        if (!referenceNode) {
            return this;
        }
        return this.forEach(function (elem) {
            var parent = referenceNode.parentNode;
            parent.insertBefore(elem, referenceNode);
        });
    },

    // å°†è¯¥å…ƒç´ æ’å…¥åˆ°æŸä¸ªå…ƒç´ åé¢
    insertAfter: function insertAfter(selector) {
        var $referenceNode = $(selector);
        var referenceNode = $referenceNode[0];
        if (!referenceNode) {
            return this;
        }
        return this.forEach(function (elem) {
            var parent = referenceNode.parentNode;
            if (parent.lastChild === referenceNode) {
                // æœ€åä¸€ä¸ªå…ƒç´ 
                parent.appendChild(elem);
            } else {
                // ä¸æ˜¯æœ€åä¸€ä¸ªå…ƒç´ 
                parent.insertBefore(elem, referenceNode.nextSibling);
            }
        });
    }
};

// new ä¸€ä¸ªå¯¹è±¡
function $(selector) {
    return new DomElement(selector);
}

// è§£ç»‘æ‰€æœ‰äº‹ä»¶ï¼Œç”¨äºé”€æ¯ç¼–è¾‘å™¨
$.offAll = function () {
    eventList.forEach(function (item) {
        var elem = item.elem;
        var type = item.type;
        var fn = item.fn;
        // è§£ç»‘
        elem.removeEventListener(type, fn);
    });
};

/*
    é…ç½®ä¿¡æ¯
*/

var config = {

    // é»˜è®¤èœå•é…ç½®
    menus: ['head', 'bold', 'fontSize', 'fontName', 'italic', 'underline', 'strikeThrough', 'foreColor', 'backColor', 'link', 'list', 'justify', 'quote', 'emoticon', 'image', 'table', 'video', 'code', 'undo', 'redo'],

    fontNames: ['å®‹ä½“', 'å¾®è½¯é›…é»‘', 'Arial', 'Tahoma', 'Verdana'],

    colors: ['#000000', '#eeece0', '#1c487f', '#4d80bf', '#c24f4a', '#8baa4a', '#7b5ba1', '#46acc8', '#f9963b', '#ffffff'],

    // // è¯­è¨€é…ç½®
    // lang: {
    //     'è®¾ç½®æ ‡é¢˜': 'title',
    //     'æ­£æ–‡': 'p',
    //     'é“¾æ¥æ–‡å­—': 'link text',
    //     'é“¾æ¥': 'link',
    //     'æ’å…¥': 'insert',
    //     'åˆ›å»º': 'init'
    // },

    // è¡¨æƒ…
    emotions: [{
        // tab çš„æ ‡é¢˜
        title: 'é»˜è®¤',
        // type -> 'emoji' / 'image'
        type: 'image',
        // content -> æ•°ç»„
        content: [{
            alt: '[åç¬‘]',
            src: 'http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/50/pcmoren_huaixiao_org.png'
        }, {
            alt: '[èˆ”å±]',
            src: 'http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/40/pcmoren_tian_org.png'
        }, {
            alt: '[æ±¡]',
            src: 'http://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/3c/pcmoren_wu_org.png'
        }]
    }, {
        // tab çš„æ ‡é¢˜
        title: 'æ–°æµª',
        // type -> 'emoji' / 'image'
        type: 'image',
        // content -> æ•°ç»„
        content: [{
            src: 'http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/7a/shenshou_thumb.gif',
            alt: '[è‰æ³¥é©¬]'
        }, {
            src: 'http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/60/horse2_thumb.gif',
            alt: '[ç¥é©¬]'
        }, {
            src: 'http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/bc/fuyun_thumb.gif',
            alt: '[æµ®äº‘]'
        }]
    }, {
        // tab çš„æ ‡é¢˜
        title: 'emoji',
        // type -> 'emoji' / 'image'
        type: 'emoji',
        // content -> æ•°ç»„
        content: 'ğŸ˜€ ğŸ˜ƒ ğŸ˜„ ğŸ˜ ğŸ˜† ğŸ˜… ğŸ˜‚ ğŸ˜Š ğŸ˜‡ ğŸ™‚ ğŸ™ƒ ğŸ˜‰ ğŸ˜“ ğŸ˜ª ğŸ˜´ ğŸ™„ ğŸ¤” ğŸ˜¬ ğŸ¤'.split(/\s/)
    }],

    // ç¼–è¾‘åŒºåŸŸçš„ z-index
    zIndex: 10000,

    // æ˜¯å¦å¼€å¯ debug æ¨¡å¼ï¼ˆdebug æ¨¡å¼ä¸‹é”™è¯¯ä¼š throw error å½¢å¼æŠ›å‡ºï¼‰
    debug: false,

    // æ’å…¥é“¾æ¥æ—¶å€™çš„æ ¼å¼æ ¡éªŒ
    linkCheck: function linkCheck(text, link) {
        // text æ˜¯æ’å…¥çš„æ–‡å­—
        // link æ˜¯æ’å…¥çš„é“¾æ¥
        return true; // è¿”å› true å³è¡¨ç¤ºæˆåŠŸ
        // return 'æ ¡éªŒå¤±è´¥' // è¿”å›å­—ç¬¦ä¸²å³è¡¨ç¤ºå¤±è´¥çš„æç¤ºä¿¡æ¯
    },

    // æ’å…¥ç½‘ç»œå›¾ç‰‡çš„æ ¡éªŒ
    linkImgCheck: function linkImgCheck(src) {
        // src å³å›¾ç‰‡çš„åœ°å€
        return true; // è¿”å› true å³è¡¨ç¤ºæˆåŠŸ
        // return 'æ ¡éªŒå¤±è´¥'  // è¿”å›å­—ç¬¦ä¸²å³è¡¨ç¤ºå¤±è´¥çš„æç¤ºä¿¡æ¯
    },

    // ç²˜è´´è¿‡æ»¤æ ·å¼ï¼Œé»˜è®¤å¼€å¯
    pasteFilterStyle: true,

    // ç²˜è´´å†…å®¹æ—¶ï¼Œå¿½ç•¥å›¾ç‰‡ã€‚é»˜è®¤å…³é—­
    pasteIgnoreImg: false,

    // å¯¹ç²˜è´´çš„æ–‡å­—è¿›è¡Œè‡ªå®šä¹‰å¤„ç†ï¼Œè¿”å›å¤„ç†åçš„ç»“æœã€‚ç¼–è¾‘å™¨ä¼šå°†å¤„ç†åçš„ç»“æœç²˜è´´åˆ°ç¼–è¾‘åŒºåŸŸä¸­ã€‚
    // IE æš‚æ—¶ä¸æ”¯æŒ
    pasteTextHandle: function pasteTextHandle(content) {
        // content å³ç²˜è´´è¿‡æ¥çš„å†…å®¹ï¼ˆhtml æˆ– çº¯æ–‡æœ¬ï¼‰ï¼Œå¯è¿›è¡Œè‡ªå®šä¹‰å¤„ç†ç„¶åè¿”å›
        return content;
    },

    // onchange äº‹ä»¶
    // onchange: function (html) {
    //     // html å³å˜åŒ–ä¹‹åçš„å†…å®¹
    //     console.log(html)
    // },

    // æ˜¯å¦æ˜¾ç¤ºæ·»åŠ ç½‘ç»œå›¾ç‰‡çš„ tab
    showLinkImg: true,

    // æ’å…¥ç½‘ç»œå›¾ç‰‡çš„å›è°ƒ
    linkImgCallback: function linkImgCallback(url) {
        // console.log(url)  // url å³æ’å…¥å›¾ç‰‡çš„åœ°å€
    },

    // é»˜è®¤ä¸Šä¼ å›¾ç‰‡ max size: 5M
    uploadImgMaxSize: 5 * 1024 * 1024,

    // é…ç½®ä¸€æ¬¡æœ€å¤šä¸Šä¼ å‡ ä¸ªå›¾ç‰‡
    // uploadImgMaxLength: 5,

    // ä¸Šä¼ å›¾ç‰‡ï¼Œæ˜¯å¦æ˜¾ç¤º base64 æ ¼å¼
    uploadImgShowBase64: false,

    // ä¸Šä¼ å›¾ç‰‡ï¼Œserver åœ°å€ï¼ˆå¦‚æœæœ‰å€¼ï¼Œåˆ™ base64 æ ¼å¼çš„é…ç½®åˆ™å¤±æ•ˆï¼‰
    // uploadImgServer: '/upload',

    // è‡ªå®šä¹‰é…ç½® filename
    uploadFileName: '',

    // ä¸Šä¼ å›¾ç‰‡çš„è‡ªå®šä¹‰å‚æ•°
    uploadImgParams: {
        // token: 'abcdef12345'
    },

    // ä¸Šä¼ å›¾ç‰‡çš„è‡ªå®šä¹‰header
    uploadImgHeaders: {
        // 'Accept': 'text/x-json'
    },

    // é…ç½® XHR withCredentials
    withCredentials: false,

    // è‡ªå®šä¹‰ä¸Šä¼ å›¾ç‰‡è¶…æ—¶æ—¶é—´ ms
    uploadImgTimeout: 10000,

    // ä¸Šä¼ å›¾ç‰‡ hook 
    uploadImgHooks: {
        // customInsert: function (insertLinkImg, result, editor) {
        //     console.log('customInsert')
        //     // å›¾ç‰‡ä¸Šä¼ å¹¶è¿”å›ç»“æœï¼Œè‡ªå®šä¹‰æ’å…¥å›¾ç‰‡çš„äº‹ä»¶ï¼Œè€Œä¸æ˜¯ç¼–è¾‘å™¨è‡ªåŠ¨æ’å…¥å›¾ç‰‡
        //     const data = result.data1 || []
        //     data.forEach(link => {
        //         insertLinkImg(link)
        //     })
        // },
        before: function before(xhr, editor, files) {
            // å›¾ç‰‡ä¸Šä¼ ä¹‹å‰è§¦å‘

            // å¦‚æœè¿”å›çš„ç»“æœæ˜¯ {prevent: true, msg: 'xxxx'} åˆ™è¡¨ç¤ºç”¨æˆ·æ”¾å¼ƒä¸Šä¼ 
            // return {
            //     prevent: true,
            //     msg: 'æ”¾å¼ƒä¸Šä¼ '
            // }
        },
        success: function success(xhr, editor, result) {
            // å›¾ç‰‡ä¸Šä¼ å¹¶è¿”å›ç»“æœï¼Œå›¾ç‰‡æ’å…¥æˆåŠŸä¹‹åè§¦å‘
        },
        fail: function fail(xhr, editor, result) {
            // å›¾ç‰‡ä¸Šä¼ å¹¶è¿”å›ç»“æœï¼Œä½†å›¾ç‰‡æ’å…¥é”™è¯¯æ—¶è§¦å‘
        },
        error: function error(xhr, editor) {
            // å›¾ç‰‡ä¸Šä¼ å‡ºé”™æ—¶è§¦å‘
        },
        timeout: function timeout(xhr, editor) {
            // å›¾ç‰‡ä¸Šä¼ è¶…æ—¶æ—¶è§¦å‘
        }
    },

    // æ˜¯å¦ä¸Šä¼ ä¸ƒç‰›äº‘ï¼Œé»˜è®¤ä¸º false
    qiniu: false

};

/*
    å·¥å…·
*/

// å’Œ UA ç›¸å…³çš„å±æ€§
var UA = {
    _ua: navigator.userAgent,

    // æ˜¯å¦ webkit
    isWebkit: function isWebkit() {
        var reg = /webkit/i;
        return reg.test(this._ua);
    },

    // æ˜¯å¦ IE
    isIE: function isIE() {
        return 'ActiveXObject' in window;
    }
};

// éå†å¯¹è±¡
function objForEach(obj, fn) {
    var key = void 0,
        result = void 0;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            result = fn.call(obj, key, obj[key]);
            if (result === false) {
                break;
            }
        }
    }
}

// éå†ç±»æ•°ç»„
function arrForEach(fakeArr, fn) {
    var i = void 0,
        item = void 0,
        result = void 0;
    var length = fakeArr.length || 0;
    for (i = 0; i < length; i++) {
        item = fakeArr[i];
        result = fn.call(fakeArr, item, i);
        if (result === false) {
            break;
        }
    }
}

// è·å–éšæœºæ•°
function getRandom(prefix) {
    return prefix + Math.random().toString().slice(2);
}

// æ›¿æ¢ html ç‰¹æ®Šå­—ç¬¦
function replaceHtmlSymbol(html) {
    if (html == null) {
        return '';
    }
    return html.replace(/</gm, '&lt;').replace(/>/gm, '&gt;').replace(/"/gm, '&quot;').replace(/(\r\n|\r|\n)/g, '<br/>');
}

// è¿”å›ç™¾åˆ†æ¯”çš„æ ¼å¼


// åˆ¤æ–­æ˜¯ä¸æ˜¯ function
function isFunction(fn) {
    return typeof fn === 'function';
}

/*
    bold-menu
*/
// æ„é€ å‡½æ•°
function Bold(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-bold"></i>\n        </div>');
    this.type = 'click';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Bold.prototype = {
    constructor: Bold,

    // ç‚¹å‡»äº‹ä»¶
    onClick: function onClick(e) {
        // ç‚¹å‡»èœå•å°†è§¦å‘è¿™é‡Œ

        var editor = this.editor;
        var isSeleEmpty = editor.selection.isSelectionEmpty();

        if (isSeleEmpty) {
            // é€‰åŒºæ˜¯ç©ºçš„ï¼Œæ’å…¥å¹¶é€‰ä¸­ä¸€ä¸ªâ€œç©ºç™½â€
            editor.selection.createEmptyRange();
        }

        // æ‰§è¡Œ bold å‘½ä»¤
        editor.cmd.do('bold');

        if (isSeleEmpty) {
            // éœ€è¦å°†é€‰å–æŠ˜å èµ·æ¥
            editor.selection.collapseRange();
            editor.selection.restoreSelection();
        }
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        if (editor.cmd.queryCommandState('bold')) {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    æ›¿æ¢å¤šè¯­è¨€
 */

var replaceLang = function (editor, str) {
    var langArgs = editor.config.langArgs || [];
    var result = str;

    langArgs.forEach(function (item) {
        var reg = item.reg;
        var val = item.val;

        if (reg.test(result)) {
            result = result.replace(reg, function () {
                return val;
            });
        }
    });

    return result;
};

/*
    droplist
*/
var _emptyFn = function _emptyFn() {};

// æ„é€ å‡½æ•°
function DropList(menu, opt) {
    var _this = this;

    // droplist æ‰€ä¾é™„çš„èœå•
    var editor = menu.editor;
    this.menu = menu;
    this.opt = opt;
    // å®¹å™¨
    var $container = $('<div class="w-e-droplist"></div>');

    // æ ‡é¢˜
    var $title = opt.$title;
    var titleHtml = void 0;
    if ($title) {
        // æ›¿æ¢å¤šè¯­è¨€
        titleHtml = $title.html();
        titleHtml = replaceLang(editor, titleHtml);
        $title.html(titleHtml);

        $title.addClass('w-e-dp-title');
        $container.append($title);
    }

    var list = opt.list || [];
    var type = opt.type || 'list'; // 'list' åˆ—è¡¨å½¢å¼ï¼ˆå¦‚â€œæ ‡é¢˜â€èœå•ï¼‰ / 'inline-block' å—çŠ¶å½¢å¼ï¼ˆå¦‚â€œé¢œè‰²â€èœå•ï¼‰
    var onClick = opt.onClick || _emptyFn;

    // åŠ å…¥ DOM å¹¶ç»‘å®šäº‹ä»¶
    var $list = $('<ul class="' + (type === 'list' ? 'w-e-list' : 'w-e-block') + '"></ul>');
    $container.append($list);
    list.forEach(function (item) {
        var $elem = item.$elem;

        // æ›¿æ¢å¤šè¯­è¨€
        var elemHtml = $elem.html();
        elemHtml = replaceLang(editor, elemHtml);
        $elem.html(elemHtml);

        var value = item.value;
        var $li = $('<li class="w-e-item"></li>');
        if ($elem) {
            $li.append($elem);
            $list.append($li);
            $li.on('click', function (e) {
                onClick(value);

                // éšè—
                _this.hideTimeoutId = setTimeout(function () {
                    _this.hide();
                }, 0);
            });
        }
    });

    // ç»‘å®šéšè—äº‹ä»¶
    $container.on('mouseleave', function (e) {
        _this.hideTimeoutId = setTimeout(function () {
            _this.hide();
        }, 0);
    });

    // è®°å½•å±æ€§
    this.$container = $container;

    // åŸºæœ¬å±æ€§
    this._rendered = false;
    this._show = false;
}

// åŸå‹
DropList.prototype = {
    constructor: DropList,

    // æ˜¾ç¤ºï¼ˆæ’å…¥DOMï¼‰
    show: function show() {
        if (this.hideTimeoutId) {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶éšè—
            clearTimeout(this.hideTimeoutId);
        }

        var menu = this.menu;
        var $menuELem = menu.$elem;
        var $container = this.$container;
        if (this._show) {
            return;
        }
        if (this._rendered) {
            // æ˜¾ç¤º
            $container.show();
        } else {
            // åŠ å…¥ DOM ä¹‹å‰å…ˆå®šä½ä½ç½®
            var menuHeight = $menuELem.getSizeData().height || 0;
            var width = this.opt.width || 100; // é»˜è®¤ä¸º 100
            $container.css('margin-top', menuHeight + 'px').css('width', width + 'px');

            // åŠ å…¥åˆ° DOM
            $menuELem.append($container);
            this._rendered = true;
        }

        // ä¿®æ”¹å±æ€§
        this._show = true;
    },

    // éšè—ï¼ˆç§»é™¤DOMï¼‰
    hide: function hide() {
        if (this.showTimeoutId) {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶æ˜¾ç¤º
            clearTimeout(this.showTimeoutId);
        }

        var $container = this.$container;
        if (!this._show) {
            return;
        }
        // éšè—å¹¶éœ€æ”¹å±æ€§
        $container.hide();
        this._show = false;
    }
};

/*
    menu - header
*/
// æ„é€ å‡½æ•°
function Head(editor) {
    var _this = this;

    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-header"></i></div>');
    this.type = 'droplist';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;

    // åˆå§‹åŒ– droplist
    this.droplist = new DropList(this, {
        width: 100,
        $title: $('<p>è®¾ç½®æ ‡é¢˜</p>'),
        type: 'list', // droplist ä»¥åˆ—è¡¨å½¢å¼å±•ç¤º
        list: [{ $elem: $('<h1>H1</h1>'), value: '<h1>' }, { $elem: $('<h2>H2</h2>'), value: '<h2>' }, { $elem: $('<h3>H3</h3>'), value: '<h3>' }, { $elem: $('<h4>H4</h4>'), value: '<h4>' }, { $elem: $('<h5>H5</h5>'), value: '<h5>' }, { $elem: $('<p>æ­£æ–‡</p>'), value: '<p>' }],
        onClick: function onClick(value) {
            // æ³¨æ„ this æ˜¯æŒ‡å‘å½“å‰çš„ Head å¯¹è±¡
            _this._command(value);
        }
    });
}

// åŸå‹
Head.prototype = {
    constructor: Head,

    // æ‰§è¡Œå‘½ä»¤
    _command: function _command(value) {
        var editor = this.editor;

        var $selectionElem = editor.selection.getSelectionContainerElem();
        if (editor.$textElem.equal($selectionElem)) {
            // ä¸èƒ½é€‰ä¸­å¤šè¡Œæ¥è®¾ç½®æ ‡é¢˜ï¼Œå¦åˆ™ä¼šå‡ºç°é—®é¢˜
            // ä¾‹å¦‚é€‰ä¸­çš„æ˜¯ <p>xxx</p><p>yyy</p> æ¥è®¾ç½®æ ‡é¢˜ï¼Œè®¾ç½®ä¹‹åä¼šæˆä¸º <h1>xxx<br>yyy</h1> ä¸ç¬¦åˆé¢„æœŸ
            return;
        }

        editor.cmd.do('formatBlock', value);
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        var reg = /^h/i;
        var cmdValue = editor.cmd.queryCommandValue('formatBlock');
        if (reg.test(cmdValue)) {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    menu - fontSize
*/

// æ„é€ å‡½æ•°
function FontSize(editor) {
    var _this = this;

    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-text-heigh"></i></div>');
    this.type = 'droplist';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;

    // åˆå§‹åŒ– droplist
    this.droplist = new DropList(this, {
        width: 160,
        $title: $('<p>å­—å·</p>'),
        type: 'list', // droplist ä»¥åˆ—è¡¨å½¢å¼å±•ç¤º
        list: [{ $elem: $('<span style="font-size: x-small;">x-small</span>'), value: '1' }, { $elem: $('<span style="font-size: small;">small</span>'), value: '2' }, { $elem: $('<span>normal</span>'), value: '3' }, { $elem: $('<span style="font-size: large;">large</span>'), value: '4' }, { $elem: $('<span style="font-size: x-large;">x-large</span>'), value: '5' }, { $elem: $('<span style="font-size: xx-large;">xx-large</span>'), value: '6' }],
        onClick: function onClick(value) {
            // æ³¨æ„ this æ˜¯æŒ‡å‘å½“å‰çš„ FontSize å¯¹è±¡
            _this._command(value);
        }
    });
}

// åŸå‹
FontSize.prototype = {
    constructor: FontSize,

    // æ‰§è¡Œå‘½ä»¤
    _command: function _command(value) {
        var editor = this.editor;
        editor.cmd.do('fontSize', value);
    }
};

/*
    menu - fontName
*/

// æ„é€ å‡½æ•°
function FontName(editor) {
    var _this = this;

    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-font"></i></div>');
    this.type = 'droplist';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;

    // è·å–é…ç½®çš„å­—ä½“
    var config = editor.config;
    var fontNames = config.fontNames || [];

    // åˆå§‹åŒ– droplist
    this.droplist = new DropList(this, {
        width: 100,
        $title: $('<p>å­—ä½“</p>'),
        type: 'list', // droplist ä»¥åˆ—è¡¨å½¢å¼å±•ç¤º
        list: fontNames.map(function (fontName) {
            return { $elem: $('<span style="font-family: ' + fontName + ';">' + fontName + '</span>'), value: fontName };
        }),
        onClick: function onClick(value) {
            // æ³¨æ„ this æ˜¯æŒ‡å‘å½“å‰çš„ FontName å¯¹è±¡
            _this._command(value);
        }
    });
}

// åŸå‹
FontName.prototype = {
    constructor: FontName,

    _command: function _command(value) {
        var editor = this.editor;
        editor.cmd.do('fontName', value);
    }
};

/*
    panel
*/

var emptyFn = function emptyFn() {};

// è®°å½•å·²ç»æ˜¾ç¤º panel çš„èœå•
var _isCreatedPanelMenus = [];

// æ„é€ å‡½æ•°
function Panel(menu, opt) {
    this.menu = menu;
    this.opt = opt;
}

// åŸå‹
Panel.prototype = {
    constructor: Panel,

    // æ˜¾ç¤ºï¼ˆæ’å…¥DOMï¼‰
    show: function show() {
        var _this = this;

        var menu = this.menu;
        if (_isCreatedPanelMenus.indexOf(menu) >= 0) {
            // è¯¥èœå•å·²ç»åˆ›å»ºäº† panel ä¸èƒ½å†åˆ›å»º
            return;
        }

        var editor = menu.editor;
        var $body = $('body');
        var $textContainerElem = editor.$textContainerElem;
        var opt = this.opt;

        // panel çš„å®¹å™¨
        var $container = $('<div class="w-e-panel-container"></div>');
        var width = opt.width || 300; // é»˜è®¤ 300px
        $container.css('width', width + 'px').css('margin-left', (0 - width) / 2 + 'px');

        // æ·»åŠ å…³é—­æŒ‰é’®
        var $closeBtn = $('<i class="w-e-icon-close w-e-panel-close"></i>');
        $container.append($closeBtn);
        $closeBtn.on('click', function () {
            _this.hide();
        });

        // å‡†å¤‡ tabs å®¹å™¨
        var $tabTitleContainer = $('<ul class="w-e-panel-tab-title"></ul>');
        var $tabContentContainer = $('<div class="w-e-panel-tab-content"></div>');
        $container.append($tabTitleContainer).append($tabContentContainer);

        // è®¾ç½®é«˜åº¦
        var height = opt.height;
        if (height) {
            $tabContentContainer.css('height', height + 'px').css('overflow-y', 'auto');
        }

        // tabs
        var tabs = opt.tabs || [];
        var tabTitleArr = [];
        var tabContentArr = [];
        tabs.forEach(function (tab, tabIndex) {
            if (!tab) {
                return;
            }
            var title = tab.title || '';
            var tpl = tab.tpl || '';

            // æ›¿æ¢å¤šè¯­è¨€
            title = replaceLang(editor, title);
            tpl = replaceLang(editor, tpl);

            // æ·»åŠ åˆ° DOM
            var $title = $('<li class="w-e-item">' + title + '</li>');
            $tabTitleContainer.append($title);
            var $content = $(tpl);
            $tabContentContainer.append($content);

            // è®°å½•åˆ°å†…å­˜
            $title._index = tabIndex;
            tabTitleArr.push($title);
            tabContentArr.push($content);

            // è®¾ç½® active é¡¹
            if (tabIndex === 0) {
                $title._active = true;
                $title.addClass('w-e-active');
            } else {
                $content.hide();
            }

            // ç»‘å®š tab çš„äº‹ä»¶
            $title.on('click', function (e) {
                if ($title._active) {
                    return;
                }
                // éšè—æ‰€æœ‰çš„ tab
                tabTitleArr.forEach(function ($title) {
                    $title._active = false;
                    $title.removeClass('w-e-active');
                });
                tabContentArr.forEach(function ($content) {
                    $content.hide();
                });

                // æ˜¾ç¤ºå½“å‰çš„ tab
                $title._active = true;
                $title.addClass('w-e-active');
                $content.show();
            });
        });

        // ç»‘å®šå…³é—­äº‹ä»¶
        $container.on('click', function (e) {
            // ç‚¹å‡»æ—¶é˜»æ­¢å†’æ³¡
            e.stopPropagation();
        });
        $body.on('click', function (e) {
            _this.hide();
        });

        // æ·»åŠ åˆ° DOM
        $textContainerElem.append($container);

        // ç»‘å®š opt çš„äº‹ä»¶ï¼Œåªæœ‰æ·»åŠ åˆ° DOM ä¹‹åæ‰èƒ½ç»‘å®šæˆåŠŸ
        tabs.forEach(function (tab, index) {
            if (!tab) {
                return;
            }
            var events = tab.events || [];
            events.forEach(function (event) {
                var selector = event.selector;
                var type = event.type;
                var fn = event.fn || emptyFn;
                var $content = tabContentArr[index];
                $content.find(selector).on(type, function (e) {
                    e.stopPropagation();
                    var needToHide = fn(e);
                    // æ‰§è¡Œå®Œäº‹ä»¶ä¹‹åï¼Œæ˜¯å¦è¦å…³é—­ panel
                    if (needToHide) {
                        _this.hide();
                    }
                });
            });
        });

        // focus ç¬¬ä¸€ä¸ª elem
        var $inputs = $container.find('input[type=text],textarea');
        if ($inputs.length) {
            $inputs.get(0).focus();
        }

        // æ·»åŠ åˆ°å±æ€§
        this.$container = $container;

        // éšè—å…¶ä»– panel
        this._hideOtherPanels();
        // è®°å½•è¯¥ menu å·²ç»åˆ›å»ºäº† panel
        _isCreatedPanelMenus.push(menu);
    },

    // éšè—ï¼ˆç§»é™¤DOMï¼‰
    hide: function hide() {
        var menu = this.menu;
        var $container = this.$container;
        if ($container) {
            $container.remove();
        }

        // å°†è¯¥ menu è®°å½•ä¸­ç§»é™¤
        _isCreatedPanelMenus = _isCreatedPanelMenus.filter(function (item) {
            if (item === menu) {
                return false;
            } else {
                return true;
            }
        });
    },

    // ä¸€ä¸ª panel å±•ç¤ºæ—¶ï¼Œéšè—å…¶ä»– panel
    _hideOtherPanels: function _hideOtherPanels() {
        if (!_isCreatedPanelMenus.length) {
            return;
        }
        _isCreatedPanelMenus.forEach(function (menu) {
            var panel = menu.panel || {};
            if (panel.hide) {
                panel.hide();
            }
        });
    }
};

/*
    menu - link
*/
// æ„é€ å‡½æ•°
function Link(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-link"></i></div>');
    this.type = 'panel';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Link.prototype = {
    constructor: Link,

    // ç‚¹å‡»äº‹ä»¶
    onClick: function onClick(e) {
        var editor = this.editor;
        var $linkelem = void 0;

        if (this._active) {
            // å½“å‰é€‰åŒºåœ¨é“¾æ¥é‡Œé¢
            $linkelem = editor.selection.getSelectionContainerElem();
            if (!$linkelem) {
                return;
            }
            // å°†è¯¥å…ƒç´ éƒ½åŒ…å«åœ¨é€‰å–ä¹‹å†…ï¼Œä»¥ä¾¿åé¢æ•´ä½“æ›¿æ¢
            editor.selection.createRangeByElem($linkelem);
            editor.selection.restoreSelection();
            // æ˜¾ç¤º panel
            this._createPanel($linkelem.text(), $linkelem.attr('href'));
        } else {
            // å½“å‰é€‰åŒºä¸åœ¨é“¾æ¥é‡Œé¢
            if (editor.selection.isSelectionEmpty()) {
                // é€‰åŒºæ˜¯ç©ºçš„ï¼Œæœªé€‰ä¸­å†…å®¹
                this._createPanel('', '');
            } else {
                // é€‰ä¸­å†…å®¹äº†
                this._createPanel(editor.selection.getSelectionText(), '');
            }
        }
    },

    // åˆ›å»º panel
    _createPanel: function _createPanel(text, link) {
        var _this = this;

        // panel ä¸­éœ€è¦ç”¨åˆ°çš„id
        var inputLinkId = getRandom('input-link');
        var inputTextId = getRandom('input-text');
        var btnOkId = getRandom('btn-ok');
        var btnDelId = getRandom('btn-del');

        // æ˜¯å¦æ˜¾ç¤ºâ€œåˆ é™¤é“¾æ¥â€
        var delBtnDisplay = this._active ? 'inline-block' : 'none';

        // åˆå§‹åŒ–å¹¶æ˜¾ç¤º panel
        var panel = new Panel(this, {
            width: 300,
            // panel ä¸­å¯åŒ…å«å¤šä¸ª tab
            tabs: [{
                // tab çš„æ ‡é¢˜
                title: 'é“¾æ¥',
                // æ¨¡æ¿
                tpl: '<div>\n                            <input id="' + inputTextId + '" type="text" class="block" value="' + text + '" placeholder="\u94FE\u63A5\u6587\u5B57"/></td>\n                            <input id="' + inputLinkId + '" type="text" class="block" value="' + link + '" placeholder="http://..."/></td>\n                            <div class="w-e-button-container">\n                                <button id="' + btnOkId + '" class="right">\u63D2\u5165</button>\n                                <button id="' + btnDelId + '" class="gray right" style="display:' + delBtnDisplay + '">\u5220\u9664\u94FE\u63A5</button>\n                            </div>\n                        </div>',
                // äº‹ä»¶ç»‘å®š
                events: [
                // æ’å…¥é“¾æ¥
                {
                    selector: '#' + btnOkId,
                    type: 'click',
                    fn: function fn() {
                        // æ‰§è¡Œæ’å…¥é“¾æ¥
                        var $link = $('#' + inputLinkId);
                        var $text = $('#' + inputTextId);
                        var link = $link.val();
                        var text = $text.val();
                        _this._insertLink(text, link);

                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                },
                // åˆ é™¤é“¾æ¥
                {
                    selector: '#' + btnDelId,
                    type: 'click',
                    fn: function fn() {
                        // æ‰§è¡Œåˆ é™¤é“¾æ¥
                        _this._delLink();

                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }]
            } // tab end
            ] // tabs end
        });

        // æ˜¾ç¤º panel
        panel.show();

        // è®°å½•å±æ€§
        this.panel = panel;
    },

    // åˆ é™¤å½“å‰é“¾æ¥
    _delLink: function _delLink() {
        if (!this._active) {
            return;
        }
        var editor = this.editor;
        var $selectionELem = editor.selection.getSelectionContainerElem();
        if (!$selectionELem) {
            return;
        }
        var selectionText = editor.selection.getSelectionText();
        editor.cmd.do('insertHTML', '<span>' + selectionText + '</span>');
    },

    // æ’å…¥é“¾æ¥
    _insertLink: function _insertLink(text, link) {
        var editor = this.editor;
        var config = editor.config;
        var linkCheck = config.linkCheck;
        var checkResult = true; // é»˜è®¤ä¸º true
        if (linkCheck && typeof linkCheck === 'function') {
            checkResult = linkCheck(text, link);
        }
        if (checkResult === true) {
            editor.cmd.do('insertHTML', '<a href="' + link + '" target="_blank">' + text + '</a>');
        } else {
            alert(checkResult);
        }
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        var $selectionELem = editor.selection.getSelectionContainerElem();
        if (!$selectionELem) {
            return;
        }
        if ($selectionELem.getNodeName() === 'A') {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    italic-menu
*/
// æ„é€ å‡½æ•°
function Italic(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-italic"></i>\n        </div>');
    this.type = 'click';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Italic.prototype = {
    constructor: Italic,

    // ç‚¹å‡»äº‹ä»¶
    onClick: function onClick(e) {
        // ç‚¹å‡»èœå•å°†è§¦å‘è¿™é‡Œ

        var editor = this.editor;
        var isSeleEmpty = editor.selection.isSelectionEmpty();

        if (isSeleEmpty) {
            // é€‰åŒºæ˜¯ç©ºçš„ï¼Œæ’å…¥å¹¶é€‰ä¸­ä¸€ä¸ªâ€œç©ºç™½â€
            editor.selection.createEmptyRange();
        }

        // æ‰§è¡Œ italic å‘½ä»¤
        editor.cmd.do('italic');

        if (isSeleEmpty) {
            // éœ€è¦å°†é€‰å–æŠ˜å èµ·æ¥
            editor.selection.collapseRange();
            editor.selection.restoreSelection();
        }
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        if (editor.cmd.queryCommandState('italic')) {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    redo-menu
*/
// æ„é€ å‡½æ•°
function Redo(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-redo"></i>\n        </div>');
    this.type = 'click';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Redo.prototype = {
    constructor: Redo,

    // ç‚¹å‡»äº‹ä»¶
    onClick: function onClick(e) {
        // ç‚¹å‡»èœå•å°†è§¦å‘è¿™é‡Œ

        var editor = this.editor;

        // æ‰§è¡Œ redo å‘½ä»¤
        editor.cmd.do('redo');
    }
};

/*
    strikeThrough-menu
*/
// æ„é€ å‡½æ•°
function StrikeThrough(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-strikethrough"></i>\n        </div>');
    this.type = 'click';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
StrikeThrough.prototype = {
    constructor: StrikeThrough,

    // ç‚¹å‡»äº‹ä»¶
    onClick: function onClick(e) {
        // ç‚¹å‡»èœå•å°†è§¦å‘è¿™é‡Œ

        var editor = this.editor;
        var isSeleEmpty = editor.selection.isSelectionEmpty();

        if (isSeleEmpty) {
            // é€‰åŒºæ˜¯ç©ºçš„ï¼Œæ’å…¥å¹¶é€‰ä¸­ä¸€ä¸ªâ€œç©ºç™½â€
            editor.selection.createEmptyRange();
        }

        // æ‰§è¡Œ strikeThrough å‘½ä»¤
        editor.cmd.do('strikeThrough');

        if (isSeleEmpty) {
            // éœ€è¦å°†é€‰å–æŠ˜å èµ·æ¥
            editor.selection.collapseRange();
            editor.selection.restoreSelection();
        }
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        if (editor.cmd.queryCommandState('strikeThrough')) {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    underline-menu
*/
// æ„é€ å‡½æ•°
function Underline(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-underline"></i>\n        </div>');
    this.type = 'click';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Underline.prototype = {
    constructor: Underline,

    // ç‚¹å‡»äº‹ä»¶
    onClick: function onClick(e) {
        // ç‚¹å‡»èœå•å°†è§¦å‘è¿™é‡Œ

        var editor = this.editor;
        var isSeleEmpty = editor.selection.isSelectionEmpty();

        if (isSeleEmpty) {
            // é€‰åŒºæ˜¯ç©ºçš„ï¼Œæ’å…¥å¹¶é€‰ä¸­ä¸€ä¸ªâ€œç©ºç™½â€
            editor.selection.createEmptyRange();
        }

        // æ‰§è¡Œ underline å‘½ä»¤
        editor.cmd.do('underline');

        if (isSeleEmpty) {
            // éœ€è¦å°†é€‰å–æŠ˜å èµ·æ¥
            editor.selection.collapseRange();
            editor.selection.restoreSelection();
        }
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        if (editor.cmd.queryCommandState('underline')) {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    undo-menu
*/
// æ„é€ å‡½æ•°
function Undo(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-undo"></i>\n        </div>');
    this.type = 'click';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Undo.prototype = {
    constructor: Undo,

    // ç‚¹å‡»äº‹ä»¶
    onClick: function onClick(e) {
        // ç‚¹å‡»èœå•å°†è§¦å‘è¿™é‡Œ

        var editor = this.editor;

        // æ‰§è¡Œ undo å‘½ä»¤
        editor.cmd.do('undo');
    }
};

/*
    menu - list
*/
// æ„é€ å‡½æ•°
function List(editor) {
    var _this = this;

    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-list2"></i></div>');
    this.type = 'droplist';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;

    // åˆå§‹åŒ– droplist
    this.droplist = new DropList(this, {
        width: 120,
        $title: $('<p>è®¾ç½®åˆ—è¡¨</p>'),
        type: 'list', // droplist ä»¥åˆ—è¡¨å½¢å¼å±•ç¤º
        list: [{ $elem: $('<span><i class="w-e-icon-list-numbered"></i> æœ‰åºåˆ—è¡¨</span>'), value: 'insertOrderedList' }, { $elem: $('<span><i class="w-e-icon-list2"></i> æ— åºåˆ—è¡¨</span>'), value: 'insertUnorderedList' }],
        onClick: function onClick(value) {
            // æ³¨æ„ this æ˜¯æŒ‡å‘å½“å‰çš„ List å¯¹è±¡
            _this._command(value);
        }
    });
}

// åŸå‹
List.prototype = {
    constructor: List,

    // æ‰§è¡Œå‘½ä»¤
    _command: function _command(value) {
        var editor = this.editor;
        var $textElem = editor.$textElem;
        editor.selection.restoreSelection();
        if (editor.cmd.queryCommandState(value)) {
            return;
        }
        editor.cmd.do(value);

        // éªŒè¯åˆ—è¡¨æ˜¯å¦è¢«åŒ…è£¹åœ¨ <p> ä¹‹å†…
        var $selectionElem = editor.selection.getSelectionContainerElem();
        if ($selectionElem.getNodeName() === 'LI') {
            $selectionElem = $selectionElem.parent();
        }
        if (/^ol|ul$/i.test($selectionElem.getNodeName()) === false) {
            return;
        }
        if ($selectionElem.equal($textElem)) {
            // è¯æ˜æ˜¯é¡¶çº§æ ‡ç­¾ï¼Œæ²¡æœ‰è¢« <p> åŒ…è£¹
            return;
        }
        var $parent = $selectionElem.parent();
        if ($parent.equal($textElem)) {
            // $parent æ˜¯é¡¶çº§æ ‡ç­¾ï¼Œä¸èƒ½åˆ é™¤
            return;
        }

        $selectionElem.insertAfter($parent);
        $parent.remove();
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        if (editor.cmd.queryCommandState('insertUnOrderedList') || editor.cmd.queryCommandState('insertOrderedList')) {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    menu - justify
*/
// æ„é€ å‡½æ•°
function Justify(editor) {
    var _this = this;

    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-paragraph-left"></i></div>');
    this.type = 'droplist';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;

    // åˆå§‹åŒ– droplist
    this.droplist = new DropList(this, {
        width: 100,
        $title: $('<p>å¯¹é½æ–¹å¼</p>'),
        type: 'list', // droplist ä»¥åˆ—è¡¨å½¢å¼å±•ç¤º
        list: [{ $elem: $('<span><i class="w-e-icon-paragraph-left"></i> é å·¦</span>'), value: 'justifyLeft' }, { $elem: $('<span><i class="w-e-icon-paragraph-center"></i> å±…ä¸­</span>'), value: 'justifyCenter' }, { $elem: $('<span><i class="w-e-icon-paragraph-right"></i> é å³</span>'), value: 'justifyRight' }],
        onClick: function onClick(value) {
            // æ³¨æ„ this æ˜¯æŒ‡å‘å½“å‰çš„ List å¯¹è±¡
            _this._command(value);
        }
    });
}

// åŸå‹
Justify.prototype = {
    constructor: Justify,

    // æ‰§è¡Œå‘½ä»¤
    _command: function _command(value) {
        var editor = this.editor;
        editor.cmd.do(value);
    }
};

/*
    menu - Forecolor
*/
// æ„é€ å‡½æ•°
function ForeColor(editor) {
    var _this = this;

    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-pencil2"></i></div>');
    this.type = 'droplist';

    // è·å–é…ç½®çš„é¢œè‰²
    var config = editor.config;
    var colors = config.colors || [];

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;

    // åˆå§‹åŒ– droplist
    this.droplist = new DropList(this, {
        width: 120,
        $title: $('<p>æ–‡å­—é¢œè‰²</p>'),
        type: 'inline-block', // droplist å†…å®¹ä»¥ block å½¢å¼å±•ç¤º
        list: colors.map(function (color) {
            return { $elem: $('<i style="color:' + color + ';" class="w-e-icon-pencil2"></i>'), value: color };
        }),
        onClick: function onClick(value) {
            // æ³¨æ„ this æ˜¯æŒ‡å‘å½“å‰çš„ ForeColor å¯¹è±¡
            _this._command(value);
        }
    });
}

// åŸå‹
ForeColor.prototype = {
    constructor: ForeColor,

    // æ‰§è¡Œå‘½ä»¤
    _command: function _command(value) {
        var editor = this.editor;
        editor.cmd.do('foreColor', value);
    }
};

/*
    menu - BackColor
*/
// æ„é€ å‡½æ•°
function BackColor(editor) {
    var _this = this;

    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-paint-brush"></i></div>');
    this.type = 'droplist';

    // è·å–é…ç½®çš„é¢œè‰²
    var config = editor.config;
    var colors = config.colors || [];

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;

    // åˆå§‹åŒ– droplist
    this.droplist = new DropList(this, {
        width: 120,
        $title: $('<p>èƒŒæ™¯è‰²</p>'),
        type: 'inline-block', // droplist å†…å®¹ä»¥ block å½¢å¼å±•ç¤º
        list: colors.map(function (color) {
            return { $elem: $('<i style="color:' + color + ';" class="w-e-icon-paint-brush"></i>'), value: color };
        }),
        onClick: function onClick(value) {
            // æ³¨æ„ this æ˜¯æŒ‡å‘å½“å‰çš„ BackColor å¯¹è±¡
            _this._command(value);
        }
    });
}

// åŸå‹
BackColor.prototype = {
    constructor: BackColor,

    // æ‰§è¡Œå‘½ä»¤
    _command: function _command(value) {
        var editor = this.editor;
        editor.cmd.do('backColor', value);
    }
};

/*
    menu - quote
*/
// æ„é€ å‡½æ•°
function Quote(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-quotes-left"></i>\n        </div>');
    this.type = 'click';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Quote.prototype = {
    constructor: Quote,

    onClick: function onClick(e) {
        var editor = this.editor;
        var $selectionElem = editor.selection.getSelectionContainerElem();
        var nodeName = $selectionElem.getNodeName();

        if (!UA.isIE()) {
            if (nodeName === 'BLOCKQUOTE') {
                // æ’¤é”€ quote
                editor.cmd.do('formatBlock', '<P>');
            } else {
                // è½¬æ¢ä¸º quote
                editor.cmd.do('formatBlock', '<BLOCKQUOTE>');
            }
            return;
        }

        // IE ä¸­ä¸æ”¯æŒ formatBlock <BLOCKQUOTE> ï¼Œè¦ç”¨å…¶ä»–æ–¹å¼å…¼å®¹
        var content = void 0,
            $targetELem = void 0;
        if (nodeName === 'P') {
            // å°† P è½¬æ¢ä¸º quote
            content = $selectionElem.text();
            $targetELem = $('<blockquote>' + content + '</blockquote>');
            $targetELem.insertAfter($selectionElem);
            $selectionElem.remove();
            return;
        }
        if (nodeName === 'BLOCKQUOTE') {
            // æ’¤é”€ quote
            content = $selectionElem.text();
            $targetELem = $('<p>' + content + '</p>');
            $targetELem.insertAfter($selectionElem);
            $selectionElem.remove();
        }
    },

    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        var reg = /^BLOCKQUOTE$/i;
        var cmdValue = editor.cmd.queryCommandValue('formatBlock');
        if (reg.test(cmdValue)) {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    menu - code
*/
// æ„é€ å‡½æ•°
function Code(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-terminal"></i>\n        </div>');
    this.type = 'panel';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Code.prototype = {
    constructor: Code,

    onClick: function onClick(e) {
        var editor = this.editor;
        var $startElem = editor.selection.getSelectionStartElem();
        var $endElem = editor.selection.getSelectionEndElem();
        var isSeleEmpty = editor.selection.isSelectionEmpty();
        var selectionText = editor.selection.getSelectionText();
        var $code = void 0;

        if (!$startElem.equal($endElem)) {
            // è·¨å…ƒç´ é€‰æ‹©ï¼Œä¸åšå¤„ç†
            editor.selection.restoreSelection();
            return;
        }
        if (!isSeleEmpty) {
            // é€‰å–ä¸æ˜¯ç©ºï¼Œç”¨ <code> åŒ…è£¹å³å¯
            $code = $('<code>' + selectionText + '</code>');
            editor.cmd.do('insertElem', $code);
            editor.selection.createRangeByElem($code, false);
            editor.selection.restoreSelection();
            return;
        }

        // é€‰å–æ˜¯ç©ºï¼Œä¸”æ²¡æœ‰å¤¸å…ƒç´ é€‰æ‹©ï¼Œåˆ™æ’å…¥ <pre><code></code></prev>
        if (this._active) {
            // é€‰ä¸­çŠ¶æ€ï¼Œå°†ç¼–è¾‘å†…å®¹
            this._createPanel($startElem.html());
        } else {
            // æœªé€‰ä¸­çŠ¶æ€ï¼Œå°†åˆ›å»ºå†…å®¹
            this._createPanel();
        }
    },

    _createPanel: function _createPanel(value) {
        var _this = this;

        // value - è¦ç¼–è¾‘çš„å†…å®¹
        value = value || '';
        var type = !value ? 'new' : 'edit';
        var textId = getRandom('texxt');
        var btnId = getRandom('btn');

        var panel = new Panel(this, {
            width: 500,
            // ä¸€ä¸ª Panel åŒ…å«å¤šä¸ª tab
            tabs: [{
                // æ ‡é¢˜
                title: 'æ’å…¥ä»£ç ',
                // æ¨¡æ¿
                tpl: '<div>\n                        <textarea id="' + textId + '" style="height:145px;;">' + value + '</textarea>\n                        <div class="w-e-button-container">\n                            <button id="' + btnId + '" class="right">\u63D2\u5165</button>\n                        </div>\n                    <div>',
                // äº‹ä»¶ç»‘å®š
                events: [
                // æ’å…¥ä»£ç 
                {
                    selector: '#' + btnId,
                    type: 'click',
                    fn: function fn() {
                        var $text = $('#' + textId);
                        var text = $text.val() || $text.html();
                        text = replaceHtmlSymbol(text);
                        if (type === 'new') {
                            // æ–°æ’å…¥
                            _this._insertCode(text);
                        } else {
                            // ç¼–è¾‘æ›´æ–°
                            _this._updateCode(text);
                        }

                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }]
            } // first tab end
            ] // tabs end
        }); // new Panel end

        // æ˜¾ç¤º panel
        panel.show();

        // è®°å½•å±æ€§
        this.panel = panel;
    },

    // æ’å…¥ä»£ç 
    _insertCode: function _insertCode(value) {
        var editor = this.editor;
        editor.cmd.do('insertHTML', '<pre><code>' + value + '</code></pre><p><br></p>');
    },

    // æ›´æ–°ä»£ç 
    _updateCode: function _updateCode(value) {
        var editor = this.editor;
        var $selectionELem = editor.selection.getSelectionContainerElem();
        if (!$selectionELem) {
            return;
        }
        $selectionELem.html(value);
        editor.selection.restoreSelection();
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        var $selectionELem = editor.selection.getSelectionContainerElem();
        if (!$selectionELem) {
            return;
        }
        var $parentElem = $selectionELem.parent();
        if ($selectionELem.getNodeName() === 'CODE' && $parentElem.getNodeName() === 'PRE') {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    menu - emoticon
*/
// æ„é€ å‡½æ•°
function Emoticon(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu">\n            <i class="w-e-icon-happy"></i>\n        </div>');
    this.type = 'panel';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Emoticon.prototype = {
    constructor: Emoticon,

    onClick: function onClick() {
        this._createPanel();
    },

    _createPanel: function _createPanel() {
        var _this = this;

        var editor = this.editor;
        var config = editor.config;
        // è·å–è¡¨æƒ…é…ç½®
        var emotions = config.emotions || [];

        // åˆ›å»ºè¡¨æƒ… dropPanel çš„é…ç½®
        var tabConfig = [];
        emotions.forEach(function (emotData) {
            var emotType = emotData.type;
            var content = emotData.content || [];

            // è¿™ä¸€ç»„è¡¨æƒ…æœ€ç»ˆæ‹¼æ¥å‡ºæ¥çš„ html
            var faceHtml = '';

            // emoji è¡¨æƒ…
            if (emotType === 'emoji') {
                content.forEach(function (item) {
                    if (item) {
                        faceHtml += '<span class="w-e-item">' + item + '</span>';
                    }
                });
            }
            // å›¾ç‰‡è¡¨æƒ…
            if (emotType === 'image') {
                content.forEach(function (item) {
                    var src = item.src;
                    var alt = item.alt;
                    if (src) {
                        // åŠ ä¸€ä¸ª data-w-e å±æ€§ï¼Œç‚¹å‡»å›¾ç‰‡çš„æ—¶å€™ä¸å†æç¤ºç¼–è¾‘å›¾ç‰‡
                        faceHtml += '<span class="w-e-item"><img src="' + src + '" alt="' + alt + '" data-w-e="1"/></span>';
                    }
                });
            }

            tabConfig.push({
                title: emotData.title,
                tpl: '<div class="w-e-emoticon-container">' + faceHtml + '</div>',
                events: [{
                    selector: 'span.w-e-item',
                    type: 'click',
                    fn: function fn(e) {
                        var target = e.target;
                        var $target = $(target);
                        var nodeName = $target.getNodeName();

                        var insertHtml = void 0;
                        if (nodeName === 'IMG') {
                            // æ’å…¥å›¾ç‰‡
                            insertHtml = $target.parent().html();
                        } else {
                            // æ’å…¥ emoji
                            insertHtml = '<span>' + $target.html() + '</span>';
                        }

                        _this._insert(insertHtml);
                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }]
            });
        });

        var panel = new Panel(this, {
            width: 300,
            height: 200,
            // ä¸€ä¸ª Panel åŒ…å«å¤šä¸ª tab
            tabs: tabConfig
        });

        // æ˜¾ç¤º panel
        panel.show();

        // è®°å½•å±æ€§
        this.panel = panel;
    },

    // æ’å…¥è¡¨æƒ…
    _insert: function _insert(emotHtml) {
        var editor = this.editor;
        editor.cmd.do('insertHTML', emotHtml);
    }
};

/*
    menu - table
*/
// æ„é€ å‡½æ•°
function Table(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-table2"></i></div>');
    this.type = 'panel';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Table.prototype = {
    constructor: Table,

    onClick: function onClick() {
        if (this._active) {
            // ç¼–è¾‘ç°æœ‰è¡¨æ ¼
            this._createEditPanel();
        } else {
            // æ’å…¥æ–°è¡¨æ ¼
            this._createInsertPanel();
        }
    },

    // åˆ›å»ºæ’å…¥æ–°è¡¨æ ¼çš„ panel
    _createInsertPanel: function _createInsertPanel() {
        var _this = this;

        // ç”¨åˆ°çš„ id
        var btnInsertId = getRandom('btn');
        var textRowNum = getRandom('row');
        var textColNum = getRandom('col');

        var panel = new Panel(this, {
            width: 250,
            // panel åŒ…å«å¤šä¸ª tab
            tabs: [{
                // æ ‡é¢˜
                title: 'æ’å…¥è¡¨æ ¼',
                // æ¨¡æ¿
                tpl: '<div>\n                        <p style="text-align:left; padding:5px 0;">\n                            \u521B\u5EFA\n                            <input id="' + textRowNum + '" type="text" value="5" style="width:40px;text-align:center;"/>\n                            \u884C\n                            <input id="' + textColNum + '" type="text" value="5" style="width:40px;text-align:center;"/>\n                            \u5217\u7684\u8868\u683C\n                        </p>\n                        <div class="w-e-button-container">\n                            <button id="' + btnInsertId + '" class="right">\u63D2\u5165</button>\n                        </div>\n                    </div>',
                // äº‹ä»¶ç»‘å®š
                events: [{
                    // ç‚¹å‡»æŒ‰é’®ï¼Œæ’å…¥è¡¨æ ¼
                    selector: '#' + btnInsertId,
                    type: 'click',
                    fn: function fn() {
                        var rowNum = parseInt($('#' + textRowNum).val());
                        var colNum = parseInt($('#' + textColNum).val());

                        if (rowNum && colNum && rowNum > 0 && colNum > 0) {
                            // form æ•°æ®æœ‰æ•ˆ
                            _this._insert(rowNum, colNum);
                        }

                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }]
            } // first tab end
            ] // tabs end
        }); // panel end

        // å±•ç¤º panel
        panel.show();

        // è®°å½•å±æ€§
        this.panel = panel;
    },

    // æ’å…¥è¡¨æ ¼
    _insert: function _insert(rowNum, colNum) {
        // æ‹¼æ¥ table æ¨¡æ¿
        var r = void 0,
            c = void 0;
        var html = '<table border="0" width="100%" cellpadding="0" cellspacing="0">';
        for (r = 0; r < rowNum; r++) {
            html += '<tr>';
            if (r === 0) {
                for (c = 0; c < colNum; c++) {
                    html += '<th>&nbsp;</th>';
                }
            } else {
                for (c = 0; c < colNum; c++) {
                    html += '<td>&nbsp;</td>';
                }
            }
            html += '</tr>';
        }
        html += '</table><p><br></p>';

        // æ‰§è¡Œå‘½ä»¤
        var editor = this.editor;
        editor.cmd.do('insertHTML', html);

        // é˜²æ­¢ firefox ä¸‹å‡ºç° resize çš„æ§åˆ¶ç‚¹
        editor.cmd.do('enableObjectResizing', false);
        editor.cmd.do('enableInlineTableEditing', false);
    },

    // åˆ›å»ºç¼–è¾‘è¡¨æ ¼çš„ panel
    _createEditPanel: function _createEditPanel() {
        var _this2 = this;

        // å¯ç”¨çš„ id
        var addRowBtnId = getRandom('add-row');
        var addColBtnId = getRandom('add-col');
        var delRowBtnId = getRandom('del-row');
        var delColBtnId = getRandom('del-col');
        var delTableBtnId = getRandom('del-table');

        // åˆ›å»º panel å¯¹è±¡
        var panel = new Panel(this, {
            width: 320,
            // panel åŒ…å«å¤šä¸ª tab
            tabs: [{
                // æ ‡é¢˜
                title: 'ç¼–è¾‘è¡¨æ ¼',
                // æ¨¡æ¿
                tpl: '<div>\n                        <div class="w-e-button-container" style="border-bottom:1px solid #f1f1f1;padding-bottom:5px;margin-bottom:5px;">\n                            <button id="' + addRowBtnId + '" class="left">\u589E\u52A0\u884C</button>\n                            <button id="' + delRowBtnId + '" class="red left">\u5220\u9664\u884C</button>\n                            <button id="' + addColBtnId + '" class="left">\u589E\u52A0\u5217</button>\n                            <button id="' + delColBtnId + '" class="red left">\u5220\u9664\u5217</button>\n                        </div>\n                        <div class="w-e-button-container">\n                            <button id="' + delTableBtnId + '" class="gray left">\u5220\u9664\u8868\u683C</button>\n                        </dv>\n                    </div>',
                // äº‹ä»¶ç»‘å®š
                events: [{
                    // å¢åŠ è¡Œ
                    selector: '#' + addRowBtnId,
                    type: 'click',
                    fn: function fn() {
                        _this2._addRow();
                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }, {
                    // å¢åŠ åˆ—
                    selector: '#' + addColBtnId,
                    type: 'click',
                    fn: function fn() {
                        _this2._addCol();
                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }, {
                    // åˆ é™¤è¡Œ
                    selector: '#' + delRowBtnId,
                    type: 'click',
                    fn: function fn() {
                        _this2._delRow();
                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }, {
                    // åˆ é™¤åˆ—
                    selector: '#' + delColBtnId,
                    type: 'click',
                    fn: function fn() {
                        _this2._delCol();
                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }, {
                    // åˆ é™¤è¡¨æ ¼
                    selector: '#' + delTableBtnId,
                    type: 'click',
                    fn: function fn() {
                        _this2._delTable();
                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }]
            }]
        });
        // æ˜¾ç¤º panel
        panel.show();
    },

    // è·å–é€‰ä¸­çš„å•å…ƒæ ¼çš„ä½ç½®ä¿¡æ¯
    _getLocationData: function _getLocationData() {
        var result = {};
        var editor = this.editor;
        var $selectionELem = editor.selection.getSelectionContainerElem();
        if (!$selectionELem) {
            return;
        }
        var nodeName = $selectionELem.getNodeName();
        if (nodeName !== 'TD' && nodeName !== 'TH') {
            return;
        }

        // è·å– td index
        var $tr = $selectionELem.parent();
        var $tds = $tr.children();
        var tdLength = $tds.length;
        $tds.forEach(function (td, index) {
            if (td === $selectionELem[0]) {
                // è®°å½•å¹¶è·³å‡ºå¾ªç¯
                result.td = {
                    index: index,
                    elem: td,
                    length: tdLength
                };
                return false;
            }
        });

        // è·å– tr index
        var $tbody = $tr.parent();
        var $trs = $tbody.children();
        var trLength = $trs.length;
        $trs.forEach(function (tr, index) {
            if (tr === $tr[0]) {
                // è®°å½•å¹¶è·³å‡ºå¾ªç¯
                result.tr = {
                    index: index,
                    elem: tr,
                    length: trLength
                };
                return false;
            }
        });

        // è¿”å›ç»“æœ
        return result;
    },

    // å¢åŠ è¡Œ
    _addRow: function _addRow() {
        // è·å–å½“å‰å•å…ƒæ ¼çš„ä½ç½®ä¿¡æ¯
        var locationData = this._getLocationData();
        if (!locationData) {
            return;
        }
        var trData = locationData.tr;
        var $currentTr = $(trData.elem);
        var tdData = locationData.td;
        var tdLength = tdData.length;

        // æ‹¼æ¥å³å°†æ’å…¥çš„å­—ç¬¦ä¸²
        var newTr = document.createElement('tr');
        var tpl = '',
            i = void 0;
        for (i = 0; i < tdLength; i++) {
            tpl += '<td>&nbsp;</td>';
        }
        newTr.innerHTML = tpl;
        // æ’å…¥
        $(newTr).insertAfter($currentTr);
    },

    // å¢åŠ åˆ—
    _addCol: function _addCol() {
        // è·å–å½“å‰å•å…ƒæ ¼çš„ä½ç½®ä¿¡æ¯
        var locationData = this._getLocationData();
        if (!locationData) {
            return;
        }
        var trData = locationData.tr;
        var tdData = locationData.td;
        var tdIndex = tdData.index;
        var $currentTr = $(trData.elem);
        var $trParent = $currentTr.parent();
        var $trs = $trParent.children();

        // éå†æ‰€æœ‰è¡Œ
        $trs.forEach(function (tr) {
            var $tr = $(tr);
            var $tds = $tr.children();
            var $currentTd = $tds.get(tdIndex);
            var name = $currentTd.getNodeName().toLowerCase();

            // new ä¸€ä¸ª tdï¼Œå¹¶æ’å…¥
            var newTd = document.createElement(name);
            $(newTd).insertAfter($currentTd);
        });
    },

    // åˆ é™¤è¡Œ
    _delRow: function _delRow() {
        // è·å–å½“å‰å•å…ƒæ ¼çš„ä½ç½®ä¿¡æ¯
        var locationData = this._getLocationData();
        if (!locationData) {
            return;
        }
        var trData = locationData.tr;
        var $currentTr = $(trData.elem);
        $currentTr.remove();
    },

    // åˆ é™¤åˆ—
    _delCol: function _delCol() {
        // è·å–å½“å‰å•å…ƒæ ¼çš„ä½ç½®ä¿¡æ¯
        var locationData = this._getLocationData();
        if (!locationData) {
            return;
        }
        var trData = locationData.tr;
        var tdData = locationData.td;
        var tdIndex = tdData.index;
        var $currentTr = $(trData.elem);
        var $trParent = $currentTr.parent();
        var $trs = $trParent.children();

        // éå†æ‰€æœ‰è¡Œ
        $trs.forEach(function (tr) {
            var $tr = $(tr);
            var $tds = $tr.children();
            var $currentTd = $tds.get(tdIndex);
            // åˆ é™¤
            $currentTd.remove();
        });
    },

    // åˆ é™¤è¡¨æ ¼
    _delTable: function _delTable() {
        var editor = this.editor;
        var $selectionELem = editor.selection.getSelectionContainerElem();
        if (!$selectionELem) {
            return;
        }
        var $table = $selectionELem.parentUntil('table');
        if (!$table) {
            return;
        }
        $table.remove();
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        var $selectionELem = editor.selection.getSelectionContainerElem();
        if (!$selectionELem) {
            return;
        }
        var nodeName = $selectionELem.getNodeName();
        if (nodeName === 'TD' || nodeName === 'TH') {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    menu - video
*/
// æ„é€ å‡½æ•°
function Video(editor) {
    this.editor = editor;
    this.$elem = $('<div class="w-e-menu"><i class="w-e-icon-play"></i></div>');
    this.type = 'panel';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Video.prototype = {
    constructor: Video,

    onClick: function onClick() {
        this._createPanel();
    },

    _createPanel: function _createPanel() {
        var _this = this;

        // åˆ›å»º id
        var textValId = getRandom('text-val');
        var btnId = getRandom('btn');

        // åˆ›å»º panel
        var panel = new Panel(this, {
            width: 350,
            // ä¸€ä¸ª panel å¤šä¸ª tab
            tabs: [{
                // æ ‡é¢˜
                title: 'æ’å…¥è§†é¢‘',
                // æ¨¡æ¿
                tpl: '<div>\n                        <input id="' + textValId + '" type="text" class="block" placeholder="\u683C\u5F0F\u5982\uFF1A<iframe src=... ></iframe>"/>\n                        <div class="w-e-button-container">\n                            <button id="' + btnId + '" class="right">\u63D2\u5165</button>\n                        </div>\n                    </div>',
                // äº‹ä»¶ç»‘å®š
                events: [{
                    selector: '#' + btnId,
                    type: 'click',
                    fn: function fn() {
                        var $text = $('#' + textValId);
                        var val = $text.val().trim();

                        // æµ‹è¯•ç”¨è§†é¢‘åœ°å€
                        // <iframe height=498 width=510 src='http://player.youku.com/embed/XMjcwMzc3MzM3Mg==' frameborder=0 'allowfullscreen'></iframe>

                        if (val) {
                            // æ’å…¥è§†é¢‘
                            _this._insert(val);
                        }

                        // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                        return true;
                    }
                }]
            } // first tab end
            ] // tabs end
        }); // panel end

        // æ˜¾ç¤º panel
        panel.show();

        // è®°å½•å±æ€§
        this.panel = panel;
    },

    // æ’å…¥è§†é¢‘
    _insert: function _insert(val) {
        var editor = this.editor;
        editor.cmd.do('insertHTML', val + '<p><br></p>');
    }
};

/*
    menu - img
*/
// æ„é€ å‡½æ•°
function Image(editor) {
    this.editor = editor;
    var imgMenuId = getRandom('w-e-img');
    this.$elem = $('<div class="w-e-menu" id="' + imgMenuId + '"><i class="w-e-icon-image"></i></div>');
    editor.imgMenuId = imgMenuId;
    this.type = 'panel';

    // å½“å‰æ˜¯å¦ active çŠ¶æ€
    this._active = false;
}

// åŸå‹
Image.prototype = {
    constructor: Image,

    onClick: function onClick() {
        var editor = this.editor;
        var config = editor.config;
        if (config.qiniu) {
            return;
        }
        if (this._active) {
            this._createEditPanel();
        } else {
            this._createInsertPanel();
        }
    },

    _createEditPanel: function _createEditPanel() {
        var editor = this.editor;

        // id
        var width30 = getRandom('width-30');
        var width50 = getRandom('width-50');
        var width100 = getRandom('width-100');
        var delBtn = getRandom('del-btn');

        // tab é…ç½®
        var tabsConfig = [{
            title: 'ç¼–è¾‘å›¾ç‰‡',
            tpl: '<div>\n                    <div class="w-e-button-container" style="border-bottom:1px solid #f1f1f1;padding-bottom:5px;margin-bottom:5px;">\n                        <span style="float:left;font-size:14px;margin:4px 5px 0 5px;color:#333;">\u6700\u5927\u5BBD\u5EA6\uFF1A</span>\n                        <button id="' + width30 + '" class="left">30%</button>\n                        <button id="' + width50 + '" class="left">50%</button>\n                        <button id="' + width100 + '" class="left">100%</button>\n                    </div>\n                    <div class="w-e-button-container">\n                        <button id="' + delBtn + '" class="gray left">\u5220\u9664\u56FE\u7247</button>\n                    </dv>\n                </div>',
            events: [{
                selector: '#' + width30,
                type: 'click',
                fn: function fn() {
                    var $img = editor._selectedImg;
                    if ($img) {
                        $img.css('max-width', '30%');
                    }
                    // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                    return true;
                }
            }, {
                selector: '#' + width50,
                type: 'click',
                fn: function fn() {
                    var $img = editor._selectedImg;
                    if ($img) {
                        $img.css('max-width', '50%');
                    }
                    // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                    return true;
                }
            }, {
                selector: '#' + width100,
                type: 'click',
                fn: function fn() {
                    var $img = editor._selectedImg;
                    if ($img) {
                        $img.css('max-width', '100%');
                    }
                    // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                    return true;
                }
            }, {
                selector: '#' + delBtn,
                type: 'click',
                fn: function fn() {
                    var $img = editor._selectedImg;
                    if ($img) {
                        $img.remove();
                    }
                    // è¿”å› trueï¼Œè¡¨ç¤ºè¯¥äº‹ä»¶æ‰§è¡Œå®Œä¹‹åï¼Œpanel è¦å…³é—­ã€‚å¦åˆ™ panel ä¸ä¼šå…³é—­
                    return true;
                }
            }]
        }];

        // åˆ›å»º panel å¹¶æ˜¾ç¤º
        var panel = new Panel(this, {
            width: 300,
            tabs: tabsConfig
        });
        panel.show();

        // è®°å½•å±æ€§
        this.panel = panel;
    },

    _createInsertPanel: function _createInsertPanel() {
        var editor = this.editor;
        var uploadImg = editor.uploadImg;
        var config = editor.config;

        // id
        var upTriggerId = getRandom('up-trigger');
        var upFileId = getRandom('up-file');
        var linkUrlId = getRandom('link-url');
        var linkBtnId = getRandom('link-btn');

        // tabs çš„é…ç½®
        var tabsConfig = [{
            title: 'ä¸Šä¼ å›¾ç‰‡',
            tpl: '<div class="w-e-up-img-container">\n                    <div id="' + upTriggerId + '" class="w-e-up-btn">\n                        <i class="w-e-icon-upload2"></i>\n                    </div>\n                    <div style="display:none;">\n                        <input id="' + upFileId + '" type="file" multiple="multiple" accept="image/jpg,image/jpeg,image/png,image/gif,image/bmp"/>\n                    </div>\n                </div>',
            events: [{
                // è§¦å‘é€‰æ‹©å›¾ç‰‡
                selector: '#' + upTriggerId,
                type: 'click',
                fn: function fn() {
                    var $file = $('#' + upFileId);
                    var fileElem = $file[0];
                    if (fileElem) {
                        fileElem.click();
                    } else {
                        // è¿”å› true å¯å…³é—­ panel
                        return true;
                    }
                }
            }, {
                // é€‰æ‹©å›¾ç‰‡å®Œæ¯•
                selector: '#' + upFileId,
                type: 'change',
                fn: function fn() {
                    var $file = $('#' + upFileId);
                    var fileElem = $file[0];
                    if (!fileElem) {
                        // è¿”å› true å¯å…³é—­ panel
                        return true;
                    }

                    // è·å–é€‰ä¸­çš„ file å¯¹è±¡åˆ—è¡¨
                    var fileList = fileElem.files;
                    if (fileList.length) {
                        uploadImg.uploadImg(fileList);
                    }

                    // è¿”å› true å¯å…³é—­ panel
                    return true;
                }
            }]
        }, // first tab end
        {
            title: 'ç½‘ç»œå›¾ç‰‡',
            tpl: '<div>\n                    <input id="' + linkUrlId + '" type="text" class="block" placeholder="\u56FE\u7247\u94FE\u63A5"/></td>\n                    <div class="w-e-button-container">\n                        <button id="' + linkBtnId + '" class="right">\u63D2\u5165</button>\n                    </div>\n                </div>',
            events: [{
                selector: '#' + linkBtnId,
                type: 'click',
                fn: function fn() {
                    var $linkUrl = $('#' + linkUrlId);
                    var url = $linkUrl.val().trim();

                    if (url) {
                        uploadImg.insertLinkImg(url);
                    }

                    // è¿”å› true è¡¨ç¤ºå‡½æ•°æ‰§è¡Œç»“æŸä¹‹åå…³é—­ panel
                    return true;
                }
            }]
        } // second tab end
        ]; // tabs end

        // åˆ¤æ–­ tabs çš„æ˜¾ç¤º
        var tabsConfigResult = [];
        if ((config.uploadImgShowBase64 || config.uploadImgServer || config.customUploadImg) && window.FileReader) {
            // æ˜¾ç¤ºâ€œä¸Šä¼ å›¾ç‰‡â€
            tabsConfigResult.push(tabsConfig[0]);
        }
        if (config.showLinkImg) {
            // æ˜¾ç¤ºâ€œç½‘ç»œå›¾ç‰‡â€
            tabsConfigResult.push(tabsConfig[1]);
        }

        // åˆ›å»º panel å¹¶æ˜¾ç¤º
        var panel = new Panel(this, {
            width: 300,
            tabs: tabsConfigResult
        });
        panel.show();

        // è®°å½•å±æ€§
        this.panel = panel;
    },

    // è¯•å›¾æ”¹å˜ active çŠ¶æ€
    tryChangeActive: function tryChangeActive(e) {
        var editor = this.editor;
        var $elem = this.$elem;
        if (editor._selectedImg) {
            this._active = true;
            $elem.addClass('w-e-active');
        } else {
            this._active = false;
            $elem.removeClass('w-e-active');
        }
    }
};

/*
    æ‰€æœ‰èœå•çš„æ±‡æ€»
*/

// å­˜å‚¨èœå•çš„æ„é€ å‡½æ•°
var MenuConstructors = {};

MenuConstructors.bold = Bold;

MenuConstructors.head = Head;

MenuConstructors.fontSize = FontSize;

MenuConstructors.fontName = FontName;

MenuConstructors.link = Link;

MenuConstructors.italic = Italic;

MenuConstructors.redo = Redo;

MenuConstructors.strikeThrough = StrikeThrough;

MenuConstructors.underline = Underline;

MenuConstructors.undo = Undo;

MenuConstructors.list = List;

MenuConstructors.justify = Justify;

MenuConstructors.foreColor = ForeColor;

MenuConstructors.backColor = BackColor;

MenuConstructors.quote = Quote;

MenuConstructors.code = Code;

MenuConstructors.emoticon = Emoticon;

MenuConstructors.table = Table;

MenuConstructors.video = Video;

MenuConstructors.image = Image;

/*
    èœå•é›†åˆ
*/
// æ„é€ å‡½æ•°
function Menus(editor) {
    this.editor = editor;
    this.menus = {};
}

// ä¿®æ”¹åŸå‹
Menus.prototype = {
    constructor: Menus,

    // åˆå§‹åŒ–èœå•
    init: function init() {
        var _this = this;

        var editor = this.editor;
        var config = editor.config || {};
        var configMenus = config.menus || []; // è·å–é…ç½®ä¸­çš„èœå•

        // æ ¹æ®é…ç½®ä¿¡æ¯ï¼Œåˆ›å»ºèœå•
        configMenus.forEach(function (menuKey) {
            var MenuConstructor = MenuConstructors[menuKey];
            if (MenuConstructor && typeof MenuConstructor === 'function') {
                // åˆ›å»ºå•ä¸ªèœå•
                _this.menus[menuKey] = new MenuConstructor(editor);
            }
        });

        // æ·»åŠ åˆ°èœå•æ 
        this._addToToolbar();

        // ç»‘å®šäº‹ä»¶
        this._bindEvent();
    },

    // æ·»åŠ åˆ°èœå•æ 
    _addToToolbar: function _addToToolbar() {
        var editor = this.editor;
        var $toolbarElem = editor.$toolbarElem;
        var menus = this.menus;
        var config = editor.config;
        // config.zIndex æ˜¯é…ç½®çš„ç¼–è¾‘åŒºåŸŸçš„ z-indexï¼Œèœå•çš„ z-index å¾—åœ¨å…¶åŸºç¡€ä¸Š +1
        var zIndex = config.zIndex + 1;
        objForEach(menus, function (key, menu) {
            var $elem = menu.$elem;
            if ($elem) {
                // è®¾ç½® z-index
                $elem.css('z-index', zIndex);
                $toolbarElem.append($elem);
            }
        });
    },

    // ç»‘å®šèœå• click mouseenter äº‹ä»¶
    _bindEvent: function _bindEvent() {
        var menus = this.menus;
        var editor = this.editor;
        objForEach(menus, function (key, menu) {
            var type = menu.type;
            if (!type) {
                return;
            }
            var $elem = menu.$elem;
            var droplist = menu.droplist;
            var panel = menu.panel;

            // ç‚¹å‡»ç±»å‹ï¼Œä¾‹å¦‚ bold
            if (type === 'click' && menu.onClick) {
                $elem.on('click', function (e) {
                    if (editor.selection.getRange() == null) {
                        return;
                    }
                    menu.onClick(e);
                });
            }

            // ä¸‹æ‹‰æ¡†ï¼Œä¾‹å¦‚ head
            if (type === 'droplist' && droplist) {
                $elem.on('mouseenter', function (e) {
                    if (editor.selection.getRange() == null) {
                        return;
                    }
                    // æ˜¾ç¤º
                    droplist.showTimeoutId = setTimeout(function () {
                        droplist.show();
                    }, 200);
                }).on('mouseleave', function (e) {
                    // éšè—
                    droplist.hideTimeoutId = setTimeout(function () {
                        droplist.hide();
                    }, 0);
                });
            }

            // å¼¹æ¡†ç±»å‹ï¼Œä¾‹å¦‚ link
            if (type === 'panel' && menu.onClick) {
                $elem.on('click', function (e) {
                    e.stopPropagation();
                    if (editor.selection.getRange() == null) {
                        return;
                    }
                    // åœ¨è‡ªå®šä¹‰äº‹ä»¶ä¸­æ˜¾ç¤º panel
                    menu.onClick(e);
                });
            }
        });
    },

    // å°è¯•ä¿®æ”¹èœå•çŠ¶æ€
    changeActive: function changeActive() {
        var menus = this.menus;
        objForEach(menus, function (key, menu) {
            if (menu.tryChangeActive) {
                setTimeout(function () {
                    menu.tryChangeActive();
                }, 100);
            }
        });
    }
};

/*
    ç²˜è´´ä¿¡æ¯çš„å¤„ç†
*/

// è·å–ç²˜è´´çš„çº¯æ–‡æœ¬
function getPasteText(e) {
    var clipboardData = e.clipboardData || e.originalEvent && e.originalEvent.clipboardData;
    var pasteText = void 0;
    if (clipboardData == null) {
        pasteText = window.clipboardData && window.clipboardData.getData('text');
    } else {
        pasteText = clipboardData.getData('text/plain');
    }

    return replaceHtmlSymbol(pasteText);
}

// è·å–ç²˜è´´çš„html
function getPasteHtml(e, filterStyle, ignoreImg) {
    var clipboardData = e.clipboardData || e.originalEvent && e.originalEvent.clipboardData;
    var pasteText = void 0,
        pasteHtml = void 0;
    if (clipboardData == null) {
        pasteText = window.clipboardData && window.clipboardData.getData('text');
    } else {
        pasteText = clipboardData.getData('text/plain');
        pasteHtml = clipboardData.getData('text/html');
    }
    if (!pasteHtml && pasteText) {
        pasteHtml = '<p>' + replaceHtmlSymbol(pasteText) + '</p>';
    }
    if (!pasteHtml) {
        return;
    }

    // è¿‡æ»¤wordä¸­çŠ¶æ€è¿‡æ¥çš„æ— ç”¨å­—ç¬¦
    var docSplitHtml = pasteHtml.split('</html>');
    if (docSplitHtml.length === 2) {
        pasteHtml = docSplitHtml[0];
    }

    // è¿‡æ»¤æ— ç”¨æ ‡ç­¾
    pasteHtml = pasteHtml.replace(/<(meta|script|link).+?>/igm, '');
    // å»æ‰æ³¨é‡Š
    pasteHtml = pasteHtml.replace(/<!--.*?-->/mg, '');
    // è¿‡æ»¤ data-xxx å±æ€§
    pasteHtml = pasteHtml.replace(/\s?data-.+?=('|").+?('|")/igm, '');

    if (ignoreImg) {
        // å¿½ç•¥å›¾ç‰‡
        pasteHtml = pasteHtml.replace(/<img.+?>/igm, '');
    }

    if (filterStyle) {
        // è¿‡æ»¤æ ·å¼
        pasteHtml = pasteHtml.replace(/\s?(class|style)=('|").*?('|")/igm, '');
    } else {
        // ä¿ç•™æ ·å¼
        pasteHtml = pasteHtml.replace(/\s?class=('|").*?('|")/igm, '');
    }

    return pasteHtml;
}

// è·å–ç²˜è´´çš„å›¾ç‰‡æ–‡ä»¶
function getPasteImgs(e) {
    var result = [];
    var txt = getPasteText(e);
    if (txt) {
        // æœ‰æ–‡å­—ï¼Œå°±å¿½ç•¥å›¾ç‰‡
        return result;
    }

    var clipboardData = e.clipboardData || e.originalEvent && e.originalEvent.clipboardData || {};
    var items = clipboardData.items;
    if (!items) {
        return result;
    }

    objForEach(items, function (key, value) {
        var type = value.type;
        if (/image/i.test(type)) {
            result.push(value.getAsFile());
        }
    });

    return result;
}

/*
    ç¼–è¾‘åŒºåŸŸ
*/

// è·å–ä¸€ä¸ª elem.childNodes çš„ JSON æ•°æ®
function getChildrenJSON($elem) {
    var result = [];
    var $children = $elem.childNodes() || []; // æ³¨æ„ childNodes() å¯ä»¥è·å–æ–‡æœ¬èŠ‚ç‚¹
    $children.forEach(function (curElem) {
        var elemResult = void 0;
        var nodeType = curElem.nodeType;

        // æ–‡æœ¬èŠ‚ç‚¹
        if (nodeType === 3) {
            elemResult = curElem.textContent;
            elemResult = replaceHtmlSymbol(elemResult);
        }

        // æ™®é€š DOM èŠ‚ç‚¹
        if (nodeType === 1) {
            elemResult = {};

            // tag
            elemResult.tag = curElem.nodeName.toLowerCase();
            // attr
            var attrData = [];
            var attrList = curElem.attributes || {};
            var attrListLength = attrList.length || 0;
            for (var i = 0; i < attrListLength; i++) {
                var attr = attrList[i];
                attrData.push({
                    name: attr.name,
                    value: attr.value
                });
            }
            elemResult.attrs = attrData;
            // childrenï¼ˆé€’å½’ï¼‰
            elemResult.children = getChildrenJSON($(curElem));
        }

        result.push(elemResult);
    });
    return result;
}

// æ„é€ å‡½æ•°
function Text(editor) {
    this.editor = editor;
}

// ä¿®æ”¹åŸå‹
Text.prototype = {
    constructor: Text,

    // åˆå§‹åŒ–
    init: function init() {
        // ç»‘å®šäº‹ä»¶
        this._bindEvent();
    },

    // æ¸…ç©ºå†…å®¹
    clear: function clear() {
        this.html('<p><br></p>');
    },

    // è·å– è®¾ç½® html
    html: function html(val) {
        var editor = this.editor;
        var $textElem = editor.$textElem;
        var html = void 0;
        if (val == null) {
            html = $textElem.html();
            // æœªé€‰ä¸­ä»»ä½•å†…å®¹çš„æ—¶å€™ç‚¹å‡»â€œåŠ ç²—â€æˆ–è€…â€œæ–œä½“â€ç­‰æŒ‰é’®ï¼Œå°±å¾—éœ€è¦ä¸€ä¸ªç©ºçš„å ä½ç¬¦ &#8203 ï¼Œè¿™é‡Œæ›¿æ¢æ‰
            html = html.replace(/\u200b/gm, '');
            return html;
        } else {
            $textElem.html(val);

            // åˆå§‹åŒ–é€‰å–ï¼Œå°†å…‰æ ‡å®šä½åˆ°å†…å®¹å°¾éƒ¨
            editor.initSelection();
        }
    },

    // è·å– JSON
    getJSON: function getJSON() {
        var editor = this.editor;
        var $textElem = editor.$textElem;
        return getChildrenJSON($textElem);
    },

    // è·å– è®¾ç½® text
    text: function text(val) {
        var editor = this.editor;
        var $textElem = editor.$textElem;
        var text = void 0;
        if (val == null) {
            text = $textElem.text();
            // æœªé€‰ä¸­ä»»ä½•å†…å®¹çš„æ—¶å€™ç‚¹å‡»â€œåŠ ç²—â€æˆ–è€…â€œæ–œä½“â€ç­‰æŒ‰é’®ï¼Œå°±å¾—éœ€è¦ä¸€ä¸ªç©ºçš„å ä½ç¬¦ &#8203 ï¼Œè¿™é‡Œæ›¿æ¢æ‰
            text = text.replace(/\u200b/gm, '');
            return text;
        } else {
            $textElem.text('<p>' + val + '</p>');

            // åˆå§‹åŒ–é€‰å–ï¼Œå°†å…‰æ ‡å®šä½åˆ°å†…å®¹å°¾éƒ¨
            editor.initSelection();
        }
    },

    // è¿½åŠ å†…å®¹
    append: function append(html) {
        var editor = this.editor;
        var $textElem = editor.$textElem;
        $textElem.append($(html));

        // åˆå§‹åŒ–é€‰å–ï¼Œå°†å…‰æ ‡å®šä½åˆ°å†…å®¹å°¾éƒ¨
        editor.initSelection();
    },

    // ç»‘å®šäº‹ä»¶
    _bindEvent: function _bindEvent() {
        // å®æ—¶ä¿å­˜é€‰å–
        this._saveRangeRealTime();

        // æŒ‰å›è½¦å»ºæ—¶çš„ç‰¹æ®Šå¤„ç†
        this._enterKeyHandle();

        // æ¸…ç©ºæ—¶ä¿ç•™ <p><br></p>
        this._clearHandle();

        // ç²˜è´´äº‹ä»¶ï¼ˆç²˜è´´æ–‡å­—ï¼Œç²˜è´´å›¾ç‰‡ï¼‰
        this._pasteHandle();

        // tab ç‰¹æ®Šå¤„ç†
        this._tabHandle();

        // img ç‚¹å‡»
        this._imgHandle();

        // æ‹–æ‹½äº‹ä»¶
        this._dragHandle();
    },

    // å®æ—¶ä¿å­˜é€‰å–
    _saveRangeRealTime: function _saveRangeRealTime() {
        var editor = this.editor;
        var $textElem = editor.$textElem;

        // ä¿å­˜å½“å‰çš„é€‰åŒº
        function saveRange(e) {
            // éšæ—¶ä¿å­˜é€‰åŒº
            editor.selection.saveRange();
            // æ›´æ–°æŒ‰é’® ative çŠ¶æ€
            editor.menus.changeActive();
        }
        // æŒ‰é”®åä¿å­˜
        $textElem.on('keyup', saveRange);
        $textElem.on('mousedown', function (e) {
            // mousedown çŠ¶æ€ä¸‹ï¼Œé¼ æ ‡æ»‘åŠ¨åˆ°ç¼–è¾‘åŒºåŸŸå¤–é¢ï¼Œä¹Ÿéœ€è¦ä¿å­˜é€‰åŒº
            $textElem.on('mouseleave', saveRange);
        });
        $textElem.on('mouseup', function (e) {
            saveRange();
            // åœ¨ç¼–è¾‘å™¨åŒºåŸŸä¹‹å†…å®Œæˆç‚¹å‡»ï¼Œå–æ¶ˆé¼ æ ‡æ»‘åŠ¨åˆ°ç¼–è¾‘åŒºå¤–é¢çš„äº‹ä»¶
            $textElem.off('mouseleave', saveRange);
        });
    },

    // æŒ‰å›è½¦é”®æ—¶çš„ç‰¹æ®Šå¤„ç†
    _enterKeyHandle: function _enterKeyHandle() {
        var editor = this.editor;
        var $textElem = editor.$textElem;

        function insertEmptyP($selectionElem) {
            var $p = $('<p><br></p>');
            $p.insertBefore($selectionElem);
            editor.selection.createRangeByElem($p, true);
            editor.selection.restoreSelection();
            $selectionElem.remove();
        }

        // å°†å›è½¦ä¹‹åç”Ÿæˆçš„é <p> çš„é¡¶çº§æ ‡ç­¾ï¼Œæ”¹ä¸º <p>
        function pHandle(e) {
            var $selectionElem = editor.selection.getSelectionContainerElem();
            var $parentElem = $selectionElem.parent();

            if ($parentElem.html() === '<code><br></code>') {
                // å›è½¦ä¹‹å‰å…‰æ ‡æ‰€åœ¨ä¸€ä¸ª <p><code>.....</code></p> ï¼Œå¿½ç„¶å›è½¦ç”Ÿæˆä¸€ä¸ªç©ºçš„ <p><code><br></code></p>
                // è€Œä¸”ç»§ç»­å›è½¦è·³ä¸å‡ºå»ï¼Œå› æ­¤åªèƒ½ç‰¹æ®Šå¤„ç†
                insertEmptyP($selectionElem);
                return;
            }

            if (!$parentElem.equal($textElem)) {
                // ä¸æ˜¯é¡¶çº§æ ‡ç­¾
                return;
            }

            var nodeName = $selectionElem.getNodeName();
            if (nodeName === 'P') {
                // å½“å‰çš„æ ‡ç­¾æ˜¯ P ï¼Œä¸ç”¨åšå¤„ç†
                return;
            }

            if ($selectionElem.text()) {
                // æœ‰å†…å®¹ï¼Œä¸åšå¤„ç†
                return;
            }

            // æ’å…¥ <p> ï¼Œå¹¶å°†é€‰å–å®šä½åˆ° <p>ï¼Œåˆ é™¤å½“å‰æ ‡ç­¾
            insertEmptyP($selectionElem);
        }

        $textElem.on('keyup', function (e) {
            if (e.keyCode !== 13) {
                // ä¸æ˜¯å›è½¦é”®
                return;
            }
            // å°†å›è½¦ä¹‹åç”Ÿæˆçš„é <p> çš„é¡¶çº§æ ‡ç­¾ï¼Œæ”¹ä¸º <p>
            pHandle(e);
        });

        // <pre><code></code></pre> å›è½¦æ—¶ ç‰¹æ®Šå¤„ç†
        function codeHandle(e) {
            var $selectionElem = editor.selection.getSelectionContainerElem();
            if (!$selectionElem) {
                return;
            }
            var $parentElem = $selectionElem.parent();
            var selectionNodeName = $selectionElem.getNodeName();
            var parentNodeName = $parentElem.getNodeName();

            if (selectionNodeName !== 'CODE' || parentNodeName !== 'PRE') {
                // ä¸ç¬¦åˆè¦æ±‚ å¿½ç•¥
                return;
            }

            if (!editor.cmd.queryCommandSupported('insertHTML')) {
                // å¿…é¡»åŸç”Ÿæ”¯æŒ insertHTML å‘½ä»¤
                return;
            }

            // å¤„ç†ï¼šå…‰æ ‡å®šä½åˆ°ä»£ç æœ«å°¾ï¼Œè”ç³»ç‚¹å‡»ä¸¤æ¬¡å›è½¦ï¼Œå³è·³å‡ºä»£ç å—
            if (editor._willBreakCode === true) {
                // æ­¤æ—¶å¯ä»¥è·³å‡ºä»£ç å—
                // æ’å…¥ <p> ï¼Œå¹¶å°†é€‰å–å®šä½åˆ° <p>
                var $p = $('<p><br></p>');
                $p.insertAfter($parentElem);
                editor.selection.createRangeByElem($p, true);
                editor.selection.restoreSelection();

                // ä¿®æ”¹çŠ¶æ€
                editor._willBreakCode = false;

                e.preventDefault();
                return;
            }

            var _startOffset = editor.selection.getRange().startOffset;

            // å¤„ç†ï¼šå›è½¦æ—¶ï¼Œä¸èƒ½æ’å…¥ <br> è€Œæ˜¯æ’å…¥ \n ï¼Œå› ä¸ºæ˜¯åœ¨ pre æ ‡ç­¾é‡Œé¢
            editor.cmd.do('insertHTML', '\n');
            editor.selection.saveRange();
            if (editor.selection.getRange().startOffset === _startOffset) {
                // æ²¡èµ·ä½œç”¨ï¼Œå†æ¥ä¸€é
                editor.cmd.do('insertHTML', '\n');
            }

            var codeLength = $selectionElem.html().length;
            if (editor.selection.getRange().startOffset + 1 === codeLength) {
                // è¯´æ˜å…‰æ ‡åœ¨ä»£ç æœ€åçš„ä½ç½®ï¼Œæ‰§è¡Œäº†å›è½¦æ“ä½œ
                // è®°å½•ä¸‹æ¥ï¼Œä»¥ä¾¿ä¸‹æ¬¡å›è½¦æ—¶å€™è·³å‡º code
                editor._willBreakCode = true;
            }

            // é˜»æ­¢é»˜è®¤è¡Œä¸º
            e.preventDefault();
        }

        $textElem.on('keydown', function (e) {
            if (e.keyCode !== 13) {
                // ä¸æ˜¯å›è½¦é”®
                // å–æ¶ˆå³å°†è·³è½¬ä»£ç å—çš„è®°å½•
                editor._willBreakCode = false;
                return;
            }
            // <pre><code></code></pre> å›è½¦æ—¶ ç‰¹æ®Šå¤„ç†
            codeHandle(e);
        });
    },

    // æ¸…ç©ºæ—¶ä¿ç•™ <p><br></p>
    _clearHandle: function _clearHandle() {
        var editor = this.editor;
        var $textElem = editor.$textElem;

        $textElem.on('keydown', function (e) {
            if (e.keyCode !== 8) {
                return;
            }
            var txtHtml = $textElem.html().toLowerCase().trim();
            if (txtHtml === '<p><br></p>') {
                // æœ€åå‰©ä¸‹ä¸€ä¸ªç©ºè¡Œï¼Œå°±ä¸å†åˆ é™¤äº†
                e.preventDefault();
                return;
            }
        });

        $textElem.on('keyup', function (e) {
            if (e.keyCode !== 8) {
                return;
            }
            var $p = void 0;
            var txtHtml = $textElem.html().toLowerCase().trim();

            // firefox æ—¶ç”¨ txtHtml === '<br>' åˆ¤æ–­ï¼Œå…¶ä»–ç”¨ !txtHtml åˆ¤æ–­
            if (!txtHtml || txtHtml === '<br>') {
                // å†…å®¹ç©ºäº†
                $p = $('<p><br/></p>');
                $textElem.html(''); // ä¸€å®šè¦å…ˆæ¸…ç©ºï¼Œå¦åˆ™åœ¨ firefox ä¸‹æœ‰é—®é¢˜
                $textElem.append($p);
                editor.selection.createRangeByElem($p, false, true);
                editor.selection.restoreSelection();
            }
        });
    },

    // ç²˜è´´äº‹ä»¶ï¼ˆç²˜è´´æ–‡å­— ç²˜è´´å›¾ç‰‡ï¼‰
    _pasteHandle: function _pasteHandle() {
        var editor = this.editor;
        var config = editor.config;
        var pasteFilterStyle = config.pasteFilterStyle;
        var pasteTextHandle = config.pasteTextHandle;
        var ignoreImg = config.pasteIgnoreImg;
        var $textElem = editor.$textElem;

        // ç²˜è´´å›¾ç‰‡ã€æ–‡æœ¬çš„äº‹ä»¶ï¼Œæ¯æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ª
        // åˆ¤æ–­è¯¥æ¬¡ç²˜è´´äº‹ä»¶æ˜¯å¦å¯ä»¥æ‰§è¡Œ
        var pasteTime = 0;
        function canDo() {
            var now = Date.now();
            var flag = false;
            if (now - pasteTime >= 100) {
                // é—´éš”å¤§äº 100 ms ï¼Œå¯ä»¥æ‰§è¡Œ
                flag = true;
            }
            pasteTime = now;
            return flag;
        }
        function resetTime() {
            pasteTime = 0;
        }

        // ç²˜è´´æ–‡å­—
        $textElem.on('paste', function (e) {
            if (UA.isIE()) {
                return;
            } else {
                // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œä½¿ç”¨ execCommand çš„ç²˜è´´å‘½ä»¤
                e.preventDefault();
            }

            // ç²˜è´´å›¾ç‰‡å’Œæ–‡æœ¬ï¼Œåªèƒ½åŒæ—¶ä½¿ç”¨ä¸€ä¸ª
            if (!canDo()) {
                return;
            }

            // è·å–ç²˜è´´çš„æ–‡å­—
            var pasteHtml = getPasteHtml(e, pasteFilterStyle, ignoreImg);
            var pasteText = getPasteText(e);
            pasteText = pasteText.replace(/\n/gm, '<br>');

            var $selectionElem = editor.selection.getSelectionContainerElem();
            if (!$selectionElem) {
                return;
            }
            var nodeName = $selectionElem.getNodeName();

            // code ä¸­åªèƒ½ç²˜è´´çº¯æ–‡æœ¬
            if (nodeName === 'CODE' || nodeName === 'PRE') {
                if (pasteTextHandle && isFunction(pasteTextHandle)) {
                    // ç”¨æˆ·è‡ªå®šä¹‰è¿‡æ»¤å¤„ç†ç²˜è´´å†…å®¹
                    pasteText = '' + (pasteTextHandle(pasteText) || '');
                }
                editor.cmd.do('insertHTML', '<p>' + pasteText + '</p>');
                return;
            }

            // å…ˆæ”¾å¼€æ³¨é‡Šï¼Œæœ‰é—®é¢˜å†è¿½æŸ¥ â€”â€”â€”â€”
            // // è¡¨æ ¼ä¸­å¿½ç•¥ï¼Œå¯èƒ½ä¼šå‡ºç°å¼‚å¸¸é—®é¢˜
            // if (nodeName === 'TD' || nodeName === 'TH') {
            //     return
            // }

            if (!pasteHtml) {
                // æ²¡æœ‰å†…å®¹ï¼Œå¯ç»§ç»­æ‰§è¡Œä¸‹é¢çš„å›¾ç‰‡ç²˜è´´
                resetTime();
                return;
            }
            try {
                // firefox ä¸­ï¼Œè·å–çš„ pasteHtml å¯èƒ½æ˜¯æ²¡æœ‰ <ul> åŒ…è£¹çš„ <li>
                // å› æ­¤æ‰§è¡Œ insertHTML ä¼šæŠ¥é”™
                if (pasteTextHandle && isFunction(pasteTextHandle)) {
                    // ç”¨æˆ·è‡ªå®šä¹‰è¿‡æ»¤å¤„ç†ç²˜è´´å†…å®¹
                    pasteHtml = '' + (pasteTextHandle(pasteHtml) || '');
                }
                editor.cmd.do('insertHTML', pasteHtml);
            } catch (ex) {
                // æ­¤æ—¶ä½¿ç”¨ pasteText æ¥å…¼å®¹ä¸€ä¸‹
                if (pasteTextHandle && isFunction(pasteTextHandle)) {
                    // ç”¨æˆ·è‡ªå®šä¹‰è¿‡æ»¤å¤„ç†ç²˜è´´å†…å®¹
                    pasteText = '' + (pasteTextHandle(pasteText) || '');
                }
                editor.cmd.do('insertHTML', '<p>' + pasteText + '</p>');
            }
        });

        // ç²˜è´´å›¾ç‰‡
        $textElem.on('paste', function (e) {
            if (UA.isIE()) {
                return;
            } else {
                e.preventDefault();
            }

            // ç²˜è´´å›¾ç‰‡å’Œæ–‡æœ¬ï¼Œåªèƒ½åŒæ—¶ä½¿ç”¨ä¸€ä¸ª
            if (!canDo()) {
                return;
            }

            // è·å–ç²˜è´´çš„å›¾ç‰‡
            var pasteFiles = getPasteImgs(e);
            if (!pasteFiles || !pasteFiles.length) {
                return;
            }

            // è·å–å½“å‰çš„å…ƒç´ 
            var $selectionElem = editor.selection.getSelectionContainerElem();
            if (!$selectionElem) {
                return;
            }
            var nodeName = $selectionElem.getNodeName();

            // code ä¸­ç²˜è´´å¿½ç•¥
            if (nodeName === 'CODE' || nodeName === 'PRE') {
                return;
            }

            // ä¸Šä¼ å›¾ç‰‡
            var uploadImg = editor.uploadImg;
            uploadImg.uploadImg(pasteFiles);
        });
    },

    // tab ç‰¹æ®Šå¤„ç†
    _tabHandle: function _tabHandle() {
        var editor = this.editor;
        var $textElem = editor.$textElem;

        $textElem.on('keydown', function (e) {
            if (e.keyCode !== 9) {
                return;
            }
            if (!editor.cmd.queryCommandSupported('insertHTML')) {
                // å¿…é¡»åŸç”Ÿæ”¯æŒ insertHTML å‘½ä»¤
                return;
            }
            var $selectionElem = editor.selection.getSelectionContainerElem();
            if (!$selectionElem) {
                return;
            }
            var $parentElem = $selectionElem.parent();
            var selectionNodeName = $selectionElem.getNodeName();
            var parentNodeName = $parentElem.getNodeName();

            if (selectionNodeName === 'CODE' && parentNodeName === 'PRE') {
                // <pre><code> é‡Œé¢
                editor.cmd.do('insertHTML', '    ');
            } else {
                // æ™®é€šæ–‡å­—
                editor.cmd.do('insertHTML', '&nbsp;&nbsp;&nbsp;&nbsp;');
            }

            e.preventDefault();
        });
    },

    // img ç‚¹å‡»
    _imgHandle: function _imgHandle() {
        var editor = this.editor;
        var $textElem = editor.$textElem;

        // ä¸ºå›¾ç‰‡å¢åŠ  selected æ ·å¼
        $textElem.on('click', 'img', function (e) {
            var img = this;
            var $img = $(img);

            if ($img.attr('data-w-e') === '1') {
                // æ˜¯è¡¨æƒ…å›¾ç‰‡ï¼Œå¿½ç•¥
                return;
            }

            // è®°å½•å½“å‰ç‚¹å‡»è¿‡çš„å›¾ç‰‡
            editor._selectedImg = $img;

            // ä¿®æ”¹é€‰åŒºå¹¶ restore ï¼Œé˜²æ­¢ç”¨æˆ·æ­¤æ—¶ç‚¹å‡»é€€æ ¼é”®ï¼Œä¼šåˆ é™¤å…¶ä»–å†…å®¹
            editor.selection.createRangeByElem($img);
            editor.selection.restoreSelection();
        });

        // å»æ‰å›¾ç‰‡çš„ selected æ ·å¼
        $textElem.on('click  keyup', function (e) {
            if (e.target.matches('img')) {
                // ç‚¹å‡»çš„æ˜¯å›¾ç‰‡ï¼Œå¿½ç•¥
                return;
            }
            // åˆ é™¤è®°å½•
            editor._selectedImg = null;
        });
    },

    // æ‹–æ‹½äº‹ä»¶
    _dragHandle: function _dragHandle() {
        var editor = this.editor;

        // ç¦ç”¨ document æ‹–æ‹½äº‹ä»¶
        var $document = $(document);
        $document.on('dragleave drop dragenter dragover', function (e) {
            e.preventDefault();
        });

        // æ·»åŠ ç¼–è¾‘åŒºåŸŸæ‹–æ‹½äº‹ä»¶
        var $textElem = editor.$textElem;
        $textElem.on('drop', function (e) {
            e.preventDefault();
            var files = e.dataTransfer && e.dataTransfer.files;
            if (!files || !files.length) {
                return;
            }

            // ä¸Šä¼ å›¾ç‰‡
            var uploadImg = editor.uploadImg;
            uploadImg.uploadImg(files);
        });
    }
};

/*
    å‘½ä»¤ï¼Œå°è£… document.execCommand
*/

// æ„é€ å‡½æ•°
function Command(editor) {
    this.editor = editor;
}

// ä¿®æ”¹åŸå‹
Command.prototype = {
    constructor: Command,

    // æ‰§è¡Œå‘½ä»¤
    do: function _do(name, value) {
        var editor = this.editor;

        // ä½¿ç”¨ styleWithCSS
        if (!editor._useStyleWithCSS) {
            document.execCommand('styleWithCSS', null, true);
            editor._useStyleWithCSS = true;
        }

        // å¦‚æœæ— é€‰åŒºï¼Œå¿½ç•¥
        if (!editor.selection.getRange()) {
            return;
        }

        // æ¢å¤é€‰å–
        editor.selection.restoreSelection();

        // æ‰§è¡Œ
        var _name = '_' + name;
        if (this[_name]) {
            // æœ‰è‡ªå®šä¹‰äº‹ä»¶
            this[_name](value);
        } else {
            // é»˜è®¤ command
            this._execCommand(name, value);
        }

        // ä¿®æ”¹èœå•çŠ¶æ€
        editor.menus.changeActive();

        // æœ€åï¼Œæ¢å¤é€‰å–ä¿è¯å…‰æ ‡åœ¨åŸæ¥çš„ä½ç½®é—ªçƒ
        editor.selection.saveRange();
        editor.selection.restoreSelection();

        // è§¦å‘ onchange
        editor.change && editor.change();
    },

    // è‡ªå®šä¹‰ insertHTML äº‹ä»¶
    _insertHTML: function _insertHTML(html) {
        var editor = this.editor;
        var range = editor.selection.getRange();

        if (this.queryCommandSupported('insertHTML')) {
            // W3C
            this._execCommand('insertHTML', html);
        } else if (range.insertNode) {
            // IE
            range.deleteContents();
            range.insertNode($(html)[0]);
        } else if (range.pasteHTML) {
            // IE <= 10
            range.pasteHTML(html);
        }
    },

    // æ’å…¥ elem
    _insertElem: function _insertElem($elem) {
        var editor = this.editor;
        var range = editor.selection.getRange();

        if (range.insertNode) {
            range.deleteContents();
            range.insertNode($elem[0]);
        }
    },

    // å°è£… execCommand
    _execCommand: function _execCommand(name, value) {
        document.execCommand(name, false, value);
    },

    // å°è£… document.queryCommandValue
    queryCommandValue: function queryCommandValue(name) {
        return document.queryCommandValue(name);
    },

    // å°è£… document.queryCommandState
    queryCommandState: function queryCommandState(name) {
        return document.queryCommandState(name);
    },

    // å°è£… document.queryCommandSupported
    queryCommandSupported: function queryCommandSupported(name) {
        return document.queryCommandSupported(name);
    }
};

/*
    selection range API
*/

// æ„é€ å‡½æ•°
function API(editor) {
    this.editor = editor;
    this._currentRange = null;
}

// ä¿®æ”¹åŸå‹
API.prototype = {
    constructor: API,

    // è·å– range å¯¹è±¡
    getRange: function getRange() {
        return this._currentRange;
    },

    // ä¿å­˜é€‰åŒº
    saveRange: function saveRange(_range) {
        if (_range) {
            // ä¿å­˜å·²æœ‰é€‰åŒº
            this._currentRange = _range;
            return;
        }

        // è·å–å½“å‰çš„é€‰åŒº
        var selection = window.getSelection();
        if (selection.rangeCount === 0) {
            return;
        }
        var range = selection.getRangeAt(0);

        // åˆ¤æ–­é€‰åŒºå†…å®¹æ˜¯å¦åœ¨ç¼–è¾‘å†…å®¹ä¹‹å†…
        var $containerElem = this.getSelectionContainerElem(range);
        if (!$containerElem) {
            return;
        }

        // åˆ¤æ–­é€‰åŒºå†…å®¹æ˜¯å¦åœ¨ä¸å¯ç¼–è¾‘åŒºåŸŸä¹‹å†…
        if ($containerElem.attr('contenteditable') === 'false' || $containerElem.parentUntil('[contenteditable=false]')) {
            return;
        }

        var editor = this.editor;
        var $textElem = editor.$textElem;
        if ($textElem.isContain($containerElem)) {
            // æ˜¯ç¼–è¾‘å†…å®¹ä¹‹å†…çš„
            this._currentRange = range;
        }
    },

    // æŠ˜å é€‰åŒº
    collapseRange: function collapseRange(toStart) {
        if (toStart == null) {
            // é»˜è®¤ä¸º false
            toStart = false;
        }
        var range = this._currentRange;
        if (range) {
            range.collapse(toStart);
        }
    },

    // é€‰ä¸­åŒºåŸŸçš„æ–‡å­—
    getSelectionText: function getSelectionText() {
        var range = this._currentRange;
        if (range) {
            return this._currentRange.toString();
        } else {
            return '';
        }
    },

    // é€‰åŒºçš„ $Elem
    getSelectionContainerElem: function getSelectionContainerElem(range) {
        range = range || this._currentRange;
        var elem = void 0;
        if (range) {
            elem = range.commonAncestorContainer;
            return $(elem.nodeType === 1 ? elem : elem.parentNode);
        }
    },
    getSelectionStartElem: function getSelectionStartElem(range) {
        range = range || this._currentRange;
        var elem = void 0;
        if (range) {
            elem = range.startContainer;
            return $(elem.nodeType === 1 ? elem : elem.parentNode);
        }
    },
    getSelectionEndElem: function getSelectionEndElem(range) {
        range = range || this._currentRange;
        var elem = void 0;
        if (range) {
            elem = range.endContainer;
            return $(elem.nodeType === 1 ? elem : elem.parentNode);
        }
    },

    // é€‰åŒºæ˜¯å¦ä¸ºç©º
    isSelectionEmpty: function isSelectionEmpty() {
        var range = this._currentRange;
        if (range && range.startContainer) {
            if (range.startContainer === range.endContainer) {
                if (range.startOffset === range.endOffset) {
                    return true;
                }
            }
        }
        return false;
    },

    // æ¢å¤é€‰åŒº
    restoreSelection: function restoreSelection() {
        var selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(this._currentRange);
    },

    // åˆ›å»ºä¸€ä¸ªç©ºç™½ï¼ˆå³ &#8203 å­—ç¬¦ï¼‰é€‰åŒº
    createEmptyRange: function createEmptyRange() {
        var editor = this.editor;
        var range = this.getRange();
        var $elem = void 0;

        if (!range) {
            // å½“å‰æ—  range
            return;
        }
        if (!this.isSelectionEmpty()) {
            // å½“å‰é€‰åŒºå¿…é¡»æ²¡æœ‰å†…å®¹æ‰å¯ä»¥
            return;
        }

        try {
            // ç›®å‰åªæ”¯æŒ webkit å†…æ ¸
            if (UA.isWebkit()) {
                // æ’å…¥ &#8203
                editor.cmd.do('insertHTML', '&#8203;');
                // ä¿®æ”¹ offset ä½ç½®
                range.setEnd(range.endContainer, range.endOffset + 1);
                // å­˜å‚¨
                this.saveRange(range);
            } else {
                $elem = $('<strong>&#8203;</strong>');
                editor.cmd.do('insertElem', $elem);
                this.createRangeByElem($elem, true);
            }
        } catch (ex) {
            // éƒ¨åˆ†æƒ…å†µä¸‹ä¼šæŠ¥é”™ï¼Œå…¼å®¹ä¸€ä¸‹
        }
    },

    // æ ¹æ® $Elem è®¾ç½®é€‰åŒº
    createRangeByElem: function createRangeByElem($elem, toStart, isContent) {
        // $elem - ç»è¿‡å°è£…çš„ elem
        // toStart - true å¼€å§‹ä½ç½®ï¼Œfalse ç»“æŸä½ç½®
        // isContent - æ˜¯å¦é€‰ä¸­Elemçš„å†…å®¹
        if (!$elem.length) {
            return;
        }

        var elem = $elem[0];
        var range = document.createRange();

        if (isContent) {
            range.selectNodeContents(elem);
        } else {
            range.selectNode(elem);
        }

        if (typeof toStart === 'boolean') {
            range.collapse(toStart);
        }

        // å­˜å‚¨ range
        this.saveRange(range);
    }
};

/*
    ä¸Šä¼ è¿›åº¦æ¡
*/

function Progress(editor) {
    this.editor = editor;
    this._time = 0;
    this._isShow = false;
    this._isRender = false;
    this._timeoutId = 0;
    this.$textContainer = editor.$textContainerElem;
    this.$bar = $('<div class="w-e-progress"></div>');
}

Progress.prototype = {
    constructor: Progress,

    show: function show(progress) {
        var _this = this;

        // çŠ¶æ€å¤„ç†
        if (this._isShow) {
            return;
        }
        this._isShow = true;

        // æ¸²æŸ“
        var $bar = this.$bar;
        if (!this._isRender) {
            var $textContainer = this.$textContainer;
            $textContainer.append($bar);
        } else {
            this._isRender = true;
        }

        // æ”¹å˜è¿›åº¦ï¼ˆèŠ‚æµï¼Œ100ms æ¸²æŸ“ä¸€æ¬¡ï¼‰
        if (Date.now() - this._time > 100) {
            if (progress <= 1) {
                $bar.css('width', progress * 100 + '%');
                this._time = Date.now();
            }
        }

        // éšè—
        var timeoutId = this._timeoutId;
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(function () {
            _this._hide();
        }, 500);
    },

    _hide: function _hide() {
        var $bar = this.$bar;
        $bar.remove();

        // ä¿®æ”¹çŠ¶æ€
        this._time = 0;
        this._isShow = false;
        this._isRender = false;
    }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

/*
    ä¸Šä¼ å›¾ç‰‡
*/

// æ„é€ å‡½æ•°
function UploadImg(editor) {
    this.editor = editor;
}

// åŸå‹
UploadImg.prototype = {
    constructor: UploadImg,

    // æ ¹æ® debug å¼¹å‡ºä¸åŒçš„ä¿¡æ¯
    _alert: function _alert(alertInfo, debugInfo) {
        var editor = this.editor;
        var debug = editor.config.debug;
        var customAlert = editor.config.customAlert;

        if (debug) {
            throw new Error('wangEditor: ' + (debugInfo || alertInfo));
        } else {
            if (customAlert && typeof customAlert === 'function') {
                customAlert(alertInfo);
            } else {
                alert(alertInfo);
            }
        }
    },

    // æ ¹æ®é“¾æ¥æ’å…¥å›¾ç‰‡
    insertLinkImg: function insertLinkImg(link) {
        var _this2 = this;

        if (!link) {
            return;
        }
        var editor = this.editor;
        var config = editor.config;

        // æ ¡éªŒæ ¼å¼
        var linkImgCheck = config.linkImgCheck;
        var checkResult = void 0;
        if (linkImgCheck && typeof linkImgCheck === 'function') {
            checkResult = linkImgCheck(link);
            if (typeof checkResult === 'string') {
                // æ ¡éªŒå¤±è´¥ï¼Œæç¤ºä¿¡æ¯
                alert(checkResult);
                return;
            }
        }

        editor.cmd.do('insertHTML', '<img src="' + link + '" style="max-width:100%;"/>');

        // éªŒè¯å›¾ç‰‡ url æ˜¯å¦æœ‰æ•ˆï¼Œæ— æ•ˆçš„è¯ç»™å‡ºæç¤º
        var img = document.createElement('img');
        img.onload = function () {
            var callback = config.linkImgCallback;
            if (callback && typeof callback === 'function') {
                callback(link);
            }

            img = null;
        };
        img.onerror = function () {
            img = null;
            // æ— æ³•æˆåŠŸä¸‹è½½å›¾ç‰‡
            _this2._alert('æ’å…¥å›¾ç‰‡é”™è¯¯', 'wangEditor: \u63D2\u5165\u56FE\u7247\u51FA\u9519\uFF0C\u56FE\u7247\u94FE\u63A5\u662F "' + link + '"\uFF0C\u4E0B\u8F7D\u8BE5\u94FE\u63A5\u5931\u8D25');
            return;
        };
        img.onabort = function () {
            img = null;
        };
        img.src = link;
    },

    // ä¸Šä¼ å›¾ç‰‡
    uploadImg: function uploadImg(files) {
        var _this3 = this;

        if (!files || !files.length) {
            return;
        }

        // ------------------------------ è·å–é…ç½®ä¿¡æ¯ ------------------------------
        var editor = this.editor;
        var config = editor.config;
        var uploadImgServer = config.uploadImgServer;
        var uploadImgShowBase64 = config.uploadImgShowBase64;

        var maxSize = config.uploadImgMaxSize;
        var maxSizeM = maxSize / 1024 / 1024;
        var maxLength = config.uploadImgMaxLength || 10000;
        var uploadFileName = config.uploadFileName || '';
        var uploadImgParams = config.uploadImgParams || {};
        var uploadImgParamsWithUrl = config.uploadImgParamsWithUrl;
        var uploadImgHeaders = config.uploadImgHeaders || {};
        var hooks = config.uploadImgHooks || {};
        var timeout = config.uploadImgTimeout || 3000;
        var withCredentials = config.withCredentials;
        if (withCredentials == null) {
            withCredentials = false;
        }
        var customUploadImg = config.customUploadImg;

        if (!customUploadImg) {
            // æ²¡æœ‰ customUploadImg çš„æƒ…å†µä¸‹ï¼Œéœ€è¦å¦‚ä¸‹ä¸¤ä¸ªé…ç½®æ‰èƒ½ç»§ç»­è¿›è¡Œå›¾ç‰‡ä¸Šä¼ 
            if (!uploadImgServer && !uploadImgShowBase64) {
                return;
            }
        }

        // ------------------------------ éªŒè¯æ–‡ä»¶ä¿¡æ¯ ------------------------------
        var resultFiles = [];
        var errInfo = [];
        arrForEach(files, function (file) {
            var name = file.name;
            var size = file.size;

            // chrome ä½ç‰ˆæœ¬ name === undefined
            if (!name || !size) {
                return;
            }

            if (/\.(jpg|jpeg|png|bmp|gif|webp)$/i.test(name) === false) {
                // åç¼€åä¸åˆæ³•ï¼Œä¸æ˜¯å›¾ç‰‡
                errInfo.push('\u3010' + name + '\u3011\u4E0D\u662F\u56FE\u7247');
                return;
            }
            if (maxSize < size) {
                // ä¸Šä¼ å›¾ç‰‡è¿‡å¤§
                errInfo.push('\u3010' + name + '\u3011\u5927\u4E8E ' + maxSizeM + 'M');
                return;
            }

            // éªŒè¯é€šè¿‡çš„åŠ å…¥ç»“æœåˆ—è¡¨
            resultFiles.push(file);
        });
        // æŠ›å‡ºéªŒè¯ä¿¡æ¯
        if (errInfo.length) {
            this._alert('å›¾ç‰‡éªŒè¯æœªé€šè¿‡: \n' + errInfo.join('\n'));
            return;
        }
        if (resultFiles.length > maxLength) {
            this._alert('ä¸€æ¬¡æœ€å¤šä¸Šä¼ ' + maxLength + 'å¼ å›¾ç‰‡');
            return;
        }

        // ------------------------------ è‡ªå®šä¹‰ä¸Šä¼  ------------------------------
        if (customUploadImg && typeof customUploadImg === 'function') {
            customUploadImg(resultFiles, this.insertLinkImg.bind(this));

            // é˜»æ­¢ä»¥ä¸‹ä»£ç æ‰§è¡Œ
            return;
        }

        // æ·»åŠ å›¾ç‰‡æ•°æ®
        var formdata = new FormData();
        arrForEach(resultFiles, function (file) {
            var name = uploadFileName || file.name;
            formdata.append(name, file);
        });

        // ------------------------------ ä¸Šä¼ å›¾ç‰‡ ------------------------------
        if (uploadImgServer && typeof uploadImgServer === 'string') {
            // æ·»åŠ å‚æ•°
            var uploadImgServerArr = uploadImgServer.split('#');
            uploadImgServer = uploadImgServerArr[0];
            var uploadImgServerHash = uploadImgServerArr[1] || '';
            objForEach(uploadImgParams, function (key, val) {
                // å› ä½¿ç”¨è€…ååº”ï¼Œè‡ªå®šä¹‰å‚æ•°ä¸èƒ½é»˜è®¤ encode ï¼Œç”± v3.1.1 ç‰ˆæœ¬å¼€å§‹æ³¨é‡Šæ‰
                // val = encodeURIComponent(val)

                // ç¬¬ä¸€ï¼Œå°†å‚æ•°æ‹¼æ¥åˆ° url ä¸­
                if (uploadImgParamsWithUrl) {
                    if (uploadImgServer.indexOf('?') > 0) {
                        uploadImgServer += '&';
                    } else {
                        uploadImgServer += '?';
                    }
                    uploadImgServer = uploadImgServer + key + '=' + val;
                }

                // ç¬¬äºŒï¼Œå°†å‚æ•°æ·»åŠ åˆ° formdata ä¸­
                formdata.append(key, val);
            });
            if (uploadImgServerHash) {
                uploadImgServer += '#' + uploadImgServerHash;
            }

            // å®šä¹‰ xhr
            var xhr = new XMLHttpRequest();
            xhr.open('POST', uploadImgServer);

            // è®¾ç½®è¶…æ—¶
            xhr.timeout = timeout;
            xhr.ontimeout = function () {
                // hook - timeout
                if (hooks.timeout && typeof hooks.timeout === 'function') {
                    hooks.timeout(xhr, editor);
                }

                _this3._alert('ä¸Šä¼ å›¾ç‰‡è¶…æ—¶');
            };

            // ç›‘æ§ progress
            if (xhr.upload) {
                xhr.upload.onprogress = function (e) {
                    var percent = void 0;
                    // è¿›åº¦æ¡
                    var progressBar = new Progress(editor);
                    if (e.lengthComputable) {
                        percent = e.loaded / e.total;
                        progressBar.show(percent);
                    }
                };
            }

            // è¿”å›æ•°æ®
            xhr.onreadystatechange = function () {
                var result = void 0;
                if (xhr.readyState === 4) {
                    if (xhr.status < 200 || xhr.status >= 300) {
                        // hook - error
                        if (hooks.error && typeof hooks.error === 'function') {
                            hooks.error(xhr, editor);
                        }

                        // xhr è¿”å›çŠ¶æ€é”™è¯¯
                        _this3._alert('ä¸Šä¼ å›¾ç‰‡å‘ç”Ÿé”™è¯¯', '\u4E0A\u4F20\u56FE\u7247\u53D1\u751F\u9519\u8BEF\uFF0C\u670D\u52A1\u5668\u8FD4\u56DE\u72B6\u6001\u662F ' + xhr.status);
                        return;
                    }

                    result = xhr.responseText;
                    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) !== 'object') {
                        try {
                            result = JSON.parse(result);
                        } catch (ex) {
                            // hook - fail
                            if (hooks.fail && typeof hooks.fail === 'function') {
                                hooks.fail(xhr, editor, result);
                            }

                            _this3._alert('ä¸Šä¼ å›¾ç‰‡å¤±è´¥', 'ä¸Šä¼ å›¾ç‰‡è¿”å›ç»“æœé”™è¯¯ï¼Œè¿”å›ç»“æœæ˜¯: ' + result);
                            return;
                        }
                    }
                    if (!hooks.customInsert && result.errno != '0') {
                        // hook - fail
                        if (hooks.fail && typeof hooks.fail === 'function') {
                            hooks.fail(xhr, editor, result);
                        }

                        // æ•°æ®é”™è¯¯
                        _this3._alert('ä¸Šä¼ å›¾ç‰‡å¤±è´¥', 'ä¸Šä¼ å›¾ç‰‡è¿”å›ç»“æœé”™è¯¯ï¼Œè¿”å›ç»“æœ errno=' + result.errno);
                    } else {
                        if (hooks.customInsert && typeof hooks.customInsert === 'function') {
                            // ä½¿ç”¨è€…è‡ªå®šä¹‰æ’å…¥æ–¹æ³•
                            hooks.customInsert(_this3.insertLinkImg.bind(_this3), result, editor);
                        } else {
                            // å°†å›¾ç‰‡æ’å…¥ç¼–è¾‘å™¨
                            var data = result.data || [];
                            data.forEach(function (link) {
                                _this3.insertLinkImg(link);
                            });
                        }

                        // hook - success
                        if (hooks.success && typeof hooks.success === 'function') {
                            hooks.success(xhr, editor, result);
                        }
                    }
                }
            };

            // hook - before
            if (hooks.before && typeof hooks.before === 'function') {
                var beforeResult = hooks.before(xhr, editor, resultFiles);
                if (beforeResult && (typeof beforeResult === 'undefined' ? 'undefined' : _typeof(beforeResult)) === 'object') {
                    if (beforeResult.prevent) {
                        // å¦‚æœè¿”å›çš„ç»“æœæ˜¯ {prevent: true, msg: 'xxxx'} åˆ™è¡¨ç¤ºç”¨æˆ·æ”¾å¼ƒä¸Šä¼ 
                        this._alert(beforeResult.msg);
                        return;
                    }
                }
            }

            // è‡ªå®šä¹‰ headers
            objForEach(uploadImgHeaders, function (key, val) {
                xhr.setRequestHeader(key, val);
            });

            // è·¨åŸŸä¼  cookie
            xhr.withCredentials = withCredentials;

            // å‘é€è¯·æ±‚
            xhr.send(formdata);

            // æ³¨æ„ï¼Œè¦ return ã€‚ä¸å»æ“ä½œæ¥ä¸‹æ¥çš„ base64 æ˜¾ç¤ºæ–¹å¼
            return;
        }

        // ------------------------------ æ˜¾ç¤º base64 æ ¼å¼ ------------------------------
        if (uploadImgShowBase64) {
            arrForEach(files, function (file) {
                var _this = _this3;
                var reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = function () {
                    _this.insertLinkImg(this.result);
                };
            });
        }
    }
};

/*
    ç¼–è¾‘å™¨æ„é€ å‡½æ•°
*/

// idï¼Œç´¯åŠ 
var editorId = 1;

// æ„é€ å‡½æ•°
function Editor(toolbarSelector, textSelector) {
    if (toolbarSelector == null) {
        // æ²¡æœ‰ä¼ å…¥ä»»ä½•å‚æ•°ï¼ŒæŠ¥é”™
        throw new Error('é”™è¯¯ï¼šåˆå§‹åŒ–ç¼–è¾‘å™¨æ—¶å€™æœªä¼ å…¥ä»»ä½•å‚æ•°ï¼Œè¯·æŸ¥é˜…æ–‡æ¡£');
    }
    // idï¼Œç”¨ä»¥åŒºåˆ†å•ä¸ªé¡µé¢ä¸åŒçš„ç¼–è¾‘å™¨å¯¹è±¡
    this.id = 'wangEditor-' + editorId++;

    this.toolbarSelector = toolbarSelector;
    this.textSelector = textSelector;

    // è‡ªå®šä¹‰é…ç½®
    this.customConfig = {};
}

// ä¿®æ”¹åŸå‹
Editor.prototype = {
    constructor: Editor,

    // åˆå§‹åŒ–é…ç½®
    _initConfig: function _initConfig() {
        // _config æ˜¯é»˜è®¤é…ç½®ï¼Œthis.customConfig æ˜¯ç”¨æˆ·è‡ªå®šä¹‰é…ç½®ï¼Œå°†å®ƒä»¬ merge ä¹‹åå†èµ‹å€¼
        var target = {};
        this.config = Object.assign(target, config, this.customConfig);

        // å°†è¯­è¨€é…ç½®ï¼Œç”Ÿæˆæ­£åˆ™è¡¨è¾¾å¼
        var langConfig = this.config.lang || {};
        var langArgs = [];
        objForEach(langConfig, function (key, val) {
            // key å³éœ€è¦ç”Ÿæˆæ­£åˆ™è¡¨è¾¾å¼çš„è§„åˆ™ï¼Œå¦‚â€œæ’å…¥é“¾æ¥â€
            // val å³éœ€è¦è¢«æ›¿æ¢æˆçš„è¯­è¨€ï¼Œå¦‚â€œinsert linkâ€
            langArgs.push({
                reg: new RegExp(key, 'img'),
                val: val

            });
        });
        this.config.langArgs = langArgs;
    },

    // åˆå§‹åŒ– DOM
    _initDom: function _initDom() {
        var _this = this;

        var toolbarSelector = this.toolbarSelector;
        var $toolbarSelector = $(toolbarSelector);
        var textSelector = this.textSelector;

        var config$$1 = this.config;
        var zIndex = config$$1.zIndex;

        // å®šä¹‰å˜é‡
        var $toolbarElem = void 0,
            $textContainerElem = void 0,
            $textElem = void 0,
            $children = void 0;

        if (textSelector == null) {
            // åªä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œå³æ˜¯å®¹å™¨çš„é€‰æ‹©å™¨æˆ–å…ƒç´ ï¼Œtoolbar å’Œ text çš„å…ƒç´ è‡ªè¡Œåˆ›å»º
            $toolbarElem = $('<div></div>');
            $textContainerElem = $('<div></div>');

            // å°†ç¼–è¾‘å™¨åŒºåŸŸåŸæœ‰çš„å†…å®¹ï¼Œæš‚å­˜èµ·æ¥
            $children = $toolbarSelector.children();

            // æ·»åŠ åˆ° DOM ç»“æ„ä¸­
            $toolbarSelector.append($toolbarElem).append($textContainerElem);

            // è‡ªè¡Œåˆ›å»ºçš„ï¼Œéœ€è¦é…ç½®é»˜è®¤çš„æ ·å¼
            $toolbarElem.css('background-color', '#f1f1f1').css('border', '1px solid #ccc');
            $textContainerElem.css('border', '1px solid #ccc').css('border-top', 'none').css('height', '300px');
        } else {
            // toolbar å’Œ text çš„é€‰æ‹©å™¨éƒ½æœ‰å€¼ï¼Œè®°å½•å±æ€§
            $toolbarElem = $toolbarSelector;
            $textContainerElem = $(textSelector);
            // å°†ç¼–è¾‘å™¨åŒºåŸŸåŸæœ‰çš„å†…å®¹ï¼Œæš‚å­˜èµ·æ¥
            $children = $textContainerElem.children();
        }

        // ç¼–è¾‘åŒºåŸŸ
        $textElem = $('<div></div>');
        $textElem.attr('contenteditable', 'true').css('width', '100%').css('height', '100%');

        // åˆå§‹åŒ–ç¼–è¾‘åŒºåŸŸå†…å®¹
        if ($children && $children.length) {
            $textElem.append($children);
        } else {
            $textElem.append($('<p><br></p>'));
        }

        // ç¼–è¾‘åŒºåŸŸåŠ å…¥DOM
        $textContainerElem.append($textElem);

        // è®¾ç½®é€šç”¨çš„ class
        $toolbarElem.addClass('w-e-toolbar');
        $textContainerElem.addClass('w-e-text-container');
        $textContainerElem.css('z-index', zIndex);
        $textElem.addClass('w-e-text');

        // æ·»åŠ  ID
        var toolbarElemId = getRandom('toolbar-elem');
        $toolbarElem.attr('id', toolbarElemId);
        var textElemId = getRandom('text-elem');
        $textElem.attr('id', textElemId);

        // è®°å½•å±æ€§
        this.$toolbarElem = $toolbarElem;
        this.$textContainerElem = $textContainerElem;
        this.$textElem = $textElem;
        this.toolbarElemId = toolbarElemId;
        this.textElemId = textElemId;

        // è®°å½•è¾“å…¥æ³•çš„å¼€å§‹å’Œç»“æŸ
        var compositionEnd = true;
        $textContainerElem.on('compositionstart', function () {
            // è¾“å…¥æ³•å¼€å§‹è¾“å…¥
            compositionEnd = false;
        });
        $textContainerElem.on('compositionend', function () {
            // è¾“å…¥æ³•ç»“æŸè¾“å…¥
            compositionEnd = true;
        });

        // ç»‘å®š onchange
        $textContainerElem.on('click keyup', function () {
            // è¾“å…¥æ³•ç»“æŸæ‰å‡ºå‘ onchange
            compositionEnd && _this.change && _this.change();
        });
        $toolbarElem.on('click', function () {
            this.change && this.change();
        });

        //ç»‘å®š onfocus ä¸ onblur äº‹ä»¶
        if (config$$1.onfocus || config$$1.onblur) {
            // å½“å‰ç¼–è¾‘å™¨æ˜¯å¦æ˜¯ç„¦ç‚¹çŠ¶æ€
            this.isFocus = false;

            $(document).on('click', function (e) {
                //åˆ¤æ–­å½“å‰ç‚¹å‡»å…ƒç´ æ˜¯å¦åœ¨ç¼–è¾‘å™¨å†…
                var isChild = $textElem.isContain($(e.target));

                //åˆ¤æ–­å½“å‰ç‚¹å‡»å…ƒç´ æ˜¯å¦ä¸ºå·¥å…·æ 
                var isToolbar = $toolbarElem.isContain($(e.target));
                var isMenu = $toolbarElem[0] == e.target ? true : false;

                if (!isChild) {
                    //è‹¥ä¸ºé€‰æ‹©å·¥å…·æ ä¸­çš„åŠŸèƒ½ï¼Œåˆ™ä¸è§†ä¸ºæˆbluræ“ä½œ
                    if (isToolbar && !isMenu) {
                        return;
                    }

                    if (_this.isFocus) {
                        _this.onblur && _this.onblur();
                    }
                    _this.isFocus = false;
                } else {
                    if (!_this.isFocus) {
                        _this.onfocus && _this.onfocus();
                    }
                    _this.isFocus = true;
                }
            });
        }
    },

    // å°è£… command
    _initCommand: function _initCommand() {
        this.cmd = new Command(this);
    },

    // å°è£… selection range API
    _initSelectionAPI: function _initSelectionAPI() {
        this.selection = new API(this);
    },

    // æ·»åŠ å›¾ç‰‡ä¸Šä¼ 
    _initUploadImg: function _initUploadImg() {
        this.uploadImg = new UploadImg(this);
    },

    // åˆå§‹åŒ–èœå•
    _initMenus: function _initMenus() {
        this.menus = new Menus(this);
        this.menus.init();
    },

    // æ·»åŠ  text åŒºåŸŸ
    _initText: function _initText() {
        this.txt = new Text(this);
        this.txt.init();
    },

    // åˆå§‹åŒ–é€‰åŒºï¼Œå°†å…‰æ ‡å®šä½åˆ°å†…å®¹å°¾éƒ¨
    initSelection: function initSelection(newLine) {
        var $textElem = this.$textElem;
        var $children = $textElem.children();
        if (!$children.length) {
            // å¦‚æœç¼–è¾‘å™¨åŒºåŸŸæ— å†…å®¹ï¼Œæ·»åŠ ä¸€ä¸ªç©ºè¡Œï¼Œé‡æ–°è®¾ç½®é€‰åŒº
            $textElem.append($('<p><br></p>'));
            this.initSelection();
            return;
        }

        var $last = $children.last();

        if (newLine) {
            // æ–°å¢ä¸€ä¸ªç©ºè¡Œ
            var html = $last.html().toLowerCase();
            var nodeName = $last.getNodeName();
            if (html !== '<br>' && html !== '<br\/>' || nodeName !== 'P') {
                // æœ€åä¸€ä¸ªå…ƒç´ ä¸æ˜¯ <p><br></p>ï¼Œæ·»åŠ ä¸€ä¸ªç©ºè¡Œï¼Œé‡æ–°è®¾ç½®é€‰åŒº
                $textElem.append($('<p><br></p>'));
                this.initSelection();
                return;
            }
        }

        this.selection.createRangeByElem($last, false, true);
        this.selection.restoreSelection();
    },

    // ç»‘å®šäº‹ä»¶
    _bindEvent: function _bindEvent() {
        // -------- ç»‘å®š onchange äº‹ä»¶ --------
        var onChangeTimeoutId = 0;
        var beforeChangeHtml = this.txt.html();
        var config$$1 = this.config;

        // onchange è§¦å‘å»¶è¿Ÿæ—¶é—´
        var onchangeTimeout = config$$1.onchangeTimeout;
        onchangeTimeout = parseInt(onchangeTimeout, 10);
        if (!onchangeTimeout || onchangeTimeout <= 0) {
            onchangeTimeout = 200;
        }

        var onchange = config$$1.onchange;
        if (onchange && typeof onchange === 'function') {
            // è§¦å‘ change çš„æœ‰ä¸‰ä¸ªåœºæ™¯ï¼š
            // 1. $textContainerElem.on('click keyup')
            // 2. $toolbarElem.on('click')
            // 3. editor.cmd.do()
            this.change = function () {
                // åˆ¤æ–­æ˜¯å¦æœ‰å˜åŒ–
                var currentHtml = this.txt.html();

                if (currentHtml.length === beforeChangeHtml.length) {
                    // éœ€è¦æ¯”è¾ƒæ¯ä¸€ä¸ªå­—ç¬¦
                    if (currentHtml === beforeChangeHtml) {
                        return;
                    }
                }

                // æ‰§è¡Œï¼Œä½¿ç”¨èŠ‚æµ
                if (onChangeTimeoutId) {
                    clearTimeout(onChangeTimeoutId);
                }
                onChangeTimeoutId = setTimeout(function () {
                    // è§¦å‘é…ç½®çš„ onchange å‡½æ•°
                    onchange(currentHtml);
                    beforeChangeHtml = currentHtml;
                }, onchangeTimeout);
            };
        }

        // -------- ç»‘å®š onblur äº‹ä»¶ --------
        var onblur = config$$1.onblur;
        if (onblur && typeof onblur === 'function') {
            this.onblur = function () {
                var currentHtml = this.txt.html();
                onblur(currentHtml);
            };
        }

        // -------- ç»‘å®š onfocus äº‹ä»¶ --------
        var onfocus = config$$1.onfocus;
        if (onfocus && typeof onfocus === 'function') {
            this.onfocus = function () {
                onfocus();
            };
        }
    },

    // åˆ›å»ºç¼–è¾‘å™¨
    create: function create() {
        // åˆå§‹åŒ–é…ç½®ä¿¡æ¯
        this._initConfig();

        // åˆå§‹åŒ– DOM
        this._initDom();

        // å°è£… command API
        this._initCommand();

        // å°è£… selection range API
        this._initSelectionAPI();

        // æ·»åŠ  text
        this._initText();

        // åˆå§‹åŒ–èœå•
        this._initMenus();

        // æ·»åŠ  å›¾ç‰‡ä¸Šä¼ 
        this._initUploadImg();

        // åˆå§‹åŒ–é€‰åŒºï¼Œå°†å…‰æ ‡å®šä½åˆ°å†…å®¹å°¾éƒ¨
        this.initSelection(true);

        // ç»‘å®šäº‹ä»¶
        this._bindEvent();
    },

    // è§£ç»‘æ‰€æœ‰äº‹ä»¶ï¼ˆæš‚æ—¶ä¸å¯¹å¤–å¼€æ”¾ï¼‰
    _offAllEvent: function _offAllEvent() {
        $.offAll();
    }
};

// æ£€éªŒæ˜¯å¦æµè§ˆå™¨ç¯å¢ƒ
try {
    document;
} catch (ex) {
    throw new Error('è¯·åœ¨æµè§ˆå™¨ç¯å¢ƒä¸‹è¿è¡Œ');
}

// polyfill
polyfill();

// è¿™é‡Œçš„ `inlinecss` å°†è¢«æ›¿æ¢æˆ css ä»£ç çš„å†…å®¹ï¼Œè¯¦æƒ…å¯å» ./gulpfile.js ä¸­æœç´¢ `inlinecss` å…³é”®å­—
var inlinecss = '.w-e-toolbar,.w-e-text-container,.w-e-menu-panel {  padding: 0;  margin: 0;  box-sizing: border-box;}.w-e-toolbar *,.w-e-text-container *,.w-e-menu-panel * {  padding: 0;  margin: 0;  box-sizing: border-box;}.w-e-clear-fix:after {  content: "";  display: table;  clear: both;}.w-e-toolbar .w-e-droplist {  position: absolute;  left: 0;  top: 0;  background-color: #fff;  border: 1px solid #f1f1f1;  border-right-color: #ccc;  border-bottom-color: #ccc;}.w-e-toolbar .w-e-droplist .w-e-dp-title {  text-align: center;  color: #999;  line-height: 2;  border-bottom: 1px solid #f1f1f1;  font-size: 13px;}.w-e-toolbar .w-e-droplist ul.w-e-list {  list-style: none;  line-height: 1;}.w-e-toolbar .w-e-droplist ul.w-e-list li.w-e-item {  color: #333;  padding: 5px 0;}.w-e-toolbar .w-e-droplist ul.w-e-list li.w-e-item:hover {  background-color: #f1f1f1;}.w-e-toolbar .w-e-droplist ul.w-e-block {  list-style: none;  text-align: left;  padding: 5px;}.w-e-toolbar .w-e-droplist ul.w-e-block li.w-e-item {  display: inline-block;  *display: inline;  *zoom: 1;  padding: 3px 5px;}.w-e-toolbar .w-e-droplist ul.w-e-block li.w-e-item:hover {  background-color: #f1f1f1;}@font-face {  font-family: \'w-e-icon\';  src: url(data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAABhQAAsAAAAAGAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIPBGNtYXAAAAFoAAABBAAAAQQrSf4BZ2FzcAAAAmwAAAAIAAAACAAAABBnbHlmAAACdAAAEvAAABLwfpUWUWhlYWQAABVkAAAANgAAADYQp00kaGhlYQAAFZwAAAAkAAAAJAfEA+FobXR4AAAVwAAAAIQAAACEeAcD7GxvY2EAABZEAAAARAAAAERBSEX+bWF4cAAAFogAAAAgAAAAIAAsALZuYW1lAAAWqAAAAYYAAAGGmUoJ+3Bvc3QAABgwAAAAIAAAACAAAwAAAAMD3gGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA8fwDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEAOgAAAA2ACAABAAWAAEAIOkG6Q3pEulH6Wbpd+m56bvpxunL6d/qDepc6l/qZepo6nHqefAN8BTxIPHc8fz//f//AAAAAAAg6QbpDekS6UfpZel36bnpu+nG6cvp3+oN6lzqX+pi6mjqcep38A3wFPEg8dzx/P/9//8AAf/jFv4W+Bb0FsAWoxaTFlIWURZHFkMWMBYDFbUVsxWxFa8VpxWiEA8QCQ7+DkMOJAADAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAACAAD/wAQAA8AABAATAAABNwEnAQMuAScTNwEjAQMlATUBBwGAgAHAQP5Anxc7MmOAAYDA/oDAAoABgP6ATgFAQAHAQP5A/p0yOxcBEU4BgP6A/YDAAYDA/oCAAAQAAAAABAADgAAQACEALQA0AAABOAExETgBMSE4ATEROAExITUhIgYVERQWMyEyNjURNCYjBxQGIyImNTQ2MzIWEyE1EwEzNwPA/IADgPyAGiYmGgOAGiYmGoA4KCg4OCgoOED9AOABAEDgA0D9AAMAQCYa/QAaJiYaAwAaJuAoODgoKDg4/biAAYD+wMAAAAIAAABABAADQAA4ADwAAAEmJy4BJyYjIgcOAQcGBwYHDgEHBhUUFx4BFxYXFhceARcWMzI3PgE3Njc2Nz4BNzY1NCcuAScmJwERDQED1TY4OXY8PT8/PTx2OTg2CwcICwMDAwMLCAcLNjg5djw9Pz89PHY5ODYLBwgLAwMDAwsIBwv9qwFA/sADIAgGBggCAgICCAYGCCkqKlktLi8vLi1ZKiopCAYGCAICAgIIBgYIKSoqWS0uLy8uLVkqKin94AGAwMAAAAAAAgDA/8ADQAPAABsAJwAAASIHDgEHBhUUFx4BFxYxMDc+ATc2NTQnLgEnJgMiJjU0NjMyFhUUBgIAQjs6VxkZMjJ4MjIyMngyMhkZVzo7QlBwcFBQcHADwBkZVzo7Qnh9fcxBQUFBzH19eEI7OlcZGf4AcFBQcHBQUHAAAAEAAAAABAADgAArAAABIgcOAQcGBycRISc+ATMyFx4BFxYVFAcOAQcGBxc2Nz4BNzY1NCcuAScmIwIANTIyXCkpI5YBgJA1i1BQRUZpHh4JCSIYGB5VKCAgLQwMKCiLXl1qA4AKCycbHCOW/oCQNDweHmlGRVArKClJICEaYCMrK2I2NjlqXV6LKCgAAQAAAAAEAAOAACoAABMUFx4BFxYXNyYnLgEnJjU0Nz4BNzYzMhYXByERByYnLgEnJiMiBw4BBwYADAwtICAoVR4YGCIJCR4eaUZFUFCLNZABgJYjKSlcMjI1al1eiygoAYA5NjZiKysjYBohIEkpKCtQRUZpHh48NJABgJYjHBsnCwooKIteXQAAAAACAAAAQAQBAwAAJgBNAAATMhceARcWFRQHDgEHBiMiJy4BJyY1JzQ3PgE3NjMVIgYHDgEHPgEhMhceARcWFRQHDgEHBiMiJy4BJyY1JzQ3PgE3NjMVIgYHDgEHPgHhLikpPRESEhE9KSkuLikpPRESASMjelJRXUB1LQkQBwgSAkkuKSk9ERISET0pKS4uKSk9ERIBIyN6UlFdQHUtCRAHCBICABIRPSkpLi4pKT0REhIRPSkpLiBdUVJ6IyOAMC4IEwoCARIRPSkpLi4pKT0REhIRPSkpLiBdUVJ6IyOAMC4IEwoCAQAABgBA/8AEAAPAAAMABwALABEAHQApAAAlIRUhESEVIREhFSEnESM1IzUTFTMVIzU3NSM1MxUVESM1MzUjNTM1IzUBgAKA/YACgP2AAoD9gMBAQECAwICAwMCAgICAgIACAIACAIDA/wDAQP3yMkCSPDJAku7+wEBAQEBAAAYAAP/ABAADwAADAAcACwAXACMALwAAASEVIREhFSERIRUhATQ2MzIWFRQGIyImETQ2MzIWFRQGIyImETQ2MzIWFRQGIyImAYACgP2AAoD9gAKA/YD+gEs1NUtLNTVLSzU1S0s1NUtLNTVLSzU1SwOAgP8AgP8AgANANUtLNTVLS/61NUtLNTVLS/61NUtLNTVLSwADAAAAAAQAA6AAAwANABQAADchFSElFSE1EyEVITUhJQkBIxEjEQAEAPwABAD8AIABAAEAAQD9YAEgASDggEBAwEBAAQCAgMABIP7g/wABAAAAAAACAB7/zAPiA7QAMwBkAAABIiYnJicmNDc2PwE+ATMyFhcWFxYUBwYPAQYiJyY0PwE2NCcuASMiBg8BBhQXFhQHDgEjAyImJyYnJjQ3Nj8BNjIXFhQPAQYUFx4BMzI2PwE2NCcmNDc2MhcWFxYUBwYPAQ4BIwG4ChMIIxISEhIjwCNZMTFZIyMSEhISI1gPLA8PD1gpKRQzHBwzFMApKQ8PCBMKuDFZIyMSEhISI1gPLA8PD1gpKRQzHBwzFMApKQ8PDysQIxISEhIjwCNZMQFECAckLS1eLS0kwCIlJSIkLS1eLS0kVxAQDysPWCl0KRQVFRTAKXQpDysQBwj+iCUiJC0tXi0tJFcQEA8rD1gpdCkUFRUUwCl0KQ8rEA8PJC0tXi0tJMAiJQAAAAAFAAD/wAQAA8AAGwA3AFMAXwBrAAAFMjc+ATc2NTQnLgEnJiMiBw4BBwYVFBceARcWEzIXHgEXFhUUBw4BBwYjIicuAScmNTQ3PgE3NhMyNz4BNzY3BgcOAQcGIyInLgEnJicWFx4BFxYnNDYzMhYVFAYjIiYlNDYzMhYVFAYjIiYCAGpdXosoKCgoi15dampdXosoKCgoi15dalZMTHEgISEgcUxMVlZMTHEgISEgcUxMVisrKlEmJiMFHBtWODc/Pzc4VhscBSMmJlEqK9UlGxslJRsbJQGAJRsbJSUbGyVAKCiLXl1qal1eiygoKCiLXl1qal1eiygoA6AhIHFMTFZWTExxICEhIHFMTFZWTExxICH+CQYGFRAQFEM6OlYYGRkYVjo6QxQQEBUGBvcoODgoKDg4KCg4OCgoODgAAAMAAP/ABAADwAAbADcAQwAAASIHDgEHBhUUFx4BFxYzMjc+ATc2NTQnLgEnJgMiJy4BJyY1NDc+ATc2MzIXHgEXFhUUBw4BBwYTBycHFwcXNxc3JzcCAGpdXosoKCgoi15dampdXosoKCgoi15dalZMTHEgISEgcUxMVlZMTHEgISEgcUxMSqCgYKCgYKCgYKCgA8AoKIteXWpqXV6LKCgoKIteXWpqXV6LKCj8YCEgcUxMVlZMTHEgISEgcUxMVlZMTHEgIQKgoKBgoKBgoKBgoKAAAQBl/8ADmwPAACkAAAEiJiMiBw4BBwYVFBYzLgE1NDY3MAcGAgcGBxUhEzM3IzceATMyNjcOAQMgRGhGcVNUbRobSUgGDWVKEBBLPDxZAT1sxizXNC1VJi5QGB09A7AQHh1hPj9BTTsLJjeZbwN9fv7Fj5AjGQIAgPYJDzdrCQcAAAAAAgAAAAAEAAOAAAkAFwAAJTMHJzMRIzcXIyURJyMRMxUhNTMRIwcRA4CAoKCAgKCggP8AQMCA/oCAwEDAwMACAMDAwP8AgP1AQEACwIABAAADAMAAAANAA4AAFgAfACgAAAE+ATU0Jy4BJyYjIREhMjc+ATc2NTQmATMyFhUUBisBEyMRMzIWFRQGAsQcIBQURi4vNf7AAYA1Ly5GFBRE/oRlKjw8KWafn58sPj4B2yJULzUvLkYUFPyAFBRGLi81RnQBRks1NUv+gAEASzU1SwAAAAACAMAAAANAA4AAHwAjAAABMxEUBw4BBwYjIicuAScmNREzERQWFx4BMzI2Nz4BNQEhFSECwIAZGVc6O0JCOzpXGRmAGxgcSSgoSRwYG/4AAoD9gAOA/mA8NDVOFhcXFk41NDwBoP5gHjgXGBsbGBc4Hv6ggAAAAAABAIAAAAOAA4AACwAAARUjATMVITUzASM1A4CA/sCA/kCAAUCAA4BA/QBAQAMAQAABAAAAAAQAA4AAPQAAARUjHgEVFAYHDgEjIiYnLgE1MxQWMzI2NTQmIyE1IS4BJy4BNTQ2Nz4BMzIWFx4BFSM0JiMiBhUUFjMyFhcEAOsVFjUwLHE+PnEsMDWAck5OcnJO/gABLAIEATA1NTAscT4+cSwwNYByTk5yck47bisBwEAdQSI1YiQhJCQhJGI1NExMNDRMQAEDASRiNTViJCEkJCEkYjU0TEw0NEwhHwAAAAcAAP/ABAADwAADAAcACwAPABMAGwAjAAATMxUjNzMVIyUzFSM3MxUjJTMVIwMTIRMzEyETAQMhAyMDIQMAgIDAwMABAICAwMDAAQCAgBAQ/QAQIBACgBD9QBADABAgEP2AEAHAQEBAQEBAQEBAAkD+QAHA/oABgPwAAYD+gAFA/sAAAAoAAAAABAADgAADAAcACwAPABMAFwAbAB8AIwAnAAATESERATUhFR0BITUBFSE1IxUhNREhFSElIRUhETUhFQEhFSEhNSEVAAQA/YABAP8AAQD/AED/AAEA/wACgAEA/wABAPyAAQD/AAKAAQADgPyAA4D9wMDAQMDAAgDAwMDA/wDAwMABAMDA/sDAwMAAAAUAAAAABAADgAADAAcACwAPABMAABMhFSEVIRUhESEVIREhFSERIRUhAAQA/AACgP2AAoD9gAQA/AAEAPwAA4CAQID/AIABQID/AIAAAAAABQAAAAAEAAOAAAMABwALAA8AEwAAEyEVIRchFSERIRUhAyEVIREhFSEABAD8AMACgP2AAoD9gMAEAPwABAD8AAOAgECA/wCAAUCA/wCAAAAFAAAAAAQAA4AAAwAHAAsADwATAAATIRUhBSEVIREhFSEBIRUhESEVIQAEAPwAAYACgP2AAoD9gP6ABAD8AAQA/AADgIBAgP8AgAFAgP8AgAAAAAABAD8APwLmAuYALAAAJRQPAQYjIi8BBwYjIi8BJjU0PwEnJjU0PwE2MzIfATc2MzIfARYVFA8BFxYVAuYQThAXFxCoqBAXFhBOEBCoqBAQThAWFxCoqBAXFxBOEBCoqBDDFhBOEBCoqBAQThAWFxCoqBAXFxBOEBCoqBAQThAXFxCoqBAXAAAABgAAAAADJQNuABQAKAA8AE0AVQCCAAABERQHBisBIicmNRE0NzY7ATIXFhUzERQHBisBIicmNRE0NzY7ATIXFhcRFAcGKwEiJyY1ETQ3NjsBMhcWExEhERQXFhcWMyEyNzY3NjUBIScmJyMGBwUVFAcGKwERFAcGIyEiJyY1ESMiJyY9ATQ3NjsBNzY3NjsBMhcWHwEzMhcWFQElBgUIJAgFBgYFCCQIBQaSBQUIJQgFBQUFCCUIBQWSBQUIJQgFBQUFCCUIBQVJ/gAEBAUEAgHbAgQEBAT+gAEAGwQGtQYEAfcGBQg3Ghsm/iUmGxs3CAUFBQUIsSgIFxYXtxcWFgkosAgFBgIS/rcIBQUFBQgBSQgFBgYFCP63CAUFBQUIAUkIBQYGBQj+twgFBQUFCAFJCAUGBgX+WwId/eMNCwoFBQUFCgsNAmZDBQICBVUkCAYF/eMwIiMhIi8CIAUGCCQIBQVgFQ8PDw8VYAUFCAACAAcASQO3Aq8AGgAuAAAJAQYjIi8BJjU0PwEnJjU0PwE2MzIXARYVFAcBFRQHBiMhIicmPQE0NzYzITIXFgFO/vYGBwgFHQYG4eEGBh0FCAcGAQoGBgJpBQUI/dsIBQUFBQgCJQgFBQGF/vYGBhwGCAcG4OEGBwcGHQUF/vUFCAcG/vslCAUFBQUIJQgFBQUFAAAAAQAjAAAD3QNuALMAACUiJyYjIgcGIyInJjU0NzY3Njc2NzY9ATQnJiMhIgcGHQEUFxYXFjMWFxYVFAcGIyInJiMiBwYjIicmNTQ3Njc2NzY3Nj0BETQ1NDU0JzQnJicmJyYnJicmIyInJjU0NzYzMhcWMzI3NjMyFxYVFAcGIwYHBgcGHQEUFxYzITI3Nj0BNCcmJyYnJjU0NzYzMhcWMzI3NjMyFxYVFAcGByIHBgcGFREUFxYXFhcyFxYVFAcGIwPBGTMyGhkyMxkNCAcJCg0MERAKEgEHFf5+FgcBFQkSEw4ODAsHBw4bNTUaGDExGA0HBwkJCwwQDwkSAQIBAgMEBAUIEhENDQoLBwcOGjU1GhgwMRgOBwcJCgwNEBAIFAEHDwGQDgcBFAoXFw8OBwcOGTMyGRkxMRkOBwcKCg0NEBEIFBQJEREODQoLBwcOAAICAgIMCw8RCQkBAQMDBQxE4AwFAwMFDNRRDQYBAgEICBIPDA0CAgICDAwOEQgJAQIDAwUNRSEB0AINDQgIDg4KCgsLBwcDBgEBCAgSDwwNAgICAg0MDxEICAECAQYMULYMBwEBBwy2UAwGAQEGBxYPDA0CAgICDQwPEQgIAQECBg1P/eZEDAYCAgEJCBEPDA0AAAIAAP+3A/8DtwATADkAAAEyFxYVFAcCBwYjIicmNTQ3ATYzARYXFh8BFgcGIyInJicmJyY1FhcWFxYXFjMyNzY3Njc2NzY3NjcDmygeHhq+TDdFSDQ0NQFtISn9+BcmJy8BAkxMe0c2NiEhEBEEExQQEBIRCRcIDxITFRUdHR4eKQO3GxooJDP+mUY0NTRJSTABSx/9sSsfHw0oek1MGhsuLzo6RAMPDgsLCgoWJRsaEREKCwQEAgABAAAAAAAA9evv618PPPUACwQAAAAAANbEBFgAAAAA1sQEWAAA/7cEAQPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAD//wQBAAEAAAAAAAAAAAAAAAAAAAAhBAAAAAAAAAAAAAAAAgAAAAQAAAAEAAAABAAAAAQAAMAEAAAABAAAAAQAAAAEAABABAAAAAQAAAAEAAAeBAAAAAQAAAAEAABlBAAAAAQAAMAEAADABAAAgAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAMlAD8DJQAAA74ABwQAACMD/wAAAAAAAAAKABQAHgBMAJQA+AE2AXwBwgI2AnQCvgLoA34EHgSIBMoE8gU0BXAFiAXgBiIGagaSBroG5AcoB+AIKgkcCXgAAQAAACEAtAAKAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGljb21vb24AaQBjAG8AbQBvAG8AblZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGljb21vb24AaQBjAG8AbQBvAG8Abmljb21vb24AaQBjAG8AbQBvAG8AblJlZ3VsYXIAUgBlAGcAdQBsAGEAcmljb21vb24AaQBjAG8AbQBvAG8AbkZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=) format(\'truetype\');  font-weight: normal;  font-style: normal;}[class^="w-e-icon-"],[class*=" w-e-icon-"] {  /* use !important to prevent issues with browser extensions that change fonts */  font-family: \'w-e-icon\' !important;  speak: none;  font-style: normal;  font-weight: normal;  font-variant: normal;  text-transform: none;  line-height: 1;  /* Better Font Rendering =========== */  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;}.w-e-icon-close:before {  content: "\\f00d";}.w-e-icon-upload2:before {  content: "\\e9c6";}.w-e-icon-trash-o:before {  content: "\\f014";}.w-e-icon-header:before {  content: "\\f1dc";}.w-e-icon-pencil2:before {  content: "\\e906";}.w-e-icon-paint-brush:before {  content: "\\f1fc";}.w-e-icon-image:before {  content: "\\e90d";}.w-e-icon-play:before {  content: "\\e912";}.w-e-icon-location:before {  content: "\\e947";}.w-e-icon-undo:before {  content: "\\e965";}.w-e-icon-redo:before {  content: "\\e966";}.w-e-icon-quotes-left:before {  content: "\\e977";}.w-e-icon-list-numbered:before {  content: "\\e9b9";}.w-e-icon-list2:before {  content: "\\e9bb";}.w-e-icon-link:before {  content: "\\e9cb";}.w-e-icon-happy:before {  content: "\\e9df";}.w-e-icon-bold:before {  content: "\\ea62";}.w-e-icon-underline:before {  content: "\\ea63";}.w-e-icon-italic:before {  content: "\\ea64";}.w-e-icon-strikethrough:before {  content: "\\ea65";}.w-e-icon-table2:before {  content: "\\ea71";}.w-e-icon-paragraph-left:before {  content: "\\ea77";}.w-e-icon-paragraph-center:before {  content: "\\ea78";}.w-e-icon-paragraph-right:before {  content: "\\ea79";}.w-e-icon-terminal:before {  content: "\\f120";}.w-e-icon-page-break:before {  content: "\\ea68";}.w-e-icon-cancel-circle:before {  content: "\\ea0d";}.w-e-icon-font:before {  content: "\\ea5c";}.w-e-icon-text-heigh:before {  content: "\\ea5f";}.w-e-toolbar {  display: -webkit-box;  display: -ms-flexbox;  display: flex;  padding: 0 5px;  /* flex-wrap: wrap; */  /* å•ä¸ªèœå• */}.w-e-toolbar .w-e-menu {  position: relative;  text-align: center;  padding: 5px 10px;  cursor: pointer;}.w-e-toolbar .w-e-menu i {  color: #999;}.w-e-toolbar .w-e-menu:hover i {  color: #333;}.w-e-toolbar .w-e-active i {  color: #1e88e5;}.w-e-toolbar .w-e-active:hover i {  color: #1e88e5;}.w-e-text-container .w-e-panel-container {  position: absolute;  top: 0;  left: 50%;  border: 1px solid #ccc;  border-top: 0;  box-shadow: 1px 1px 2px #ccc;  color: #333;  background-color: #fff;  /* ä¸º emotion panel å®šåˆ¶çš„æ ·å¼ */  /* ä¸Šä¼ å›¾ç‰‡çš„ panel å®šåˆ¶æ ·å¼ */}.w-e-text-container .w-e-panel-container .w-e-panel-close {  position: absolute;  right: 0;  top: 0;  padding: 5px;  margin: 2px 5px 0 0;  cursor: pointer;  color: #999;}.w-e-text-container .w-e-panel-container .w-e-panel-close:hover {  color: #333;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-title {  list-style: none;  display: -webkit-box;  display: -ms-flexbox;  display: flex;  font-size: 14px;  margin: 2px 10px 0 10px;  border-bottom: 1px solid #f1f1f1;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-title .w-e-item {  padding: 3px 5px;  color: #999;  cursor: pointer;  margin: 0 3px;  position: relative;  top: 1px;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-title .w-e-active {  color: #333;  border-bottom: 1px solid #333;  cursor: default;  font-weight: 700;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content {  padding: 10px 15px 10px 15px;  font-size: 16px;  /* è¾“å…¥æ¡†çš„æ ·å¼ */  /* æŒ‰é’®çš„æ ·å¼ */}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content input:focus,.w-e-text-container .w-e-panel-container .w-e-panel-tab-content textarea:focus,.w-e-text-container .w-e-panel-container .w-e-panel-tab-content button:focus {  outline: none;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content textarea {  width: 100%;  border: 1px solid #ccc;  padding: 5px;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content textarea:focus {  border-color: #1e88e5;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content input[type=text] {  border: none;  border-bottom: 1px solid #ccc;  font-size: 14px;  height: 20px;  color: #333;  text-align: left;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content input[type=text].small {  width: 30px;  text-align: center;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content input[type=text].block {  display: block;  width: 100%;  margin: 10px 0;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content input[type=text]:focus {  border-bottom: 2px solid #1e88e5;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content .w-e-button-container button {  font-size: 14px;  color: #1e88e5;  border: none;  padding: 5px 10px;  background-color: #fff;  cursor: pointer;  border-radius: 3px;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content .w-e-button-container button.left {  float: left;  margin-right: 10px;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content .w-e-button-container button.right {  float: right;  margin-left: 10px;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content .w-e-button-container button.gray {  color: #999;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content .w-e-button-container button.red {  color: #c24f4a;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content .w-e-button-container button:hover {  background-color: #f1f1f1;}.w-e-text-container .w-e-panel-container .w-e-panel-tab-content .w-e-button-container:after {  content: "";  display: table;  clear: both;}.w-e-text-container .w-e-panel-container .w-e-emoticon-container .w-e-item {  cursor: pointer;  font-size: 18px;  padding: 0 3px;  display: inline-block;  *display: inline;  *zoom: 1;}.w-e-text-container .w-e-panel-container .w-e-up-img-container {  text-align: center;}.w-e-text-container .w-e-panel-container .w-e-up-img-container .w-e-up-btn {  display: inline-block;  *display: inline;  *zoom: 1;  color: #999;  cursor: pointer;  font-size: 60px;  line-height: 1;}.w-e-text-container .w-e-panel-container .w-e-up-img-container .w-e-up-btn:hover {  color: #333;}.w-e-text-container {  position: relative;}.w-e-text-container .w-e-progress {  position: absolute;  background-color: #1e88e5;  bottom: 0;  left: 0;  height: 1px;}.w-e-text {  padding: 0 10px;  overflow-y: scroll;}.w-e-text p,.w-e-text h1,.w-e-text h2,.w-e-text h3,.w-e-text h4,.w-e-text h5,.w-e-text table,.w-e-text pre {  margin: 10px 0;  line-height: 1.5;}.w-e-text ul,.w-e-text ol {  margin: 10px 0 10px 20px;}.w-e-text blockquote {  display: block;  border-left: 8px solid #d0e5f2;  padding: 5px 10px;  margin: 10px 0;  line-height: 1.4;  font-size: 100%;  background-color: #f1f1f1;}.w-e-text code {  display: inline-block;  *display: inline;  *zoom: 1;  background-color: #f1f1f1;  border-radius: 3px;  padding: 3px 5px;  margin: 0 3px;}.w-e-text pre code {  display: block;}.w-e-text table {  border-top: 1px solid #ccc;  border-left: 1px solid #ccc;}.w-e-text table td,.w-e-text table th {  border-bottom: 1px solid #ccc;  border-right: 1px solid #ccc;  padding: 3px 5px;}.w-e-text table th {  border-bottom: 2px solid #ccc;  text-align: center;}.w-e-text:focus {  outline: none;}.w-e-text img {  cursor: pointer;}.w-e-text img:hover {  box-shadow: 0 0 5px #333;}';

// å°† css ä»£ç æ·»åŠ åˆ° <style> ä¸­
var style = document.createElement('style');
style.type = 'text/css';
style.innerHTML = inlinecss;
document.getElementsByTagName('HEAD').item(0).appendChild(style);

// è¿”å›
var index = window.wangEditor || Editor;

return index;

})));


/***/ }),

/***/ 17:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ 18:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(6);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ 19:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),

/***/ 2:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);
var normalizeHeaderName = __webpack_require__(17);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(5);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(5);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),

/***/ 20:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ 21:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ 22:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),

/***/ 25:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ 26:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var transformData = __webpack_require__(27);
var isCancel = __webpack_require__(7);
var defaults = __webpack_require__(2);
var isAbsoluteURL = __webpack_require__(28);
var combineURLs = __webpack_require__(29);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ 27:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ 28:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ 29:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ 3:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ 30:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(8);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ 31:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ 32:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(11);
/* jshint esversion: 6 */



let bindFieldValidator = function (el, binding, vnode) {
    // è§£æåŠ¨æ€è¡¨è¾¾å¼
    let prop = binding.expression;
    for (let key of Object.keys(vnode.data.attrs)) {
        if (key && key.startsWith('dsp-index-')) {
            prop = prop.replace(key.substr('dsp-index-'.length, key.length), vnode.data.attrs[key]);
        }
    }

    //binding.expression.replace(/\[[a-zA-Z0-9]*]/g, '.');
    // let ruleProp = binding.expression.replace(/\[/g, '.').replace(/]/g, '');
    let ruleProp = binding.expression;

    // è§£ææ ¡éªŒè§„åˆ™
    let rules = __WEBPACK_IMPORTED_MODULE_0__utils__["default"].getProp(vnode.context, '$data.$validator.rule');
    let rule = __WEBPACK_IMPORTED_MODULE_0__utils__["default"].getProp(rules, ruleProp);
    if (!rule) {
        //æ²¡æœ‰è§„åˆ™ï¼Œä¸åšæ ¡éªŒ
        console.warn('can not find validate rule config for ' + ruleProp + ' in $validator.rule, it will not be verified. ');
        return;
    }

    if (!vnode.context.$data.$validator.validator) {
        vnode.context.$data.$validator.validator = {};
    }

    // å­—æ®µæ ¡éªŒ
    let fieldValidator = function (value) {
        let val = value || __WEBPACK_IMPORTED_MODULE_0__utils__["default"].getProp(vnode.context, '$data.' + prop);

        return Promise.resolve({ $prop: prop }).then(error => {
            if (rule.required) {
                if (!val) {
                    error.required = true;
                } else if (typeof val == 'string' && val.trim().length == 0) {
                    error.required = true;
                } else if (val instanceof Array && val.length == 0) {
                    error.required = true;
                } else if (typeof val == 'object' && Object.keys(val).length == 0) {
                    error.required = true;
                } else {
                    error.required = false;
                }
            }
            return error;
        }).then(error => {
            if (rule.minLength) {
                if (!val) {
                    error.minLength = false;
                } else if (typeof val == 'string' && val.trim().length < rule.minLength) {
                    error.minLength = true;
                } else if (val instanceof Array && val.length < rule.minLength) {
                    error.minLength = true;
                } else {
                    error.minLength = false;
                }
            }

            return error;
        }).then(error => {
            if (rule.min || rule.min === 0) {
                if (!val) {
                    error.min = false;
                } else if (typeof val == 'string') {
                    if (val.trim().length == 0 || isNaN(val)) {
                        error.min = false;
                    } else {
                        error.min = parseFloat(val) <= rule.min;
                    }
                } else {
                    error.min = false;
                }
            }

            return error;
        }).then(error => {
            if (rule.max) {
                if (!val) {
                    error.max = false;
                } else if (typeof val == 'string') {
                    if (val.trim().length == 0 || isNaN(val)) {
                        error.max = false;
                    } else {
                        error.max = parseFloat(val) > rule.max;
                    }
                } else {
                    error.max = false;
                }
            }

            return error;
        }).then(error => {
            if (rule.remote && typeof rule.remote == 'function') {
                return rule.remote(vnode.context.$data, val).then(pass => {
                    if (!pass) {
                        error.remote = true;
                    } else {
                        error.remote = false;
                    }

                    return error;
                });
            }

            return error;
        }).then(error => {
            if (rule.customize && typeof rule.customize == 'function') {
                return rule.customize(vnode.context.$data, val).then(pass => {
                    if (!pass) {
                        error.customize = true;
                    } else {
                        error.customize = false;
                    }

                    return error;
                });
            }

            return error;
        }).then(error => {
            error.$pass = Object.keys(error).map(key => error[key]).filter(v => v == true).length == 0;

            if (!error.$pass) {
                // æœªé€šè¿‡æ ¡éªŒ
                if (!vnode.context.$data.$validator.error) {
                    vnode.context.$data.$validator.error = {};
                }

                vnode.context.$data.$validator.error[prop] = error;
            } else {
                // é€šè¿‡æ ¡éªŒ
                if (vnode.context.$data.$validator.error) {
                    delete vnode.context.$data.$validator.error[prop];
                }
            }

            return error;
        }).then(error => {
            /* æ·»åŠ CSS */

            if (!el.classList.contains('form-validate-field')) {
                el.classList.add('form-validate-field');
            }

            if (!error.$pass) {
                // æœªé€šè¿‡æ ¡éªŒ
                if (!el.classList.contains('is-error')) {
                    el.classList.add('is-error');
                }
            } else {
                // é€šè¿‡æ ¡éªŒ
                el.classList.remove('is-error');
            }

            if (error.required) {
                if (!el.classList.contains('err-required')) {
                    el.classList.add('err-required');
                }
            } else {
                el.classList.remove('err-required');
            }

            if (error.minLength) {
                if (!el.classList.contains('err-minlength')) {
                    el.classList.add('err-minlength');
                }
            } else {
                el.classList.remove('err-minlength');
            }

            if (error.min) {
                if (!el.classList.contains('err-min')) {
                    el.classList.add('err-min');
                }
            } else {
                el.classList.remove('err-min');
            }

            if (error.max) {
                if (!el.classList.contains('err-max')) {
                    el.classList.add('err-max');
                }
            } else {
                el.classList.remove('err-max');
            }

            if (error.remote) {
                if (!el.classList.contains('err-remote')) {
                    el.classList.add('err-remote');
                }
            } else {
                el.classList.remove('err-remote');
            }

            if (error.customize) {
                if (!el.classList.contains('err-customize')) {
                    el.classList.add('err-customize');
                }
            } else {
                el.classList.remove('err-customize');
            }

            return error.$pass;
        });
    };

    // æ³¨å†Œåˆ°è¡¨å•æ ¡éªŒå™¨ä¸­
    vnode.context.$data.$validator.validator[prop] = fieldValidator;

    // å­—æ®µç›‘å¬ï¼Œå˜åŒ–åè‡ªåŠ¨æ ¡éªŒ
    if (!vnode.context.$data.$validator.watcher) {
        vnode.context.$data.$validator.watcher = {};
    }

    // å­—æ®µç›‘å¬
    let unwatch = vnode.context.$watch(prop, function (newVal, oldVal) {
        console.debug(prop + ' value changed from %o to: %o', oldVal, newVal);
        fieldValidator(newVal);
    });

    // è¡¨å•ç›‘å¬å™¨ä¸­å­˜åœ¨è¯¥å­—æ®µç›‘å¬ï¼Œåˆ™å…ˆæ³¨é”€æ—§çš„å­—æ®µç›‘å¬å™¨
    if (vnode.context.$data.$validator.watcher[prop]) {
        vnode.context.$data.$validator.watcher[prop]();
        delete vnode.context.$data.$validator.watcher[prop];
        console.debug('watcher removed:' + prop);
    }

    // æ³¨å†Œåˆ°è¡¨å•ç›‘å¬å™¨ä¸­
    console.debug('watcher added:' + prop);
    vnode.context.$data.$validator.watcher[prop] = unwatch;

    console.debug('validator: %o', vnode.context.$data.$validator);
};

let unbindFieldValidator = function (el, binding, vnode) {
    // è§£æåŠ¨æ€è¡¨è¾¾å¼
    let prop = binding.expression;
    for (let key of Object.keys(vnode.data.attrs)) {
        if (key && key.startsWith('dsp-index-')) {
            prop = prop.replace(key.substr('dsp-index-'.length, key.length), vnode.data.attrs[key]);
        }
    }

    // ä»æ ¡éªŒé”™è¯¯ä¸­ç§»é™¤
    if (vnode.context.$data.$validator.error) {
        delete vnode.context.$data.$validator.error[prop];
        console.debug('error removed:' + prop);
    }

    // ä»è¡¨å•æ ¡éªŒå™¨ä¸­ç§»é™¤
    if (vnode.context.$data.$validator.validator) {
        delete vnode.context.$data.$validator.validator[prop];
        console.debug('validator removed:' + prop);
    }

    // ä»è¡¨å•ç›‘å¬å™¨ä¸­ç§»é™¤
    if (vnode.context.$data.$validator.watcher && vnode.context.$data.$validator.watcher[prop]) {
        vnode.context.$data.$validator.watcher[prop]();
        delete vnode.context.$data.$validator.watcher[prop];
        console.debug('watcher removed:' + prop);
    }

    console.debug('validator: %o', vnode.context.$data.$validator);
};

/* harmony default export */ __webpack_exports__["default"] = ({

    //åªå…è®¸è¾“å…¥æ•´æ•°
    integer: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');
            el.onkeydown = function ($event) {
                let keyCode = $event.keyCode;
                let val = input.value;

                if (keyCode === 8 || keyCode === 9 || keyCode === 46 || keyCode === 37 || keyCode === 39 || keyCode === 17 || keyCode === 86) {
                    //é€€æ ¼ã€Tabé”®ã€åˆ é™¤ã€æ–¹å‘ã€Control+Vé”®
                } else {
                    //åªå…è®¸è¾“å…¥æ•´æ•°
                    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105) {
                        // if (val === '0') {
                        //     //é¦–ä½æ•°å­—ä¸º0ï¼Œç¦æ­¢è¾“å…¥
                        //     $event.preventDefault();
                        // }
                    } else {
                        $event.preventDefault();
                    }
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    // let regExp =  /^0{1}$|^[1-9]{1}\d*$/;
                    let regExp = /^0{1}$|^[0-9]{1}\d*$/;
                    if (newVal && !regExp.test(newVal)) {
                        console.debug('%o ä¸æ˜¯æœ‰æ•ˆçš„æ•´æ•°, è¿˜åŸåˆ°ä¸Šæ¬¡æœ‰æ•ˆå€¼ %o', newVal, oldVal);
                        //
                        // let bytes = newVal.split('');
                        // let validVal;
                        //
                        // while (bytes.length > 0) {
                        //     bytes.pop();
                        //     validVal = bytes.join('');
                        //     if (regExp.test(validVal)) {
                        //         break;
                        //     }
                        // }

                        __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, oldVal);
                    }
                });
            } else {
                console.warn('%o v-dsp-input-integer è¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-integer="vm.your.property"', input);
            }
        }
    },

    //å…è®¸è¾“å…¥6ä½æ•°å­—éªŒè¯ç 
    captcha: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');
            el.onkeydown = function ($event) {
                let keyCode = $event.keyCode;

                if (keyCode === 8 || keyCode === 9 || keyCode === 46 || keyCode === 37 || keyCode === 39 || keyCode === 17 || keyCode === 86) {
                    //é€€æ ¼ã€Tabé”®ã€åˆ é™¤ã€æ–¹å‘ã€Control+Vé”®
                } else {
                    //éªŒè¯ç è¿™ç§çº¯æ•°å­—
                    if (keyCode < 48 || keyCode > 105 || keyCode > 57 && keyCode < 96) {
                        $event.preventDefault();
                    }
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    let regExp = /^\d{0,6}$/;
                    if (newVal && !regExp.test(newVal)) {
                        console.debug('%o ä¸æ˜¯æœ‰æ•ˆçš„éªŒè¯ç , è¿˜åŸåˆ°ä¸Šæ¬¡æœ‰æ•ˆå€¼ %o', newVal, oldVal);
                        //
                        // let bytes = newVal.split('');
                        // let validVal;
                        //
                        // while (bytes.length > 0) {
                        //     bytes.pop();
                        //     validVal = bytes.join('');
                        //     if (regExp.test(validVal)) {
                        //         break;
                        //     }
                        // }

                        __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, oldVal);
                    }
                });
            } else {
                console.warn('%o v-dsp-input-captcha è¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-captcha="vm.your.property"', input);
            }
        }
    },

    //å…è®¸è¾“å…¥æ•´æ•°æˆ–æµ®ç‚¹æ•°ï¼Œå°æ•°ç‚¹åä¿ç•™2ä½
    number: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');

            el.onkeydown = function ($event) {
                let keyCode = $event.keyCode;
                let val = input.value;
                if (keyCode === 8 || keyCode === 9 || keyCode === 46 || keyCode === 37 || keyCode === 39 || keyCode === 17 || keyCode === 86) {
                    //é€€æ ¼ã€Tabé”®ã€åˆ é™¤ã€æ–¹å‘ã€Control+Vé”®

                } else {
                    //å¯è¾“å…¥æ•´æ•°æˆ–å°æ•°ï¼ˆç²¾ç¡®åˆ°å°æ•°ç‚¹åä¸¤ä½ï¼‰
                    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105 || keyCode === 110 || keyCode === 190) {

                        if (val === '' && (keyCode === 110 || keyCode === 190)) {
                            //ä¸å…è®¸ç›´æ¥è¾“å…¥å°æ•°ç‚¹
                            $event.preventDefault();
                        }

                        /*if (val === '0' && (keyCode !== 110 && keyCode !== 190)) {
                            //é¦–ä½æ•°å­—ä¸º0ï¼Œåªå…è®¸è¾“å…¥å°æ•°ç‚¹
                            $event.preventDefault();
                        }*/

                        if (val.indexOf('.') !== -1 && (keyCode === 110 || keyCode === 190)) {
                            //å·²ç»æœ‰å°æ•°ç‚¹ï¼Œä¸å…è®¸å†æ¬¡è¾“å…¥å°æ•°ç‚¹
                            $event.preventDefault();
                        }

                        if (val.indexOf('.') !== -1 && val.substring(val.indexOf('.') + 1).length >= 2) {
                            //ç²¾ç¡®åˆ°å°æ•°ç‚¹åä¸¤ä½
                            $event.preventDefault();
                        }
                    } else {
                        $event.preventDefault();
                    }
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    let regExp = /^0{1}$|^0\.\d{0,2}$|^[1-9]{1}\d*\.?\d{0,2}$/;
                    if (newVal && !regExp.test(newVal)) {
                        console.debug('%o ä¸æ˜¯æœ‰æ•ˆçš„æ•°å€¼, è¿˜åŸåˆ°ä¸Šæ¬¡æœ‰æ•ˆå€¼ %o', newVal, oldVal);
                        //
                        // let bytes = newVal.split('');
                        // let validVal;
                        //
                        // while (bytes.length > 0) {
                        //     bytes.pop();
                        //     validVal = bytes.join('');
                        //     if (regExp.test(validVal)) {
                        //         break;
                        //     }
                        // }

                        __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, oldVal);
                    }
                });
            } else {
                console.warn('%o v-dsp-input-number è¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-number="vm.your.property"', input);
            }
        }
    },

    //åº§æœºç”µè¯å’Œç”µè¯
    telephone: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');
            el.onkeydown = function ($event) {
                let keyCode = $event.keyCode;
                let val = input.value;

                if (keyCode === 8 || keyCode === 9 || keyCode === 46 || keyCode === 37 || keyCode === 39 || keyCode === 17 || keyCode === 86) {
                    //é€€æ ¼ã€Tabé”®ã€åˆ é™¤ã€æ–¹å‘ã€Control+Vé”®
                } else {
                    //åªå…è®¸è¾“å…¥æ•´æ•°
                    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105) {
                        // if (val === '0') {
                        //     //é¦–ä½æ•°å­—ä¸º0ï¼Œç¦æ­¢è¾“å…¥
                        //     $event.preventDefault();
                        // }
                    } else {
                        $event.preventDefault();
                    }
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    // let regExp =  /^0{1}$|^[1-9]{1}\d*$/;
                    let regExp = /^[\d-]*$/;
                    if (newVal && !regExp.test(newVal)) {
                        console.debug('%o ä¸æ˜¯æœ‰æ•ˆçš„æ•´æ•°, è¿˜åŸåˆ°ä¸Šæ¬¡æœ‰æ•ˆå€¼ %o', newVal, oldVal);
                        //
                        // let bytes = newVal.split('');
                        // let validVal;
                        //
                        // while (bytes.length > 0) {
                        //     bytes.pop();
                        //     validVal = bytes.join('');
                        //     if (regExp.test(validVal)) {
                        //         break;
                        //     }
                        // }

                        __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, oldVal);
                    }
                });
            } else {
                console.warn('%o v-dsp-input-integer è¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-integer="vm.your.property"', input);
            }
        }
    },

    //å…è®¸è¾“å…¥æ•´æ•°æˆ–æµ®ç‚¹æ•°ï¼Œå°æ•°ç‚¹åä¿ç•™4ä½,ç”¨äºæŠ˜æ‰£çš„è¾“å…¥æ¡†
    discount: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');

            el.onkeydown = function ($event) {
                let keyCode = $event.keyCode;
                let val = input.value;
                if (keyCode === 8 || keyCode === 9 || keyCode === 46 || keyCode === 37 || keyCode === 39 || keyCode === 17 || keyCode === 86) {
                    //é€€æ ¼ã€Tabé”®ã€åˆ é™¤ã€æ–¹å‘ã€Control+Vé”®

                } else {
                    //å¯è¾“å…¥æ•´æ•°æˆ–å°æ•°ï¼ˆç²¾ç¡®åˆ°å°æ•°ç‚¹åä¸¤ä½ï¼‰
                    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105 || keyCode === 110 || keyCode === 190) {

                        if (val === '' && (keyCode === 110 || keyCode === 190)) {
                            //ä¸å…è®¸ç›´æ¥è¾“å…¥å°æ•°ç‚¹
                            $event.preventDefault();
                        }

                        /*if (val === '0' && (keyCode !== 110 && keyCode !== 190)) {
                            //é¦–ä½æ•°å­—ä¸º0ï¼Œåªå…è®¸è¾“å…¥å°æ•°ç‚¹
                            $event.preventDefault();
                        }*/

                        if (val.indexOf('.') !== -1 && (keyCode === 110 || keyCode === 190)) {
                            //å·²ç»æœ‰å°æ•°ç‚¹ï¼Œä¸å…è®¸å†æ¬¡è¾“å…¥å°æ•°ç‚¹
                            $event.preventDefault();
                        }

                        if (val.indexOf('.') !== -1 && val.substring(val.indexOf('.') + 1).length >= 4) {
                            //ç²¾ç¡®åˆ°å°æ•°ç‚¹åä¸¤ä½
                            $event.preventDefault();
                        }
                    } else {
                        $event.preventDefault();
                    }
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    let regExp = /^0{1}$|^0\.\d{0,4}$|^1{1}$/;
                    if (newVal && !regExp.test(newVal)) {
                        console.debug('%o ä¸æ˜¯æœ‰æ•ˆçš„æ•°å€¼, è¿˜åŸåˆ°ä¸Šæ¬¡æœ‰æ•ˆå€¼ %o', newVal, oldVal);
                        //
                        // let bytes = newVal.split('');
                        // let validVal;
                        //
                        // while (bytes.length > 0) {
                        //     bytes.pop();
                        //     validVal = bytes.join('');
                        //     if (regExp.test(validVal)) {
                        //         break;
                        //     }
                        // }

                        __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, oldVal);
                    }
                });
            } else {
                console.warn('%o v-dsp-input-number è¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-number="vm.your.property"', input);
            }
        }
    },

    //å…è®¸è¾“å…¥æ‰‹æœºå·ç 
    mobile: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');
            el.onkeydown = function ($event) {
                let keyCode = $event.keyCode;
                let val = input.value;
                if (keyCode === 8 || keyCode === 9 || keyCode === 46 || keyCode === 37 || keyCode === 39 || keyCode === 17 || keyCode === 86) {
                    //é€€æ ¼ã€Tabé”®ã€åˆ é™¤ã€æ–¹å‘ã€Control+Vé”®
                } else {
                    if (val.length >= 11) {
                        //åªå…è®¸è¾“å…¥11ä½
                        $event.preventDefault();
                    }

                    //å¯è¾“å…¥æ•´æ•°æˆ–å°æ•°ï¼ˆç²¾ç¡®åˆ°å°æ•°ç‚¹åä¸¤ä½ï¼‰
                    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105) {
                        if (val === '' && keyCode !== 49 && keyCode !== 97) {
                            //æ‰‹æœºå·ä»¥1å¼€å¤´
                            $event.preventDefault();
                        }

                        if (val === '1' && (keyCode < 51 || keyCode > 57) && (keyCode < 99 || keyCode > 105)) {
                            //æ‰‹æœºå·ç¬¬2ä½åªèƒ½æ˜¯3~9
                            $event.preventDefault();
                        }
                    } else {
                        $event.preventDefault();
                    }
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    let regExp = /^1{1}([3|4|5|6|7|8|9]{1}\d{0,9}){0,1}$/;
                    if (newVal && !regExp.test(newVal)) {
                        console.debug('%o ä¸æ˜¯æœ‰æ•ˆçš„æ‰‹æœºå·ç , è¿˜åŸåˆ°ä¸Šæ¬¡æœ‰æ•ˆå€¼ %o', newVal, oldVal);
                        //
                        // let bytes = newVal.split('');
                        // let validVal;
                        //
                        // while (bytes.length > 0) {
                        //     bytes.pop();
                        //     validVal = bytes.join('');
                        //     if (regExp.test(validVal)) {
                        //         break;
                        //     }
                        // }

                        __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, oldVal);
                    }
                });
            } else {
                console.warn('%o v-dsp-input-mobileè¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-mobile="vm.your.property"', input);
            }
        }
    },

    //åªå…è®¸è¾“å…¥æ•°å­—å’Œå­—æ¯
    code: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');
            el.onkeydown = function ($event) {
                let keyCode = $event.keyCode;
                if (keyCode === 8 || keyCode === 9 || keyCode === 46 || keyCode === 37 || keyCode === 39 || keyCode === 17 || keyCode === 86) {
                    //é€€æ ¼ã€Tabé”®ã€åˆ é™¤ã€æ–¹å‘ã€Control+Vé”®
                } else {
                    //åªå…è®¸è¾“å…¥å­—æ¯å’Œæ•°å­—
                    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105 || keyCode >= 65 && keyCode <= 90) {} else {
                        $event.preventDefault();
                    }
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    let regExp = /^[0-9a-zA-Z]*$/;
                    if (newVal && !regExp.test(newVal)) {
                        console.debug('%o ä¸æ˜¯æœ‰æ•ˆçš„ç¼–ç , è¿˜åŸåˆ°ä¸Šæ¬¡æœ‰æ•ˆå€¼ %o', newVal, oldVal);
                        __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, oldVal);
                    }
                });
            } else {
                console.warn('%o v-dsp-input-code è¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-code="vm.your.property"', input);
            }
        }
    },

    //ä¸å…è®¸ç©ºæ ¼
    trim: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');
            el.onkeydown = function ($event) {
                let key = $event.key;
                let keyCode = $event.keyCode;
                let val = input.value;
                if (keyCode === 32) {
                    $event.preventDefault();
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, newVal && newVal.trim() || oldVal);
                });
            } else {
                console.warn('%o v-dsp-input-trim è¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-trim="vm.your.property"', input);
            }
        }
    },

    //å­—æ®µæ ¡éªŒ
    validate: {
        // bind: function (el, binding, vnode) {
        //     console.debug('bind: %o', binding.expression);
        //     console.debug('æ·»åŠ æ ¡éªŒ: %o', binding.expression);
        // },
        inserted: function (el, binding, vnode) {
            console.debug('inserted æ·»åŠ æ ¡éªŒ: %o', binding.expression);
            bindFieldValidator(el, binding, vnode);
        },
        // update: function (el, binding, vnode) {
        //     console.debug('update: %o', binding.expression);
        // },
        // componentUpdated: function (el, binding, vnode, oldVnode) {
        //     console.debug('componentUpdated å˜æ›´æ ¡éªŒ: %o', binding.expression);
        //     bindFieldValidator(el, binding, vnode);
        // },
        unbind: function (el, binding, vnode) {
            console.debug('unbind å–æ¶ˆæ ¡éªŒ: %o', binding.expression);
            unbindFieldValidator(el, binding, vnode);
        }
    },

    //è¡¨å•æ ¡éªŒ
    validateForm: {
        bind: function (el, binding, vnode) {
            console.debug('form bind');

            // ç›‘å¬å™¨
            vnode.context.$data.$validator.watcher = {};
            // æ ¡éªŒå™¨
            vnode.context.$data.$validator.validator = {};
            // æ ¡éªŒé”™è¯¯
            vnode.context.$data.$validator.error = {};

            // å–æ¶ˆç›‘å¬
            vnode.context.$data.$validator.unwatch = function () {
                if (vnode.context.$data.$validator.watcher) {
                    for (let key in vnode.context.$data.$validator.watcher) {
                        vnode.context.$data.$validator.watcher[key]();
                        delete vnode.context.$data.$validator.watcher[key];
                    }
                }
            };
            // è¡¨å•æ ¡éªŒ
            vnode.context.$data.$validator.validateAll = function (group) {

                return Promise.resolve().then(() => {
                    let validator = vnode.context.$data.$validator.validator;
                    let promises = [];

                    for (let key of Object.keys(validator)) {
                        if (group) {
                            if (key.startsWith(group + '.')) {
                                //æŒ‰ç»„æ£€éªŒ
                                promises.push(validator[key]());
                            }
                        } else {
                            //é€ä¸ªéå†å¹¶æ ¡éªŒ
                            promises.push(validator[key]());
                        }
                    }

                    return Promise.all(promises);
                }).then(() => {
                    let error = vnode.context.$data.$validator.error;
                    return !error || Object.keys(error).length == 0;
                });
            };
            // é‡ç½®è¡¨å•æ ¡éªŒ
            vnode.context.$data.$validator.reset = function () {

                //æ¸…ç©ºé”™è¯¯æ¶ˆæ¯
                vnode.context.$data.$validator.error = {};

                el.querySelectorAll('.is-error').forEach(i => {
                    i.classList.remove('is-error');
                });

                el.querySelectorAll('.err-required').forEach(i => {
                    i.classList.remove('err-required');
                });

                el.querySelectorAll('.err-minlength').forEach(i => {
                    i.classList.remove('err-minlength');
                });

                el.querySelectorAll('.err-min').forEach(i => {
                    i.classList.remove('err-min');
                });

                el.querySelectorAll('.err-remote').forEach(i => {
                    i.classList.remove('err-remote');
                });

                el.querySelectorAll('.err-customize').forEach(i => {
                    i.classList.remove('err-customize');
                });
            };

            console.debug(vnode.context.$data.$validator);
        },
        unbind: function (el, binding, vnode) {
            console.debug('form unbind');

            vnode.context.$data.$validator.unwatch();
            vnode.context.$data.$validator.reset();

            delete vnode.context.$data.$validator.unwatch;
            delete vnode.context.$data.$validator.validateAll;
            delete vnode.context.$data.$validator.reset;

            delete vnode.context.$data.$validator.watcher;
            delete vnode.context.$data.$validator.validator;
            delete vnode.context.$data.$validator.error;

            console.debug(vnode.context.$data.$validator);
        }
    },

    //æŠ˜å é¢æ¿
    collapsable: {
        bind: function (el, binding, vnode) {
            let target = el.getAttribute('target');
            let collapsed = el.getAttribute('collapsed') == 'true';
            if (!el.classList.contains('dsp-panel-collapsable')) {
                el.classList.add('dsp-panel-collapsable');
            }
            if (collapsed && !el.classList.contains('collapsed')) {
                el.classList.add('collapsed');
            }
            el.addEventListener("click", function () {
                let targetDom = document.querySelector(target);
                if (targetDom) {
                    if (targetDom.classList.contains('dsp-panel-collapsed__content')) {
                        targetDom.classList.remove('dsp-panel-collapsed__content');
                        el.classList.remove('collapsed');
                    } else {
                        targetDom.classList.add('dsp-panel-collapsed__content');
                        el.classList.add('collapsed');
                    }
                } else {
                    console.debug('target not found: %o', target);
                }
            });
        }
    },

    //å›¾ç‰‡æ‹–æ‹½
    imgdrag: {
        bind: function (el, binding, vnode) {

            const dialogHeaderEl = el.querySelector('.dsp-img-header');
            const dragDom = el.querySelector('.dsp-img-preview');
            const sty = function () {
                if (window.document.currentStyle) {
                    return (dom, attr) => dom.currentStyle[attr];
                } else {
                    return (dom, attr) => getComputedStyle(dom, false)[attr];
                }
            }();
            dialogHeaderEl.onmousedown = e => {
                // é¼ æ ‡æŒ‰ä¸‹ï¼Œè®¡ç®—å½“å‰å…ƒç´ è·ç¦»å¯è§†åŒºçš„è·ç¦»
                const disX = e.clientX - dialogHeaderEl.offsetLeft;
                const disY = e.clientY - dialogHeaderEl.offsetTop;

                // bodyå½“å‰å®½åº¦
                const screenWidth = document.body.clientWidth;
                // å¯è§åŒºåŸŸé«˜åº¦(åº”ä¸ºbodyé«˜åº¦ï¼Œå¯æŸäº›ç¯å¢ƒä¸‹æ— æ³•è·å–)
                const screenHeight = document.documentElement.clientHeight;

                // å®½åº¦
                const dragDomWidth = dragDom.offsetWidth;
                // é«˜åº¦
                const dragDomheight = dragDom.offsetHeight;

                const minDragDomLeft = dragDom.offsetLeft;
                const maxDragDomLeft = screenWidth - dragDom.offsetLeft - dragDomWidth;

                const minDragDomTop = dragDom.offsetTop;
                const maxDragDomTop = screenHeight - dragDom.offsetTop - dragDomheight;

                // è·å–åˆ°çš„å€¼å¸¦px æ­£åˆ™åŒ¹é…æ›¿æ¢
                let styL = sty(dragDom, 'left');
                let styT = sty(dragDom, 'top');

                if (styL.includes('%')) {
                    styL = +document.body.clientWidth * (+styL.replace(/%/g, '') / 100);
                    styT = +document.body.clientHeight * (+styT.replace(/%/g, '') / 100);
                } else {
                    styL = +styL.replace(/px/g, '');
                    styT = +styT.replace(/px/g, '');
                }
                document.onmousemove = function (e) {
                    // é€šè¿‡äº‹ä»¶å§”æ‰˜ï¼Œè®¡ç®—ç§»åŠ¨çš„è·ç¦»
                    let left = e.clientX - disX;
                    let top = e.clientY - disY;
                    // è¾¹ç•Œå¤„ç†
                    if (-left > minDragDomLeft) {
                        left = -minDragDomLeft;
                    } else if (left > maxDragDomLeft) {
                        left = maxDragDomLeft;
                    }
                    if (-top > minDragDomTop) {
                        top = -minDragDomTop;
                    } else if (top > maxDragDomTop) {
                        top = maxDragDomTop;
                    }
                    // ç§»åŠ¨å½“å‰å…ƒç´ 
                    dragDom.style.cssText += `;left:${left + styL}px;top:${top + styT}px;`;
                };
                document.onmouseup = function (e) {
                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            };
        }
    },

    //å…è®¸è¾“å…¥0-100çš„æ•´æ•°æˆ–è€…å°æ•°ï¼Œå°æ•°ç‚¹åä¿ç•™4ä½,ç”¨äºæœåŠ¡è´¹è¿”æ¬¾è´¹ç‡çš„è¾“å…¥æ¡†
    percentRate: {
        bind: function (el, binding, vnode) {
            let input = el.tagName === 'INPUT' ? el : el.querySelector('input');

            el.onkeydown = function ($event) {
                let keyCode = $event.keyCode;
                let val = input.value;
                if (keyCode === 8 || keyCode === 9 || keyCode === 46 || keyCode === 37 || keyCode === 39 || keyCode === 17 || keyCode === 86) {
                    //é€€æ ¼ã€Tabé”®ã€åˆ é™¤ã€æ–¹å‘ã€Control+Vé”®

                } else {
                    //å¯è¾“å…¥æ•´æ•°æˆ–å°æ•°ï¼ˆç²¾ç¡®åˆ°å°æ•°ç‚¹åä¸¤ä½ï¼‰
                    if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105 || keyCode === 110 || keyCode === 190) {

                        if (val === '' && (keyCode === 110 || keyCode === 190)) {
                            //ä¸å…è®¸ç›´æ¥è¾“å…¥å°æ•°ç‚¹
                            $event.preventDefault();
                        }

                        /*if (val === '0' && (keyCode !== 110 && keyCode !== 190)) {
                         //é¦–ä½æ•°å­—ä¸º0ï¼Œåªå…è®¸è¾“å…¥å°æ•°ç‚¹
                         $event.preventDefault();
                         }*/

                        if (val.indexOf('.') !== -1 && (keyCode === 110 || keyCode === 190)) {
                            //å·²ç»æœ‰å°æ•°ç‚¹ï¼Œä¸å…è®¸å†æ¬¡è¾“å…¥å°æ•°ç‚¹
                            $event.preventDefault();
                        }

                        if (val.indexOf('.') !== -1 && val.substring(val.indexOf('.') + 1).length >= 4) {
                            //ç²¾ç¡®åˆ°å°æ•°ç‚¹åä¸¤ä½
                            $event.preventDefault();
                        }
                    } else {
                        $event.preventDefault();
                    }
                }
            };

            let prop = binding.expression;
            if (prop) {
                vnode.context.$watch(prop, function (newVal, oldVal) {
                    let regExp = /^(\d|[1-9]\d|100)(\.\d{0,4})?$/;
                    if (newVal && !regExp.test(newVal)) {
                        console.debug('%o ä¸æ˜¯æœ‰æ•ˆçš„æ•°å€¼, è¿˜åŸåˆ°ä¸Šæ¬¡æœ‰æ•ˆå€¼ %o', newVal, oldVal);
                        //
                        // let bytes = newVal.split('');
                        // let validVal;
                        //
                        // while (bytes.length > 0) {
                        //     bytes.pop();
                        //     validVal = bytes.join('');
                        //     if (regExp.test(validVal)) {
                        //         break;
                        //     }
                        // }

                        __WEBPACK_IMPORTED_MODULE_0__utils__["default"].setProp(vnode.context, '$data.' + prop, oldVal);
                    }
                });
            } else {
                console.warn('%o v-dsp-input-number è¾“å…¥æ¡†æœªæŒ‡å®šç›‘å¬å±æ€§ï¼Œæ— æ³•é¿å…ä¸­æ–‡è¾“å…¥æ³•æˆ–é¼ æ ‡äº‹ä»¶å¼•èµ·çš„è¾“å…¥é”™è¯¯ï¼Œæ­£ç¡®ç”¨æ³•ï¼šv-dsp-input-number="vm.your.property"', input);
            }
        }
    }
});

/***/ }),

/***/ 33:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* jshint esversion: 6 */

__webpack_require__(34)();

//æ±‰å­—çš„æ•°å­—
const cnNums = new Array('é›¶', 'å£¹', 'è´°', 'å', 'è‚†', 'ä¼', 'é™†', 'æŸ’', 'æŒ', 'ç–');
//åŸºæœ¬å•ä½
const cnIntRadice = new Array('', 'æ‹¾', 'ä½°', 'ä»Ÿ');
//å¯¹åº”æ•´æ•°éƒ¨åˆ†æ‰©å±•å•ä½
const cnIntUnits = new Array('', 'ä¸‡', 'äº¿', 'å…†');
//å¯¹åº”å°æ•°éƒ¨åˆ†å•ä½
const cnDecUnits = new Array('è§’', 'åˆ†', 'æ¯«', 'å˜');
//æ•´æ•°é‡‘é¢æ—¶åé¢è·Ÿçš„å­—ç¬¦
const cnInteger = 'æ•´';
//æ•´å‹å®Œä»¥åçš„å•ä½
const cnIntLast = 'å…ƒ';
//æœ€å¤§å¤„ç†çš„æ•°å­—
const maxNum = 999999999999999.9999;

/* harmony default export */ __webpack_exports__["default"] = ({

    //å°å†™å˜å¤§å†™
    capitalize: function (value) {
        if (!value) return '';
        value = value.toString();
        return value.toUpperCase();
    },

    //é‡‘é¢
    amount: function (value) {
        if (!value && value != 0) return value;
        let old = value;
        value = parseFloat(value).toFixed(2);
        value = value.replace('.00', '');
        if (isNaN(value)) {
            return old;
        }
        // return 'ï¿¥' + value;
        return value;
    },

    //é¢ç§¯
    area: function (value) {
        if (!value && value != 0) return '';
        value = parseFloat(value).toFixed(4);
        value = value.replace('.0000', '');
        // return value + ' ã¡';
        return value;
    },

    //æ¯”ç‡
    rate: function (value) {
        if (!value && value != 0) return '';
        value = parseFloat(value).toFixed(2);
        value = value.replace('.00', '');
        return value + '%';
    },

    //å–æ•´
    integer: function (value) {
        if (!value) return '';
        return Math.round(value);
    },

    //ä¿ç•™ä¸¤ä½å°æ•°
    float: function (value) {
        if (!value) return '';
        return parseFloat(value).toFixed(2);
    },

    //æ—¥æœŸ
    date: function (value) {
        if (!value) return '';
        if (typeof value == 'number') {
            return new Date(parseInt(value)).format('yyyy-MM-dd');
        } else if (typeof value == 'string' && !isNaN(value)) {
            return new Date(parseInt(value)).format('yyyy-MM-dd');
        } else if (typeof value == 'string' && value.indexOf('-') != -1) {
            return value.substr(0, 10);
        } else {
            return value;
        }
    },

    //æ—¥æœŸæ—¶é—´
    time: function (value) {
        if (!value) return '';
        if (typeof value == 'number') {
            return new Date(parseInt(value)).format('hh:mm');
        } else if (typeof value == 'string' && !isNaN(value)) {
            return new Date(parseInt(value)).format('hh:mm');
        } else {
            return value;
        }
    },

    //æ—¥æœŸæ—¶é—´
    datetime: function (value) {
        if (!value) return '';
        if (typeof value == 'number') {
            return new Date(parseInt(value)).format('yyyy-MM-dd hh:mm');
        } else if (typeof value == 'string' && !isNaN(value)) {
            return new Date(parseInt(value)).format('yyyy-MM-dd hh:mm');
        } else {
            return value;
        }
    },
    //ç§’çº§
    datetimes: function (value) {
        if (!value) return '';
        if (typeof value == 'number') {
            return new Date(parseInt(value)).format('yyyy-MM-dd hh:mm:ss');
        } else if (typeof value == 'string' && !isNaN(value)) {
            return new Date(parseInt(value)).format('yyyy-MM-dd hh:mm:ss');
        } else {
            return value;
        }
    },
    // 61ç§’ï¼Œæ˜¾ç¤ºæˆ1åˆ†1ç§’ï¼› 3800ç§’ï¼Œ æ˜¾ç¤ºæˆ1æ—¶3åˆ†20ç§’
    formatseconds: function (value) {
        var theTime = parseInt(value); // ç§’
        var middle = 0; // åˆ†
        var hour = 0; // å°æ—¶

        if (theTime > 60) {
            middle = parseInt(theTime / 60);
            theTime = parseInt(theTime % 60);
            if (middle > 60) {
                hour = parseInt(middle / 60);
                middle = parseInt(middle % 60);
            }
        }
        var result = "" + parseInt(theTime) + "ç§’";
        if (middle > 0) {
            result = "" + parseInt(middle) + "åˆ†" + result;
        }
        if (hour > 0) {
            result = "" + parseInt(hour) + "æ—¶" + result;
        }
        return result;
    },
    //è¿‡æ»¤å™¨
    filter: function (list, keyword, props) {
        if (!list || !list.length || !keyword) return list;

        return list.filter(item => {
            if (props && props.length) {
                return props.map(function (prop) {
                    return prop && item[prop] && item[prop].toLowerCase().indexOf(keyword.toLowerCase()) != -1;
                }).find(result => result);
            } else {
                return typeof item == 'string' ? item.toLowerCase().indexOf(keyword.toLowerCase()) != -1 : true;
            }
        });
    },

    //å…¼å®¹è€ç³»ç»Ÿäº§ç”Ÿçš„ç»å¯¹è·¯å¾„è·¯ç”±
    url: function (value) {
        if (!value) return '';
        if (value.startsWith("http")) {
            return value;
        } else {
            return DSP.globalConfig.fileBaseUrl + value;
        }
    },

    //ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š
    convertCurrency(money) {
        //é‡‘é¢æ•´æ•°éƒ¨åˆ†
        let integerNum;
        //é‡‘é¢å°æ•°éƒ¨åˆ†
        let decimalNum;
        //è¾“å‡ºçš„ä¸­æ–‡é‡‘é¢å­—ç¬¦ä¸²
        let chineseStr = '';
        //åˆ†ç¦»é‡‘é¢åç”¨çš„æ•°ç»„ï¼Œé¢„å®šä¹‰
        let parts;
        if (money == '') {
            return '';
        }
        money = parseFloat(money);
        if (money >= maxNum) {
            //è¶…å‡ºæœ€å¤§å¤„ç†æ•°å­—
            return '';
        }
        if (money == 0) {
            chineseStr = cnNums[0] + cnIntLast + cnInteger;
            return chineseStr;
        }
        //è½¬æ¢ä¸ºå­—ç¬¦ä¸²
        money = money.toString();
        if (money.indexOf('.') == -1) {
            integerNum = money;
            decimalNum = '';
        } else {
            parts = money.split('.');
            integerNum = parts[0];
            decimalNum = parts[1].substr(0, 4);
        }
        //è·å–æ•´å‹éƒ¨åˆ†è½¬æ¢
        if (parseInt(integerNum, 10) > 0) {
            let zeroCount = 0;
            let IntLen = integerNum.length;
            for (let i = 0; i < IntLen; i++) {
                let n = integerNum.substr(i, 1);
                let p = IntLen - i - 1;
                let q = p / 4;
                let m = p % 4;
                if (n == '0') {
                    zeroCount++;
                } else {
                    if (zeroCount > 0) {
                        chineseStr += cnNums[0];
                    }
                    //å½’é›¶
                    zeroCount = 0;
                    chineseStr += cnNums[parseInt(n)] + cnIntRadice[m];
                }
                if (m == 0 && zeroCount < 4) {
                    chineseStr += cnIntUnits[q];
                }
            }
            chineseStr += cnIntLast;
        }
        //å°æ•°éƒ¨åˆ†
        if (decimalNum != '') {
            let decLen = decimalNum.length;
            for (let i = 0; i < decLen; i++) {
                let n = decimalNum.substr(i, 1);
                if (n != '0') {
                    chineseStr += cnNums[Number(n)] + cnDecUnits[i];
                }
            }
        }
        if (chineseStr == '') {
            chineseStr += cnNums[0] + cnIntLast + cnInteger;
        } else if (decimalNum == '') {
            chineseStr += cnInteger;
        }
        return chineseStr;
    }

});

/***/ }),

/***/ 34:
/***/ (function(module, exports) {

module.exports = function () {
    /**
     * å¾®ä¿¡æµè§ˆå™¨ä¸æ”¯æŒçš„æ–¹æ³•
     */
    if (typeof String.prototype.startsWith != 'function') {
        String.prototype.startsWith = function (prefix) {
            return this.slice(0, prefix.length) === prefix;
        };
    }
    if (typeof String.prototype.endsWith != 'function') {
        String.prototype.endsWith = function (suffix) {
            return this.indexOf(suffix, this.length - suffix.length) !== -1;
        };
    }
    if (typeof Array.prototype.find != 'function') {
        Array.prototype.find = function (callback) {
            var found;

            this.forEach(function (item, i) {
                if (callback(item, i)) {
                    found = item;
                }
            });

            return found;
        };
    }
    if (typeof Array.prototype.remove != 'function') {
        Array.prototype.remove = function (callback) {
            var index = -1;

            this.forEach(function (item, i) {
                if (callback(item, i)) {
                    index = i;
                }
            });

            if (index != -1) {
                this.splice(index, 1);
            }
        };
    }
    if (typeof Array.prototype.filter != 'function') {
        Array.prototype.filter = function (callback) {
            var results = [];

            this.forEach(function (item, i) {
                if (callback(item, i)) {
                    results.push(item);
                }
            });

            return results;
        };
    }
    if (typeof Array.prototype.map != 'function') {
        Array.prototype.map = function (callback) {
            var results = [];

            this.forEach(function (item, i) {
                results.push(callback(item, i));
            });

            return results;
        };
    }

    Date.prototype.format = function (fmt) {
        var o = {
            "M+": this.getMonth() + 1, //æœˆä»½
            "d+": this.getDate(), //æ—¥
            "h+": this.getHours(), //å°æ—¶
            "m+": this.getMinutes(), //åˆ†
            "s+": this.getSeconds(), //ç§’
            "q+": Math.floor((this.getMonth() + 3) / 3), //å­£åº¦
            "S": this.getMilliseconds() //æ¯«ç§’
        };
        if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
        for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
        return fmt;
    };

    Number.prototype.toFixed = function (n) {
        if (n > 20 || n < 0) {
            throw new RangeError('tofixed()æ•°å­—å‚æ•°å¿…é¡»æ˜¯0å’Œ20ä¹‹é—´');
        }
        const number = this;
        if (isNaN(number) || number >= Math.pow(10, 21)) {
            return number.toString();
        }
        if (typeof n == 'undefined' || n == 0) {
            return Math.round(number).toString();
        }

        let result = number.toString();
        const arr = result.split('.');

        // æ•´æ•°çš„æƒ…å†µ
        if (arr.length < 2) {
            result += '.';
            for (let i = 0; i < n; i += 1) {
                result += '0';
            }
            return result;
        }

        const integer = arr[0];
        const decimal = arr[1];
        if (decimal.length == n) {
            return result;
        }
        if (decimal.length < n) {
            for (let i = 0; i < n - decimal.length; i += 1) {
                result += '0';
            }
            return result;
        }
        result = integer + '.' + decimal.substr(0, n);
        const last = decimal.substr(n, 1);

        // å››èˆäº”å…¥ï¼Œè½¬æ¢ä¸ºæ•´æ•°å†å¤„ç†ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦çš„æŸå¤±
        if (parseInt(last, 10) >= 5) {
            const x = Math.pow(10, n);
            result = (Math.round(parseFloat(result) * x) + 1) / x;
            result = result.toFixed(n);
        }

        return result;
    };
};

/***/ }),

/***/ 35:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_base64___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_js_base64__);
/* jshint esversion: 6 */



/* harmony default export */ __webpack_exports__["default"] = ({
    // ä¸šåŠ¡å­—å…¸ç¿»è¯‘
    $translate: function (dict, value) {
        if (!dict || !dict.length || !value) {
            return value;
        }

        let match = null;
        dict.forEach(d => {
            if (d.value == value) {
                match = d;
            } else if (d.children && d.children.length) {
                d.children.forEach(c => {
                    if (c.value == value) {
                        match = c;
                    } else if (c.children && c.children.length) {
                        c.children.forEach(i => {
                            if (i.value == value) {
                                match = i;
                            }
                        });
                    }
                });
            }
        });

        return match && match.label || value;
    },
    $sceneInfo(s) {
        var scene = [];
        s = s * 1;
        switch (s) {
            case 1001:
                scene.push(s, 'å‘ç°æ å°ç¨‹åºä¸»å…¥å£');
                break;
            case 1005:
                scene.push(s, 'é¡¶éƒ¨æœç´¢æ¡†çš„æœç´¢ç»“æœé¡µ');
                break;
            case 1006:
                scene.push(s, 'å‘ç°æ å°ç¨‹åºä¸»å…¥å£æœç´¢æ¡†çš„æœç´¢ç»“æœé¡µ');
                break;
            case 1007:
                scene.push(s, 'å•äººèŠå¤©ä¼šè¯ä¸­çš„å°ç¨‹åºæ¶ˆæ¯å¡ç‰‡');
                break;
            case 1008:
                scene.push(s, 'ç¾¤èŠä¼šè¯ä¸­çš„å°ç¨‹åºæ¶ˆæ¯å¡ç‰‡');
                break;
            case 1011:
                scene.push(s, 'æ‰«æäºŒç»´ç ');
                break;
            case 1012:
                scene.push(s, 'é•¿æŒ‰å›¾ç‰‡è¯†åˆ«äºŒç»´ç ');
                break;
            case 1014:
                scene.push(s, 'æ‰‹æœºç›¸å†Œé€‰å–äºŒç»´ç ');
                break;
            case 1017:
                scene.push(s, 'å‰å¾€ä½“éªŒç‰ˆçš„å…¥å£é¡µ');
                break;
            case 1019:
                scene.push(s, 'å¾®ä¿¡é’±åŒ…');
                break;
            case 1020:
                scene.push(s, 'å…¬ä¼—å·profileé¡µç›¸å…³å°ç¨‹åºåˆ—è¡¨');
                break;
            case 1022:
                scene.push(s, 'èŠå¤©é¡¶éƒ¨ç½®é¡¶å°ç¨‹åºå…¥å£');
                break;
            case 1023:
                scene.push(s, 'å®‰å“ç³»ç»Ÿæ¡Œé¢å›¾æ ‡');
                break;
            case 1024:
                scene.push(s, 'å°ç¨‹åºprofileé¡µ');
                break;
            case 1025:
                scene.push(s, 'æ‰«æä¸€ç»´ç ');
                break;
            case 1026:
                scene.push(s, 'é™„è¿‘å°ç¨‹åºåˆ—è¡¨');
                break;
            case 1027:
                scene.push(s, 'é¡¶éƒ¨æœç´¢æ¡†æœç´¢ç»“æœé¡µâ€œä½¿ç”¨è¿‡çš„å°ç¨‹åºâ€åˆ—è¡¨');
                break;
            case 1028:
                scene.push(s, 'æˆ‘çš„å¡åŒ…');
                break;
            case 1029:
                scene.push(s, 'å¡åˆ¸è¯¦æƒ…é¡µ');
                break;
            case 1031:
                scene.push(s, 'é•¿æŒ‰å›¾ç‰‡è¯†åˆ«ä¸€ç»´ç ');
                break;
            case 1032:
                scene.push(s, 'æ‰‹æœºç›¸å†Œé€‰å–ä¸€ç»´ç ');
                break;
            case 1034:
                scene.push(s, 'å¾®ä¿¡æ”¯ä»˜å®Œæˆé¡µ');
                break;
            case 1035:
                scene.push(s, 'å…¬ä¼—å·è‡ªå®šä¹‰èœå•');
                break;
            case 1036:
                scene.push(s, 'Appåˆ†äº«æ¶ˆæ¯å¡ç‰‡');
                break;
            case 1037:
                scene.push(s, 'å°ç¨‹åºæ‰“å¼€å°ç¨‹åº');
                break;
            case 1038:
                scene.push(s, 'ä»å¦ä¸€ä¸ªå°ç¨‹åºè¿”å›');
                break;
            case 1039:
                scene.push(s, 'æ‘‡ç”µè§†');
                break;
            case 1042:
                scene.push(s, 'æ·»åŠ å¥½å‹æœç´¢æ¡†çš„æœç´¢ç»“æœé¡µ');
                break;
            case 1044:
                scene.push(s, 'å¸¦shareTicketçš„å°ç¨‹åºæ¶ˆæ¯å¡ç‰‡');
                break;
            case 1047:
                scene.push(s, 'æ‰«æå°ç¨‹åºç ');
                break;
            case 1048:
                scene.push(s, 'é•¿æŒ‰å›¾ç‰‡è¯†åˆ«å°ç¨‹åºç ');
                break;
            case 1049:
                scene.push(s, 'æ‰‹æœºç›¸å†Œé€‰å–å°ç¨‹åºç ');
                break;
            case 1052:
                scene.push(s, 'å¡åˆ¸çš„é€‚ç”¨é—¨åº—åˆ—è¡¨');
                break;
            case 1053:
                scene.push(s, 'æœä¸€æœçš„ç»“æœé¡µ');
                break;
            case 1054:
                scene.push(s, 'é¡¶éƒ¨æœç´¢æ¡†å°ç¨‹åºå¿«æ·å…¥å£');
                break;
            case 1056:
                scene.push(s, 'éŸ³ä¹æ’­æ”¾å™¨èœå•');
                break;
            case 1058:
                scene.push(s, 'å…¬ä¼—å·æ–‡ç« ');
                break;
            case 1059:
                scene.push(s, 'ä½“éªŒç‰ˆå°ç¨‹åºç»‘å®šé‚€è¯·é¡µ');
                break;
            case 1064:
                scene.push(s, 'å¾®ä¿¡è¿WifiçŠ¶æ€æ ');
                break;
            case 1067:
                scene.push(s, 'å…¬ä¼—å·æ–‡ç« å¹¿å‘Š');
                break;
            case 1068:
                scene.push(s, 'é™„è¿‘å°ç¨‹åºåˆ—è¡¨å¹¿å‘Š');
                break;
            case 1072:
                scene.push(s, 'äºŒç»´ç æ”¶æ¬¾é¡µé¢');
                break;
            case 1073:
                scene.push(s, 'å®¢æœæ¶ˆæ¯åˆ—è¡¨ä¸‹å‘çš„å°ç¨‹åºæ¶ˆæ¯å¡ç‰‡');
                break;
            case 1074:
                scene.push(s, 'å…¬ä¼—å·ä¼šè¯ä¸‹å‘çš„å°ç¨‹åºæ¶ˆæ¯å¡ç‰‡');
                break;
            case 1089:
                scene.push(s, 'å¾®ä¿¡èŠå¤©ä¸»ç•Œé¢ä¸‹æ‹‰');
                break;
            case 1090:
                scene.push(s, 'é•¿æŒ‰å°ç¨‹åºå³ä¸Šè§’èœå•å”¤å‡ºæœ€è¿‘ä½¿ç”¨å†å²');
                break;
            case 1092:
                scene.push(s, 'åŸå¸‚æœåŠ¡å…¥å£');
                break;
            default:
                scene.push('æœªçŸ¥å…¥å£');
                break;
        }
        let str = scene[1] || scene[0];
        return str;
    },
    // åˆå¹¶ä¸¤ä¸ªå¯¹è±¡
    $merge: function (obj, src) {
        for (var key in src) {
            if (src.hasOwnProperty(key)) obj[key] = src[key];
        }
        return obj;
    },

    // è§£ææµè§ˆå™¨åœ°å€æ è¯·æ±‚å‚æ•°
    $parseQuery: function () {
        let query = {};
        let search = window.location.search;
        if (search.startsWith('?')) {
            search = search.substr(1, search.length);
            search = search.split('&');

            search.forEach(s => {
                let idx = s.indexOf('=');
                if (idx !== -1) {
                    let prop = s.substr(0, idx);
                    let val = s.substr(idx + 1, s.length);

                    if (query[prop]) {
                        let arr = [].concat(query[prop]).concat(val);
                        query[prop] = arr;
                    } else {
                        query[prop] = val;
                    }
                }
            });
        }

        return query;
    },

    // base64ç¼–ç 
    $base64Encode: function (obj) {
        if (obj == undefined || obj == null) {
            return '';
        }

        if (typeof obj == 'object') {
            return __WEBPACK_IMPORTED_MODULE_0_js_base64__["Base64"].encode(JSON.stringify(obj));
        } else if (typeof obj == 'string') {
            return __WEBPACK_IMPORTED_MODULE_0_js_base64__["Base64"].encode(JSON.stringify(obj));
        } else {
            throw new Error('Only string or object can be encoded');
        }
    },

    // base64è§£ç 
    $base64Decode: function (str) {
        if (!str) {
            return;
        }

        let decoded = __WEBPACK_IMPORTED_MODULE_0_js_base64__["Base64"].decode(str);
        try {
            return JSON.parse(decoded);
        } catch (err) {
            return decoded;
        }
    },

    $math: {
        /**
         * æ±‚å’Œ
         * æ•°ç»„æ±‚å’Œï¼Œsum([1,2,3]) = 6
         * å‚æ•°æ±‚å’Œï¼Œsum(1,2,3) = 6
         * @returns {number}
         */
        sum: function () {
            if (arguments.length == 0) {
                return 0;
            }

            let args = [];
            if (arguments.length == 1 && arguments[0] instanceof Array) {
                args = arguments[0];
            } else {
                args = arguments;
            }

            let sum = 0;
            for (var i = 0; i < args.length; i++) {
                if (typeof (args[i] == 'number')) {
                    sum += parseFloat(args[i]);
                } else if (typeof (args[i] == 'string') && !isNaN(args[i])) {
                    sum += parseFloat(args[i]);
                }
            }

            return sum;
        }
    },

    $history: {
        back: function () {
            if (document.referrer) {
                window.location.href = document.referrer;
            } else {
                window.history.back();
            }
        }
    },

    /**
     * æ˜¯å¦å…·å¤‡æŸé¡¹åŠŸèƒ½æƒé™
     * @param privilege ä¸šåŠ¡æƒé™å€¼
     * @returns {boolean} trueï¼šå…·å¤‡ï¼Œfalseï¼šä¸å…·å¤‡
     */
    $hasPrivilege: function (privilege) {
        if (!privilege) {
            return true;
        }

        if (!DSP || !DSP.user || !DSP.user.privileges) {
            return false;
        }

        return DSP.user.privileges.indexOf(privilege) != -1;
    },

    /**
     * æ˜¯å¦å…·å¤‡æŸé¡¹ä¸šåŠ¡æƒé™
     * @param type ä¸šåŠ¡æƒé™ç±»å‹
     * @param privilege ä¸šåŠ¡æƒé™å€¼
     * @returns {boolean} trueï¼šå…·å¤‡ï¼Œfalseï¼šä¸å…·å¤‡
     */
    $hasBizPrivilege: function (type, privilege) {
        if (!privilege) {
            return true;
        }

        if (!DSP || !DSP.user || !DSP.user.currPosition) {
            return false;
        }

        if (!DSP.user.currPosition.bizPrivileges || !DSP.user.currPosition.bizPrivileges[type]) {
            //å¦‚æœæœªé…ç½®ä¸šåŠ¡æƒé™ï¼Œåˆ™é»˜è®¤ä¸ºå…·æœ‰è¯¥æƒé™
            return true;
        }

        return DSP.user.currPosition.bizPrivileges[type].indexOf(privilege) != -1;
    },
    // æ ¹æ®å•ä½ç¡®å®šè®¡ç®—æ–¹å¼ï¼Œå¹¶è¿”å›é‡‘é¢
    $price: function (unit, product) {
        var { price, quantity, ratio, width, height } = product;
        var base = (price || 0) * (ratio || 0) * (quantity || 0);
        var area = ((width || 0) * 0.001 * (height || 0) * 0.001 || 0).toFixed(4);
        var obj = {
            num: 0,
            area: null
        };
        if (unit.indexOf('YG.') > -1) {
            obj.num = base;
        } else if (unit.indexOf('YM.') > -1) {
            obj.num = base * (height || 0) * 0.001;
        } else if (unit.indexOf('YP.') > -1) {
            obj.area = area;
            obj.num = base * area;
        }
        obj.num = obj.num.toFixed(2);
        obj.num = obj.num.replace('.00', '');
        return obj;
    },

    // å°†javaçš„LocalDateTimeæ—¶é—´æ ¼å¼å˜æˆæ—¶é—´æˆ³
    $localDateTimeNumber: function (el, type = 's') {
        el = new Date(`${el.year}-${el.monthValue}-${el.dayOfMonth} ${el.hour}:${el.minute}:${el.second}`.replace(/-/g, '/'));
        el = el.getTime();
        return el;
    }
});

/***/ }),

/***/ 36:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
     true
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.5.1";
    // if node.js and NOT React Native, we use Buffer
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        try {
            buffer = eval("require('buffer').Buffer");
        } catch (err) {
            buffer = undefined;
        }
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function (u) {
            return (u.constructor === buffer.constructor ? u : buffer.from(u))
                .toString('base64')
        }
        :  function (u) {
            return (u.constructor === buffer.constructor ? u : new  buffer(u))
                .toString('base64')
        }
        : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function(a) {
            return (a.constructor === buffer.constructor
                    ? a : buffer.from(a, 'base64')).toString();
        }
        : function(a) {
            return (a.constructor === buffer.constructor
                    ? a : new buffer(a, 'base64')).toString();
        }
        : function(a) { return btou(_atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        __buffer__: buffer
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){ return global.Base64 }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    // that's it!
    return {Base64: global.Base64}
}));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ }),

/***/ 37:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__directive__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__filter__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__method__ = __webpack_require__(35);
/* jshint esversion: 6 */

// import Vue from 'vue';




Vue.directive('dsp-input-code', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].code);
Vue.directive('dsp-input-integer', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].integer);
Vue.directive('dsp-input-mobile', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].mobile);
//åº§æœºç”µè¯å’Œç”µè¯
Vue.directive('dsp-input-telephone', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].telephone);
Vue.directive('dsp-input-number', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].number);
Vue.directive('dsp-input-discount', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].discount);
Vue.directive('dsp-input-captcha', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].captcha);
Vue.directive('dsp-input-trim', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].trim);
Vue.directive('dsp-input-rate', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].percentRate);

Vue.directive('dsp-validate', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].validate);
Vue.directive('dsp-form-validate', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].validateForm);
Vue.directive('dsp-panel-collapsable', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].collapsable);
Vue.directive('dsp-drapable', __WEBPACK_IMPORTED_MODULE_0__directive__["default"].imgdrag);

for (var prop in __WEBPACK_IMPORTED_MODULE_1__filter__["default"]) {
    Vue.filter(prop, __WEBPACK_IMPORTED_MODULE_1__filter__["default"][prop]);

    if (!Vue.prototype.$filter) {
        Vue.prototype.$filter = {};
    }
    Vue.prototype.$filter[prop] = __WEBPACK_IMPORTED_MODULE_1__filter__["default"][prop];
}

for (var $method in __WEBPACK_IMPORTED_MODULE_2__method__["default"]) {
    Vue.prototype[$method] = __WEBPACK_IMPORTED_MODULE_2__method__["default"][$method];
}

/* harmony default export */ __webpack_exports__["default"] = (Vue);

/***/ }),

/***/ 39:
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 4:
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 40:
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ 41:
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(45)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ 43:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__error__ = __webpack_require__(9);
/* jshint esversion: 6 */



/* harmony default export */ __webpack_exports__["default"] = ({
    //å…¨å±€é”™è¯¯æ¶ˆæ¯
    ERROR: __WEBPACK_IMPORTED_MODULE_0__error__["default"].SYSTEM_ERROR,
    NETWORK: __WEBPACK_IMPORTED_MODULE_0__error__["default"].NETWORK_ERROR,

    /**************************             æšä¸¾å€¼                  **************************/

    //å“ç‰Œåˆ«åç”¨äºæŒ‡æ´¾
    BRAND: [{ value: 'SOGAL', label: 'è¡£æŸœ' }, { value: 'SCHMIDT', label: 'æ©±æŸœ' }, { value: 'MILANA', label: 'æœ¨é—¨' }],
    // æˆ¿å±‹ç±»å‹
    CUST_HOUSE_TYPE: [{ value: 'MPF', label: 'æ¯›å¯æˆ¿' }, { value: 'JZF', label: 'ç²¾è£…æˆ¿' }, { value: 'LF', label: 'è€æˆ¿' }, { value: 'new', label: 'æ–°æˆ¿' }, { value: 'old', label: 'è€æˆ¿' }],
    //ç©ºé—´ç±»å‹
    SPACE_TYPE: [{ value: 'LIVING_ROOM', label: 'å®¢å…' }, { value: 'DINING_ROOM', label: 'é¤å…' }, { value: 'COOK_ROOM', label: 'å¨æˆ¿' }, { value: 'BALCONY', label: 'é˜³å°' }, { value: 'SCHOOL_ROOM', label: 'ä¹¦æˆ¿' }, { value: 'CLOAK_ROOM', label: 'è¡£å¸½é—´' }, { value: 'MASTER_ROOM', label: 'ä¸»äººæˆ¿' }, { value: 'OLD_ROOM', label: 'è€äººæˆ¿' }, { value: 'CHILDREN_ROOM', label: 'å„¿ç«¥æˆ¿' }, { value: 'MULTI_FUNCTION_ROOM', label: 'å¤šåŠŸèƒ½å®¤' }, { value: 'HOUSEHOLD', label: 'å…¥æˆ·' }, { value: 'EXTRA1', label: 'æ¬¡å§1' }, { value: 'EXTRA2', label: 'æ¬¡å§2' }, { value: 'WASHROOM', label: 'å«ç”Ÿé—´' }, { value: 'STUDY', label: 'ä¹¦æˆ¿' }, { value: 'MASTER', label: 'ä¸»å§' }, { value: 'BATHROOM', label: 'ä¸»å«' }, { value: 'RESTROOM', label: 'å…¬å«' }, { value: 'OTHER', label: 'å…¶å®ƒ' }],
    //åˆä½œæ–¹å¤‡æ¡ˆç±»å‹
    COOPERATOR_TYPE: [{ value: 'DESIGNER', label: 'åˆä½œè®¾è®¡å¸ˆ' }, { value: 'COMPANY', label: 'åˆä½œè£…é¥°å…¬å¸' }, { value: 'BRAND', label: 'å“ç‰Œè”ç›Ÿ' }, { value: 'DIFFERENT', label: 'å¼‚ä¸šè”ç›Ÿ' }, { value: 'SQCOOPERATOR', label: 'ç¤¾ç¾¤åˆä½œå¹³å°' }],
    DELIVERY_PART: [{ value: true, label: 'æ˜¯' }, { value: false, label: 'å¦' }],
    //ç»„ç»‡æœºæ„çš„ç±»å‹
    ORG_TYPE: [{ value: 'DEPT', label: 'éƒ¨é—¨' }, { value: 'STORE', label: 'ä¸“å–åº—' }, { value: 'P_SHOP', label: 'Påº—' }],
    //ç”¨æˆ·ç±»å‹
    USER_TYPE: [{ value: 'C', label: 'å®¢æˆ·' }, { value: 'E', label: 'å‘˜å·¥' }, { value: 'H', label: 'åˆä½œæ–¹' }],
    //æ€§åˆ«
    GENDER: [{ value: 'MALE', label: 'ç”·' }, { value: 'FEMALE', label: 'å¥³' }],
    //å®¡æ‰¹çŠ¶æ€
    APPROVAL_STATUS: [{ value: 'NEW', label: 'æ–°å»º' }, { value: 'APPROVING', label: 'å®¡æ‰¹ä¸­' }, { value: 'SENDBACK', label: 'å·²é€€å›' }, { value: 'CANCELLED', label: 'å·²å¦å†³' }, { value: 'PASSED', label: 'å·²å®Œæˆ' }],
    //å‘˜å·¥çŠ¶æ€
    EMPLOYEE_STATUS: [{ value: 'TRAIL', label: 'è¯•ç”¨' }, { value: 'TRAINEE', label: 'å®ä¹ ' }, { value: 'WAIT', label: 'å¾…å²—' }, { value: 'FORMAL', label: 'æ­£å¼' }, { value: 'RETIRED', label: 'é€€ä¼‘' }, { value: 'DIMISSION', label: 'ç¦»èŒ' }],
    //æ•°æ®æƒé™
    DATA_PRIVILEGE: [{ label: 'å…¨éƒ¨', value: 'ALL' }, { label: 'æœ¬äºº', value: 'I' }, { label: 'æœ¬äººåŠä¸‹å±', value: 'WE' }, { label: 'æœ¬éƒ¨é—¨', value: 'DEPARTMENT' }, { label: 'æœ¬éƒ¨é—¨åŠä¸‹çº§éƒ¨é—¨', value: 'WEDEPART' }],
    //èœå•å›¾æ ‡
    MENU_ICON: [{ value: 'icon-user-management', label: 'icon-user-management' }, { value: 'icon-cms', label: 'icon-cms' }, { value: 'icon-wechat', label: 'icon-wechat' }, { value: 'icon-channel', label: 'icon-channel' }, { value: 'icon-distributor', label: 'icon-distributor' }, { value: 'icon-audit', label: 'icon-audit' }, { value: 'icon-sales', label: 'icon-sales' }, { value: 'icon-home', label: 'icon-home' }, { value: 'icon-undue', label: 'icon-undue' }, { value: 'icon-pool', label: 'icon-pool' }, { value: 'icon-finance', label: 'icon-finance' }, { value: 'icon-pay', label: 'icon-pay' }, { value: 'icon-logistics', label: 'icon-logistics' }, { value: 'icon-install', label: 'icon-install' }, { value: 'icon-service', label: 'icon-service' }, { value: 'icon-setup', label: 'icon-setup' }, { value: 'icon-configure', label: 'icon-configure' }, { value: 'icon-user', label: 'icon-user' }, { value: 'icon-search', label: 'icon-search' }, { value: 'icon-focus', label: 'icon-focus' }, { value: 'icon-sun', label: 'icon-sun' }, { value: 'icon-moon', label: 'icon-moon' }, { value: 'el-icon-star-on', label: 'el-icon-star-on' }, { value: 'el-icon-date', label: 'el-icon-date' }, { value: 'el-icon-time', label: 'el-icon-time' }, { value: 'el-icon-goods', label: 'el-icon-goods' }, { value: 'el-icon-bell', label: 'el-icon-bell' }, { value: 'el-icon-service', label: 'el-icon-service' }, { value: 'el-icon-picture-outline', label: 'el-icon-picture-outline' }, { value: 'el-icon-location-outline', label: 'el-icon-location-outline' }],
    //æ—¶é—´å•ä½
    TIME_UNIT: [{ value: 'Y', label: 'å¹´' }, { value: 'M', label: 'æœˆ' }, { value: 'W', label: 'å‘¨' }, { value: 'D', label: 'æ—¥' }],
    COOPERATING_STATE: [{ value: 'RUNNING', label: 'åˆä½œä¸­' }, { value: 'STOPPED', label: 'åœæ­¢åˆä½œ' }],
    //å‘å¸ƒç»ˆç«¯
    FBZD: [{ value: 'WEB', label: 'DSPç½‘é¡µç«¯' }, { value: 'MINAPP', label: 'ç´¢å°ç§˜' }],
    //ç³»ç»Ÿè®¾ç½® - æ ‡ç­¾ç®¡ç† --ä½œç”¨åŸŸ
    TAGSCOPE: [{ value: 'CUSTOMER', label: 'å®¢æˆ·' }, { value: 'ORGANIZATION', label: 'ç»„ç»‡æœºæ„' }, { value: 'PLAN', label: 'è®¡åˆ’' }, { value: 'POSITION', label: 'èŒä½' }, { value: 'BUDGET', label: 'é¢„ç®—å•' }, { value: 'ORDER', label: 'è®¢å•' }, { value: 'SUPPLEMENT', label: 'å¢è¡¥å•' }, { value: 'SAMPLE', label: 'ä¸Šæ ·å•' }],
    ORG_SELF_TYPE: [{ value: 'C', label: 'åˆä½œåº—' }, { value: 'O', label: 'å¤–åŒ…åº—' }, { value: 'S', label: 'è‡ªè¥åº—' }],
    // èœå•ç®¡ç†ä½œç”¨åŸŸ
    MENU_SCOPE: [{ value: 'BI', label: 'æŠ¥è¡¨' }, { value: 'DSP', label: 'ä¸»è¥' }, { value: 'CONSOLE', label: 'ç®¡ç†' }, { value: 'INSTALL', label: 'å®‰è£…å°ç¨‹åº' }, { value: 'DELIVERY', label: 'ç‰©æµå¸æœºç«¯' }, { value: 'CRM', label: 'ç´¢å°ç§˜' }],

    // todo æ‚Ÿç©ºå¿«è£…ç¿»æ–°+ ç´¢è²äºšå®šåˆ¶+
    //     QRCODE("å°ç¨‹åºç "),          //æœ€æ—©çš„é‚£ç§åˆ†äº«æµ·æŠ¥çš„åˆ†äº«æ–¹å¼
    //     CARD("åˆ†äº«å¡"),
    //     CMSQRCODE("CMSäºŒç»´ç "),
    //     MY_CARD("æˆ‘çš„åç‰‡"),
    //     WECHAT_SERVICE_ACCOUNT("å¾®ä¿¡å…¬ä¼—å·"),
    //     POSTER_QRCODE("æµ·æŠ¥äºŒç»´ç ");
    shareMethod: [{ value: 'WECHAT_SERVICE_ACCOUNT', label: 'å¾®ä¿¡å…¬ä¼—å·' }, { value: 'QRCODE', label: 'æµ·æŠ¥å°ç¨‹åºç ' }, { value: 'POSTER_QRCODE', label: 'æµ·æŠ¥äºŒç»´ç ' }, { value: 'CARD', label: 'åˆ†äº«å¡' }, { value: 'CMSQRCODE', label: 'è‡ªå®šä¹‰äºŒç»´ç ' }, { value: 'MY_CARD', label: 'æ¨å¹¿å¤§ä½¿åç‰‡' }],
    // å®¢æˆ·ç§ç±»
    levels: [{ value: 'VISITOR', label: 'è®¿å®¢' }, { value: 'USER', label: 'ç”¨æˆ·' }],
    // ä¸“é¢˜ç±»åˆ«
    categories: [{ value: 'DESIGN', label: 'å…¨å±‹å®šåˆ¶', key: 'ç´¢è²äºšå®šåˆ¶+' }, { value: 'REFORM', label: 'å±€éƒ¨ç¿»æ–°', key: 'æ‚Ÿç©ºå¿«è£…ç¿»æ–°+' }],
    // æˆ¿å±‹æˆ·å‹
    FWHX: [{ value: 'YSYT', label: 'ä¸€å®¤ä¸€å…' }, { value: 'ESYT', label: 'äºŒå®¤ä¸€å…' }, { value: 'LSLT', label: 'ä¸¤å®¤ä¸¤å…' }, { value: 'SSYT', label: 'ä¸‰å®¤ä¸€å…' }, { value: 'SSLT', label: 'ä¸‰å®¤ä¸¤å…' }, { value: 'SISYT', label: 'å››å®¤ä¸€å…' }, { value: 'SISLT', label: 'å››å®¤ä¸¤å…' }, { value: 'FSSSLTYS', label: 'å¤å¼' }, { value: 'BS', label: 'åˆ«å¢…' }, { value: 'QT', label: 'å…¶ä»–' }],
    //å°ç¨‹åºå›¾æ ‡     valueå°ç¨‹åºå›¾æ ‡      labelç”µè„‘æ˜¾ç¤ºçš„å›¾æ ‡
    WX_ICON: [{ value: 'icon-consultation', label: 'icon-consultation' }, { value: 'icon-triangle', label: 'icon-triangle' }, { value: 'icon-gift', label: 'icon-gift' }, { value: 'icon-free', label: 'icon-free' }],
    //èµ„æ·±/ä¸“ä¸š/æ–°æ‰‹
    stylistGrade: [{ value: 'A_new', label: 'æ–°é”' }, { value: 'B_special', label: 'ä¸“ä¸š' }, { value: 'C_senior', label: 'èµ„æ·±' }],
    identityList: [{ value: 'mc', label: 'ä¸»æ¡ˆ' }, { value: 'ac', label: 'åŠ©ç†' }],
    //å…¬ä¼—å·ç”¨æˆ·å…³æ³¨çš„æ¸ é“æ¥æºï¼Œ
    gzhLaiyuan: [{ value: 'ADD_SCENE_SEARCH', label: 'å…¬ä¼—å·æœç´¢' }, { value: 'ADD_SCENE_ACCOUNT_MIGRATION', label: 'å…¬ä¼—å·è¿ç§»' }, { value: 'ADD_SCENE_PROFILE_CARD', label: 'åç‰‡åˆ†äº«' }, { value: 'ADD_SCENE_QR_CODE', label: 'æ‰«æäºŒç»´ç ' }, { value: 'ADD_SCENE_PROFILE_ LINK', label: 'å›¾æ–‡é¡µå†…åç§°ç‚¹å‡»' }, { value: 'ADD_SCENE_PROFILE_ITEM', label: 'å›¾æ–‡é¡µå³ä¸Šè§’èœå•' }, { value: 'ADD_SCENE_PAID', label: 'æ”¯ä»˜åå…³æ³¨' }, { value: 'ADD_SCENE_OTHERS', label: 'å…¶ä»–' }],

    //åˆ†äº«å¡æ‰‹æœºç«¯åˆ†äº«çš„æ˜¯é‚£ä¸ªé¡µé¢
    generalizePage: [{ value: 'SOGAL_INDEX', label: 'å…¨å±‹å®šåˆ¶ä¸»é¡µ' }, { value: 'WK_INDEX', label: 'å±€éƒ¨ç¿»æ–°ä¸»é¡µ' }, { value: 'SOGAL_LIST', label: 'å…¨å±‹å®šåˆ¶åˆ—è¡¨' }, { value: 'WK_LIST', label: 'å±€éƒ¨ç¿»æ–°åˆ—è¡¨' }, { value: 'USER_INFO', label: 'ä¸ªäººè¯¦æƒ…é¡µ' }, { value: 'WECHAT_DESIGN_C', label: 'è®¾è®¡é…·å®¶ä¹åˆ†äº«é¡µ' }, { value: 'ACT_ENTER_INDEX', label: 'æ´»åŠ¨æŠ¥åé¡µ' }],
    // éœ€æ±‚å“ç±»
    REQUIRECATEGORY: [{
        value: 'BEDROOM',
        label: 'è¡£æŸœ'
    }, {
        value: 'KITCHEN',
        label: 'æ©±æŸœ'
    }, {
        value: 'DOOR',
        label: 'æœ¨é—¨'
    }, {
        value: 'FLOOR',
        label: 'åœ°æ¿'
    }, {
        value: 'FURNITURE',
        label: 'å®¶å…·'
    }, {
        value: 'CURTAIN',
        label: 'çª—å¸˜'
    }, {
        value: 'ORNAMENTS',
        label: 'é¥°å“'
    }, {
        value: 'ELECTRIC_APPLIANCE',
        label: 'ç”µå™¨'
    }],

    //åˆ›è–ªåˆä¼™äººç­‰çº§
    PROMOTIONLEVEL: [{ value: 'LV0', label: 'é’é“œ' }, { value: 'LV1', label: 'ç™½é“¶' }, { value: 'LV2', label: 'é»„é‡‘' }],
    INEFFECTIVE_REASONS: [{ "label": "å·²è´­ä¹°ç«å“", "value": "BuyCompetingProducts", "sortOrder": 0 }, { "label": "å®¢æˆ·æ‰‹æœºå·é”™è¯¯", "value": "CustomerMobileError", "sortOrder": 0 }, { "label": "æ— è®¢è´­æ„å‘", "value": "NoOrderIntention", "sortOrder": 0 }, { "label": "äº§å“å·¥è‰ºä¸å¥½", "value": "PoorProductTechnology", "sortOrder": 0 }, { "label": "ä»·æ ¼è¿‡é«˜", "value": "Overpriced", "sortOrder": 0 }, { "label": "æœåŠ¡ä½“éªŒä¸å¥½", "value": "ServiceExperienceDifference", "sortOrder": 0 }, { "label": "è®¾è®¡ä¸æ»¡æ„", "value": "NotSatisfiedWithDesign", "sortOrder": 0 }, { "label": "è”ç³»ä¸åˆ°å®¢æˆ·", "value": "NoContactWithCustomers", "sortOrder": 0 }, { "label": "æ— å®¢æˆ·éœ€æ±‚çš„äº§å“é£æ ¼", "value": "NoCustomerStyle", "sortOrder": 0 }, { "label": "æ— æ•ˆå®¢æˆ·", "value": "InvalidCustomer", "sortOrder": 0 }],
    //æŠ¥åå®¢æˆ·çŠ¶æ€
    registerUserStage: [{ "label": "å¾…ç¡®è®¤", "value": "CONFIRM" }, { "label": "æµ‹é‡ä¸”åˆ°åº—", "value": "MEASURE_STORE" }, { "label": "æ— æ•ˆ", "value": "INVALID" }, { "label": "æˆäº¤", "value": "TRADED" }],
    //å°ç¨‹åºé¡µé¢é“¾æ¥å‚æ•°ç±»å‹

    /**************************             ä¸šåŠ¡å­—å…¸                  **************************/
    $dict: null,
    dict: function (type) {
        let self = this;
        if (!self.$dict) {
            let script = document.querySelector('script[type="text/json"][name="dict"]');
            let text = script && script.innerText || '{}';
            try {
                self.$dict = JSON.parse(text);
            } catch (e) {}
        }
        return type && self.$dict ? self.$dict[type] || [] : self.$dict || {};
    }
});

/***/ }),

/***/ 45:
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),

/***/ 47:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_cropperjs__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_cropperjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_cropperjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scripts_module_axios__ = __webpack_require__(10);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
    props: {
        // ä¼ å…¥çš„æ•°æ®å¯¹è±¡ï¼ˆå¿…å¡«ï¼‰
        value: Object,
        // å¤‡ç”¨çš„ï¼Œæš‚æ—¶ä¸ç”¨
        ul: String,
        // æŒ‡å®šå®½é«˜ï¼ˆå¿…å¡«ï¼‰
        width: String,
        height: String,
        // ä¸€ä¸ªé¡µé¢å¦‚æœä½¿ç”¨ä¸¤ä¸ªï¼Œç¬¬äºŒä¸ªtypeå€¼ä¼ å€¼ä¸ºposterï¼ˆé€‰å¡«ï¼‰
        type: String,
        // é»˜è®¤çš„å›¾ç‰‡åœ°å€
        defaultImg: String,
        maxsize: Number //MB
    },
    data() {
        return {
            // åŸºç¡€å›¾ç‰‡åœ°å€
            fileBaseUrl: DSP.globalConfig.fileBaseUrl,
            headerImage: "",
            picValue: "",
            cropper: "",
            croppable: false,
            panel: false,
            url: this.value && this.value.imageUrl,
            loading: false
        };
    },
    mounted() {
        let that = this;
        var val = that.value;
        var num = new Date().getTime();
        that.$forceUpdate();
        that.num = num;
        if (val && val.imageUrl) {
            that.headerImage = that.fileBaseUrl + val.imageUrl;
        }
        // ç°åœ¨å…¼å®¹ä¸€ä¸ªé¡µé¢åŒæ—¶å±•ç¤ºä¸¤ä¸ªæ­¤ç»„ä»¶ï¼Œ
        // ä½†æ˜¯å› ä¸ºcropperå¯¹è±¡çš„æ¸²æŸ“éœ€è¦æ ¹æ®imgå…ƒç´ çš„idæ¸²æŸ“ï¼Œ
        // ä½†æ˜¯id å¿…é¡»ç‹¬ä¸€æ— äºŒï¼Œå› æ­¤æ ¹æ®typeæ¥æ”¹å˜id todo ç°åœ¨ä»…ä»…æ”¯æŒä¸¤ä¸ª
        // that.type === 'poster' ? 'poster' : 'image';
        var eleId = ''; // æ ¹æ®type åˆ¤æ–­æ¸²æŸ“çš„id å€¼
        if (that.type) {
            eleId = that.type + '1';
        } else {
            eleId = 'change1';
        }
        var image = document.getElementById(eleId); // è·å–å…ƒç´ 
        var width = that.width.split('p')[0]; // è·å–æŒ‡å®šå®½
        var height = that.height.split('p')[0]; // è·å–æŒ‡å®šé«˜
        // åˆ›å»ºæŒ‡å®šCropperå¯¹è±¡
        that.cropper = new __WEBPACK_IMPORTED_MODULE_0_cropperjs___default.a(image, {
            aspectRatio: width / height, // é»˜è®¤æ¯”ä¾‹
            preview: '.previewImg', // é¢„è§ˆè§†å›¾
            guides: false, // è£å‰ªæ¡†çš„è™šçº¿(ä¹å®«æ ¼)
            autoCropArea: 1, // 0-1ä¹‹é—´çš„æ•°å€¼ï¼Œå®šä¹‰è‡ªåŠ¨å‰ªè£åŒºåŸŸçš„å¤§å°ï¼Œé»˜è®¤0.8
            dragMode: 'move', // æ˜¯å¦å…è®¸ç§»é™¤å½“å‰çš„å‰ªè£æ¡†ï¼Œå¹¶é€šè¿‡æ‹–åŠ¨æ¥æ–°å»ºä¸€ä¸ªå‰ªè£æ¡†åŒºåŸŸ
            movable: true, // æ˜¯å¦å…è®¸ç§»åŠ¨å›¾ç‰‡
            resizable: false, // æ˜¯å¦å…è®¸æ”¹å˜è£å‰ªæ¡†çš„å¤§å°
            cropBoxResizable: false,
            zoomable: true, // æ˜¯å¦å…è®¸ç¼©æ”¾å›¾ç‰‡å¤§å°
            mouseWheelZoom: false, // æ˜¯å¦å…è®¸é€šè¿‡é¼ æ ‡æ»šè½®æ¥ç¼©æ”¾å›¾ç‰‡
            touchDragZoom: false, // æ˜¯å¦å…è®¸é€šè¿‡è§¦æ‘¸ç§»åŠ¨æ¥ç¼©æ”¾å›¾ç‰‡
            rotatable: true, // æ˜¯å¦å…è®¸æ—‹è½¬å›¾ç‰‡
            viewMode: 2,
            background: false,
            ready: function () {
                that.croppable = true;
            },
            crop(event) {
                // console.log(event.detail.x);
            }
        });
    },
    methods: {
        imgurl(url) {
            if (url && url.indexOf('http:') > -1) {
                return url;
            } else {
                return DSP.globalConfig.fileBaseUrl + url;
            }
        },
        // ç¼©æ”¾
        scale(type) {
            var that = this;
            var num = type === -1 ? -0.1 : 0.1;
            that.cropper.zoom(num);
        },
        // æ—‹è½¬
        roteta(direction) {
            var that = this;
            var reg = direction === 'left' ? -90 : 90;
            that.cropper.rotate(reg);
        },
        // ç¡®å®šæˆªå–
        crop() {
            let that = this;
            var croppedCanvas;
            var roundedCanvas;
            if (!this.croppable) {
                return;
            }
            var width = that.width.split('p')[0];
            var height = that.height.split('p')[0];
            // ç”Ÿæˆè£åˆ‡åçš„å›¾ç‰‡ï¼ŒæŒ‡å®šå®½é«˜
            // croppedCanvas = this.cropper.getCroppedCanvas({
            // 	width: width * 2,
            // 	height: height * 2,
            // 	minWidth: width * 2,
            // 	minHeight: height * 2,
            // 	maxWidth: 4096,
            // 	maxHeight: 4096,
            // 	fillColor: '#fff',
            // 	imageSmoothingEnabled: false,
            // 	imageSmoothingQuality: 'high'
            // });
            croppedCanvas = this.cropper.getCroppedCanvas();
            roundedCanvas = this.getRoundedCanvas(croppedCanvas); // ç”Ÿæˆè£åˆ‡åçš„å›¾ç‰‡
            that.postImg(roundedCanvas);
        },
        // æˆªå–å›¾ç‰‡åˆ¶æˆcanvas
        getRoundedCanvas(sourceCanvas) {
            let that = this;
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            var width = sourceCanvas.width;
            var height = sourceCanvas.height;
            canvas.width = width;
            canvas.height = height;
            context.imageSmoothingEnabled = true;
            // context.translate(0.2, -0.2);
            // context.scale(0.2, 0.2);
            // context.drawImage(sourceCanvas, 0, 0, width * 5, height * 5);
            context.drawImage(sourceCanvas, 0, 0, width, height);
            // context.globalCompositeOperation = 'destination-in';
            return canvas;
        },
        getObjectURL(file) {
            var url = null;
            if (window.createObjectURL != undefined) {
                // basic
                url = window.createObjectURL(file);
            } else if (window.URL != undefined) {
                // mozilla(firefox)
                url = window.URL.createObjectURL(file);
            } else if (window.webkitURL != undefined) {
                // webkit or chrome
                url = window.webkitURL.createObjectURL(file);
            }
            return url;
        },
        // é€‰å–çš„å›¾ç‰‡æ›´æ”¹å
        change(e) {
            var that = this;
            let files = e.target.files || e.dataTransfer.files;
            if (!files.length) return;
            this.panel = true;
            this.picValue = files[0];
            this.url = this.getObjectURL(this.picValue);

            var width = that.width.split('p')[0];
            var height = that.height.split('p')[0];
            that.cropper.setAspectRatio(width / height);
            //æ¯æ¬¡æ›¿æ¢å›¾ç‰‡è¦é‡æ–°å¾—åˆ°æ–°çš„url
            if (this.cropper) {
                this.cropper.replace(this.url);
            }
            // å±•ç¤ºæˆªå–çš„ç•Œé¢
            this.panel = true;
        },
        // ç‚¹å‡»å–æ¶ˆæŒ‰é’®
        cancelCrop() {
            var that = this;
            that.panel = false;
            that.clearInputFile(); // æ¸…é™¤é€‰ä¸­çš„å›¾ç‰‡çš„value
        },
        // æ¸…é™¤é€‰ä¸­çš„å›¾ç‰‡çš„value,é˜²æ­¢åŒä¸€å›¾ç‰‡ä¸èƒ½åå¤æäº¤
        clearInputFile() {
            var that = this;
            var eleId = '';
            if (that.type) {
                eleId = that.type;
            } else {
                eleId = 'change';
            }
            var f = document.getElementById(eleId);
            if (f.value) {
                try {
                    f.value = ''; //for IE11, latest Chrome/Firefox/Opera...
                } catch (err) {}
                if (f.value) {
                    //for IE5 ~ IE10
                    var form = document.createElement('form'),
                        ref = f.nextSibling,
                        p = f.parentNode;
                    form.appendChild(f);
                    form.reset();
                    p.insertBefore(f, ref);
                }
            }
        },
        // æäº¤å›¾ç‰‡åˆ°åå°
        postImg(file) {
            var that = this;
            // file.toBlob() canvasè½¬æˆblob
            file.toBlob(blob => {
                // å°† blob å›¾ç‰‡è½¬æˆæ–‡ä»¶æ ¼å¼  var file = new File([file], name)
                var files = new File([blob], 'file.png');
                const formData = new FormData();
                formData.append('file', files);
                let sis = (files.size / 1024 / 1024).toFixed(2);
                console.log(sis);
                if (that.maxsize && that.maxsize < files.size / 1024 / 1024) {
                    let si = (files.size / 1024 / 1024).toFixed(2);
                    that.$message.error(`å‰ªåˆ‡åå›¾ç‰‡å¤§å°ä¸º${si}MBï¼Œä¸èƒ½å¤§äº${that.maxsize}MB`);
                    return;
                }
                that.loading = true;
                var url = '/api/file-service/file/wechat/admin/upload';
                var config = { headers: { "Content-Type": "multipart/form-data" } };
                __WEBPACK_IMPORTED_MODULE_1__scripts_module_axios__["default"].post(url, formData, config).then(res => {
                    if (res && res.success) {
                        var newValue = that.value && that.value.imageUrl ? JSON.parse(JSON.stringify(that.value)) : {};
                        if (that.value && that.value.id) {
                            newValue.id = that.value.id;
                        }
                        newValue.ext = res.data.fileExt;
                        newValue.imageMd5 = res.data.md5;
                        newValue.imageUrl = res.data.relativePath;
                        newValue.name = res.data.relativePath;
                        newValue.reduceUrl = res.data.ghostRelativePath;
                        newValue.size = files.size;
                        that.$emit('update:value', newValue); // æ›´æ–°æ•°æ®
                        that.$emit('update:defaultImg', res.data.relativePath); // æ›´æ–°å›¾ç‰‡åœ°å€
                        that.panel = false; // å…³é—­æˆªå–ç•Œé¢
                        that.clearInputFile(); // æ¸…é™¤é€‰ä¸­çš„å›¾ç‰‡çš„value
                    }
                    that.loading = false;
                }).catch(err => {
                    that.loading = false;
                    console.log(error);
                });
            }, 'image/jpeg');
        },
        // ç‚¹å‡»å›¾ç‰‡æˆ–ç©ºå®¹å™¨ï¼ŒæŒ‡å‘imgçš„ç‚¹å‡»äº‹ä»¶
        chioce() {
            let that = this;
            //that.type === 'poster' ? 'changeP' : 'change'
            var eleId = '';
            if (that.type) {
                eleId = that.type;
            } else {
                eleId = 'change';
            }
            var el = document.getElementById(eleId);
            el.click();
        }
    },
    watch: {
        'value'(val, oldVal) {
            var that = this;
            this.headerImage = this.fileBaseUrl + (val && val.imageUrl);
        }
    }
});

/***/ }),

/***/ 5:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);
var settle = __webpack_require__(18);
var buildURL = __webpack_require__(20);
var parseHeaders = __webpack_require__(21);
var isURLSameOrigin = __webpack_require__(22);
var createError = __webpack_require__(6);
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(23);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(24);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),

/***/ 50:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_7_3_vue_loader_lib_selector_type_script_index_0_dsp_cropper_vue__ = __webpack_require__(47);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_7_3_vue_loader_lib_template_compiler_index_id_data_v_3493686e_hasScoped_false_buble_transforms_node_modules_vue_loader_13_7_3_vue_loader_lib_selector_type_template_index_0_dsp_cropper_vue__ = __webpack_require__(55);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(52)
}
var normalizeComponent = __webpack_require__(39)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_13_7_3_vue_loader_lib_selector_type_script_index_0_dsp_cropper_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_13_7_3_vue_loader_lib_template_compiler_index_id_data_v_3493686e_hasScoped_false_buble_transforms_node_modules_vue_loader_13_7_3_vue_loader_lib_selector_type_template_index_0_dsp_cropper_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "modules/global/components/ui/dsp-cropper.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3493686e", Component.options)
  } else {
    hotAPI.reload("data-v-3493686e", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),

/***/ 52:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(53);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(41)("3641c26c", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../../node_modules/_css-loader@0.28.11@css-loader/index.js!../../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3493686e\",\"scoped\":false,\"hasInlineConfig\":false}!../../../../node_modules/_less-loader@4.1.0@less-loader/dist/cjs.js!../../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector.js?type=styles&index=0!./dsp-cropper.vue", function() {
     var newContent = require("!!../../../../node_modules/_css-loader@0.28.11@css-loader/index.js!../../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3493686e\",\"scoped\":false,\"hasInlineConfig\":false}!../../../../node_modules/_less-loader@4.1.0@less-loader/dist/cjs.js!../../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector.js?type=styles&index=0!./dsp-cropper.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ 53:
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(40)(false);
// imports


// module
exports.push([module.i, "/*@import \"../../global/styles/global\";*/\n.demo #button {\n  width: 80px;\n  height: 40px;\n  border: none;\n  border-radius: 5px;\n  background: white;\n}\n.demo .show {\n  /*width: 375px;*/\n  /*height: 210px;*/\n  overflow: hidden;\n  position: relative;\n  border: 1px solid #d5d5d5;\n}\n.demo .picture {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  background-position: center center;\n  background-repeat: no-repeat;\n  background-size: cover;\n  text-align: center;\n  line-height: 300px;\n  font-size: 40px;\n  color: #aeaeae;\n  background-color: #DDE1EA ;\n  cursor: pointer;\n  position: relative;\n}\n.demo .picture .icon-upload-box {\n  width: 68px;\n  height: 68px;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  border-radius: 50%;\n  background: #fff;\n  margin: auto;\n  text-align: center;\n  line-height: 68px;\n  color: #409EFF;\n}\n.demo .container {\n  z-index: 1000;\n  position: fixed;\n  padding-top: 60px;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.5);\n}\n.demo .wrap {\n  width: 500px;\n  height: 500px;\n  margin: 80px auto;\n}\n.demo #image {\n  max-width: 100%;\n}\n/*!\n * Cropper.js v1.0.0-rc\n * https://github.com/fengyuanchen/cropperjs\n *\n * Copyright (c) 2017 Fengyuan Chen\n * Released under the MIT license\n *\n * Date: 2017-03-25T12:02:21.062Z\n */\n.cropper-container {\n  font-size: 0;\n  line-height: 0;\n  position: relative;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  direction: ltr;\n  -ms-touch-action: none;\n  touch-action: none;\n}\n.cropper-container img {\n  /* Avoid margin top issue (Occur only when margin-top <= -height) */\n  display: block;\n  min-width: 0 !important;\n  max-width: none !important;\n  min-height: 0 !important;\n  max-height: none !important;\n  width: 100%;\n  height: 100%;\n  image-orientation: NaNdeg;\n}\n.cropper-wrap-box,\n.cropper-canvas,\n.cropper-drag-box,\n.cropper-crop-box,\n.cropper-modal {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.cropper-wrap-box {\n  overflow: hidden;\n}\n.cropper-drag-box {\n  opacity: 0;\n  background-color: #fff;\n}\n.cropper-modal {\n  opacity: .5;\n  background-color: #000;\n}\n.cropper-view-box {\n  display: block;\n  overflow: hidden;\n  width: 100%;\n  height: 100%;\n  outline: 1px solid #39f;\n  outline-color: rgba(51, 153, 255, 0.75);\n}\n.cropper-dashed {\n  position: absolute;\n  display: block;\n  opacity: .5;\n  border: 1px dashed #eee;\n}\n.cropper-dashed.dashed-h {\n  top: 33.33333%;\n  left: 0;\n  width: 100%;\n  height: 33.33333%;\n  border-top-width: 1px;\n  border-bottom-width: 1px;\n}\n.cropper-dashed.dashed-v {\n  top: 0;\n  left: 33.33333%;\n  width: 33.33333%;\n  height: 100%;\n  border-right-width: 1px;\n  border-left-width: 1px;\n}\n.cropper-center {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  display: block;\n  width: 0;\n  height: 0;\n  opacity: 0.75;\n}\n.cropper-center:before,\n.cropper-center:after {\n  position: absolute;\n  display: block;\n  content: ' ';\n  background-color: #eee;\n}\n.cropper-center:before {\n  top: 0;\n  left: -3px;\n  width: 7px;\n  height: 1px;\n}\n.cropper-center:after {\n  top: -3px;\n  left: 0;\n  width: 1px;\n  height: 7px;\n}\n.cropper-face,\n.cropper-line,\n.cropper-point {\n  position: absolute;\n  display: block;\n  width: 100%;\n  height: 100%;\n  opacity: .1;\n}\n.cropper-face {\n  top: 0;\n  left: 0;\n  background-color: #fff;\n}\n.cropper-line {\n  background-color: #39f;\n}\n.cropper-line.line-e {\n  top: 0;\n  right: -3px;\n  width: 5px;\n  cursor: e-resize;\n}\n.cropper-line.line-n {\n  top: -3px;\n  left: 0;\n  height: 5px;\n  cursor: n-resize;\n}\n.cropper-line.line-w {\n  top: 0;\n  left: -3px;\n  width: 5px;\n  cursor: w-resize;\n}\n.cropper-line.line-s {\n  bottom: -3px;\n  left: 0;\n  height: 5px;\n  cursor: s-resize;\n}\n.cropper-point {\n  width: 5px;\n  height: 5px;\n  opacity: .75;\n  background-color: #39f;\n}\n.cropper-point.point-e {\n  top: 50%;\n  right: -3px;\n  margin-top: -3px;\n  cursor: e-resize;\n}\n.cropper-point.point-n {\n  top: -3px;\n  left: 50%;\n  margin-left: -3px;\n  cursor: n-resize;\n}\n.cropper-point.point-w {\n  top: 50%;\n  left: -3px;\n  margin-top: -3px;\n  cursor: w-resize;\n}\n.cropper-point.point-s {\n  bottom: -3px;\n  left: 50%;\n  margin-left: -3px;\n  cursor: s-resize;\n}\n.cropper-point.point-ne {\n  top: -3px;\n  right: -3px;\n  cursor: ne-resize;\n}\n.cropper-point.point-nw {\n  top: -3px;\n  left: -3px;\n  cursor: nw-resize;\n}\n.cropper-point.point-sw {\n  bottom: -3px;\n  left: -3px;\n  cursor: sw-resize;\n}\n.cropper-point.point-se {\n  right: -3px;\n  bottom: -3px;\n  width: 20px;\n  height: 20px;\n  cursor: se-resize;\n  opacity: 1;\n}\n@media (min-width: 768px) {\n.cropper-point.point-se {\n    width: 15px;\n    height: 15px;\n}\n}\n@media (min-width: 992px) {\n.cropper-point.point-se {\n    width: 10px;\n    height: 10px;\n}\n}\n@media (min-width: 1200px) {\n.cropper-point.point-se {\n    width: 5px;\n    height: 5px;\n    opacity: 0.75;\n}\n}\n.cropper-point.point-se:before {\n  position: absolute;\n  right: -50%;\n  bottom: -50%;\n  display: block;\n  width: 200%;\n  height: 200%;\n  content: ' ';\n  opacity: 0;\n  background-color: #39f;\n}\n.cropper-invisible {\n  opacity: 0;\n}\n.cropper-bg {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAAA3NCSVQICAjb4U/gAAAABlBMVEXMzMz////TjRV2AAAACXBIWXMAAArrAAAK6wGCiw1aAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABFJREFUCJlj+M/AgBVhF/0PAH6/D/HkDxOGAAAAAElFTkSuQmCC');\n}\n.cropper-hide {\n  position: absolute;\n  display: block;\n  width: 0;\n  height: 0;\n}\n.cropper-hidden {\n  display: none !important;\n}\n.cropper-move {\n  cursor: move;\n}\n.cropper-crop {\n  cursor: crosshair;\n}\n.cropper-disabled .cropper-drag-box,\n.cropper-disabled .cropper-face,\n.cropper-disabled .cropper-line,\n.cropper-disabled .cropper-point {\n  cursor: not-allowed;\n}\n", ""]);

// exports


/***/ }),

/***/ 54:
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Cropper.js v1.5.6
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2019-10-04T04:33:48.372Z
 */

(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Cropper = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(source, true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
  var WINDOW = IS_BROWSER ? window : {};
  var IS_TOUCH_DEVICE = IS_BROWSER ? 'ontouchstart' in WINDOW.document.documentElement : false;
  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
  var NAMESPACE = 'cropper'; // Actions

  var ACTION_ALL = 'all';
  var ACTION_CROP = 'crop';
  var ACTION_MOVE = 'move';
  var ACTION_ZOOM = 'zoom';
  var ACTION_EAST = 'e';
  var ACTION_WEST = 'w';
  var ACTION_SOUTH = 's';
  var ACTION_NORTH = 'n';
  var ACTION_NORTH_EAST = 'ne';
  var ACTION_NORTH_WEST = 'nw';
  var ACTION_SOUTH_EAST = 'se';
  var ACTION_SOUTH_WEST = 'sw'; // Classes

  var CLASS_CROP = "".concat(NAMESPACE, "-crop");
  var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
  var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
  var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
  var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
  var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
  var CLASS_MOVE = "".concat(NAMESPACE, "-move"); // Data keys

  var DATA_ACTION = "".concat(NAMESPACE, "Action");
  var DATA_PREVIEW = "".concat(NAMESPACE, "Preview"); // Drag modes

  var DRAG_MODE_CROP = 'crop';
  var DRAG_MODE_MOVE = 'move';
  var DRAG_MODE_NONE = 'none'; // Events

  var EVENT_CROP = 'crop';
  var EVENT_CROP_END = 'cropend';
  var EVENT_CROP_MOVE = 'cropmove';
  var EVENT_CROP_START = 'cropstart';
  var EVENT_DBLCLICK = 'dblclick';
  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
  var EVENT_READY = 'ready';
  var EVENT_RESIZE = 'resize';
  var EVENT_WHEEL = 'wheel';
  var EVENT_ZOOM = 'zoom'; // Mime types

  var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps

  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
  var REGEXP_DATA_URL = /^data:/;
  var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
  var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc
  // Inspired by the default width and height of a canvas element.

  var MIN_CONTAINER_WIDTH = 200;
  var MIN_CONTAINER_HEIGHT = 100;

  var DEFAULTS = {
    // Define the view mode of the cropper
    viewMode: 0,
    // 0, 1, 2, 3
    // Define the dragging mode of the cropper
    dragMode: DRAG_MODE_CROP,
    // 'crop', 'move' or 'none'
    // Define the initial aspect ratio of the crop box
    initialAspectRatio: NaN,
    // Define the aspect ratio of the crop box
    aspectRatio: NaN,
    // An object with the previous cropping result data
    data: null,
    // A selector for adding extra containers to preview
    preview: '',
    // Re-render the cropper when resize the window
    responsive: true,
    // Restore the cropped area after resize the window
    restore: true,
    // Check if the current image is a cross-origin image
    checkCrossOrigin: true,
    // Check the current image's Exif Orientation information
    checkOrientation: true,
    // Show the black modal
    modal: true,
    // Show the dashed lines for guiding
    guides: true,
    // Show the center indicator for guiding
    center: true,
    // Show the white modal to highlight the crop box
    highlight: true,
    // Show the grid background
    background: true,
    // Enable to crop the image automatically when initialize
    autoCrop: true,
    // Define the percentage of automatic cropping area when initializes
    autoCropArea: 0.8,
    // Enable to move the image
    movable: true,
    // Enable to rotate the image
    rotatable: true,
    // Enable to scale the image
    scalable: true,
    // Enable to zoom the image
    zoomable: true,
    // Enable to zoom the image by dragging touch
    zoomOnTouch: true,
    // Enable to zoom the image by wheeling mouse
    zoomOnWheel: true,
    // Define zoom ratio when zoom the image by wheeling mouse
    wheelZoomRatio: 0.1,
    // Enable to move the crop box
    cropBoxMovable: true,
    // Enable to resize the crop box
    cropBoxResizable: true,
    // Toggle drag mode between "crop" and "move" when click twice on the cropper
    toggleDragModeOnDblclick: true,
    // Size limitation
    minCanvasWidth: 0,
    minCanvasHeight: 0,
    minCropBoxWidth: 0,
    minCropBoxHeight: 0,
    minContainerWidth: 200,
    minContainerHeight: 100,
    // Shortcuts of events
    ready: null,
    cropstart: null,
    cropmove: null,
    cropend: null,
    crop: null,
    zoom: null
  };

  var TEMPLATE = '<div class="cropper-container" touch-action="none">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-cropper-action="e"></span>' + '<span class="cropper-line line-n" data-cropper-action="n"></span>' + '<span class="cropper-line line-w" data-cropper-action="w"></span>' + '<span class="cropper-line line-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-e" data-cropper-action="e"></span>' + '<span class="cropper-point point-n" data-cropper-action="n"></span>' + '<span class="cropper-point point-w" data-cropper-action="w"></span>' + '<span class="cropper-point point-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-ne" data-cropper-action="ne"></span>' + '<span class="cropper-point point-nw" data-cropper-action="nw"></span>' + '<span class="cropper-point point-sw" data-cropper-action="sw"></span>' + '<span class="cropper-point point-se" data-cropper-action="se"></span>' + '</div>' + '</div>';

  /**
   * Check if the given value is not a number.
   */

  var isNaN = Number.isNaN || WINDOW.isNaN;
  /**
   * Check if the given value is a number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a number, else `false`.
   */

  function isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
  }
  /**
   * Check if the given value is a positive number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.
   */

  var isPositiveNumber = function isPositiveNumber(value) {
    return value > 0 && value < Infinity;
  };
  /**
   * Check if the given value is undefined.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
   */

  function isUndefined(value) {
    return typeof value === 'undefined';
  }
  /**
   * Check if the given value is an object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is an object, else `false`.
   */

  function isObject(value) {
    return _typeof(value) === 'object' && value !== null;
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * Check if the given value is a plain object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
   */

  function isPlainObject(value) {
    if (!isObject(value)) {
      return false;
    }

    try {
      var _constructor = value.constructor;
      var prototype = _constructor.prototype;
      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
    } catch (error) {
      return false;
    }
  }
  /**
   * Check if the given value is a function.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a function, else `false`.
   */

  function isFunction(value) {
    return typeof value === 'function';
  }
  var slice = Array.prototype.slice;
  /**
   * Convert array-like or iterable object to an array.
   * @param {*} value - The value to convert.
   * @returns {Array} Returns a new array.
   */

  function toArray(value) {
    return Array.from ? Array.from(value) : slice.call(value);
  }
  /**
   * Iterate the given data.
   * @param {*} data - The data to iterate.
   * @param {Function} callback - The process function for each element.
   * @returns {*} The original data.
   */

  function forEach(data, callback) {
    if (data && isFunction(callback)) {
      if (Array.isArray(data) || isNumber(data.length)
      /* array-like */
      ) {
          toArray(data).forEach(function (value, key) {
            callback.call(data, value, key, data);
          });
        } else if (isObject(data)) {
        Object.keys(data).forEach(function (key) {
          callback.call(data, data[key], key, data);
        });
      }
    }

    return data;
  }
  /**
   * Extend the given object.
   * @param {*} target - The target object to extend.
   * @param {*} args - The rest objects for merging to the target object.
   * @returns {Object} The extended object.
   */

  var assign = Object.assign || function assign(target) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (isObject(target) && args.length > 0) {
      args.forEach(function (arg) {
        if (isObject(arg)) {
          Object.keys(arg).forEach(function (key) {
            target[key] = arg[key];
          });
        }
      });
    }

    return target;
  };
  var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
  /**
   * Normalize decimal number.
   * Check out {@link http://0.30000000000000004.com/}
   * @param {number} value - The value to normalize.
   * @param {number} [times=100000000000] - The times for normalizing.
   * @returns {number} Returns the normalized number.
   */

  function normalizeDecimalNumber(value) {
    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;
    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
  }
  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
  /**
   * Apply styles to the given element.
   * @param {Element} element - The target element.
   * @param {Object} styles - The styles for applying.
   */

  function setStyle(element, styles) {
    var style = element.style;
    forEach(styles, function (value, property) {
      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
        value = "".concat(value, "px");
      }

      style[property] = value;
    });
  }
  /**
   * Check if the given element has a special class.
   * @param {Element} element - The element to check.
   * @param {string} value - The class to search.
   * @returns {boolean} Returns `true` if the special class was found.
   */

  function hasClass(element, value) {
    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
  }
  /**
   * Add classes to the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be added.
   */

  function addClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        addClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.add(value);
      return;
    }

    var className = element.className.trim();

    if (!className) {
      element.className = value;
    } else if (className.indexOf(value) < 0) {
      element.className = "".concat(className, " ").concat(value);
    }
  }
  /**
   * Remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be removed.
   */

  function removeClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        removeClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.remove(value);
      return;
    }

    if (element.className.indexOf(value) >= 0) {
      element.className = element.className.replace(value, '');
    }
  }
  /**
   * Add or remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be toggled.
   * @param {boolean} added - Add only.
   */

  function toggleClass(element, value, added) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        toggleClass(elem, value, added);
      });
      return;
    } // IE10-11 doesn't support the second parameter of `classList.toggle`


    if (added) {
      addClass(element, value);
    } else {
      removeClass(element, value);
    }
  }
  var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
  /**
   * Transform the given string from camelCase to kebab-case
   * @param {string} value - The value to transform.
   * @returns {string} The transformed value.
   */

  function toParamCase(value) {
    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();
  }
  /**
   * Get data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to get.
   * @returns {string} The data value.
   */

  function getData(element, name) {
    if (isObject(element[name])) {
      return element[name];
    }

    if (element.dataset) {
      return element.dataset[name];
    }

    return element.getAttribute("data-".concat(toParamCase(name)));
  }
  /**
   * Set data to the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to set.
   * @param {string} data - The data value.
   */

  function setData(element, name, data) {
    if (isObject(data)) {
      element[name] = data;
    } else if (element.dataset) {
      element.dataset[name] = data;
    } else {
      element.setAttribute("data-".concat(toParamCase(name)), data);
    }
  }
  /**
   * Remove data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to remove.
   */

  function removeData(element, name) {
    if (isObject(element[name])) {
      try {
        delete element[name];
      } catch (error) {
        element[name] = undefined;
      }
    } else if (element.dataset) {
      // #128 Safari not allows to delete dataset property
      try {
        delete element.dataset[name];
      } catch (error) {
        element.dataset[name] = undefined;
      }
    } else {
      element.removeAttribute("data-".concat(toParamCase(name)));
    }
  }
  var REGEXP_SPACES = /\s\s*/;

  var onceSupported = function () {
    var supported = false;

    if (IS_BROWSER) {
      var once = false;

      var listener = function listener() {};

      var options = Object.defineProperty({}, 'once', {
        get: function get() {
          supported = true;
          return once;
        },

        /**
         * This setter can fix a `TypeError` in strict mode
         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
         * @param {boolean} value - The value to set
         */
        set: function set(value) {
          once = value;
        }
      });
      WINDOW.addEventListener('test', listener, options);
      WINDOW.removeEventListener('test', listener, options);
    }

    return supported;
  }();
  /**
   * Remove event listener from the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */


  function removeListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (!onceSupported) {
        var listeners = element.listeners;

        if (listeners && listeners[event] && listeners[event][listener]) {
          handler = listeners[event][listener];
          delete listeners[event][listener];

          if (Object.keys(listeners[event]).length === 0) {
            delete listeners[event];
          }

          if (Object.keys(listeners).length === 0) {
            delete element.listeners;
          }
        }
      }

      element.removeEventListener(event, handler, options);
    });
  }
  /**
   * Add event listener to the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */

  function addListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var _handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (options.once && !onceSupported) {
        var _element$listeners = element.listeners,
            listeners = _element$listeners === void 0 ? {} : _element$listeners;

        _handler = function handler() {
          delete listeners[event][listener];
          element.removeEventListener(event, _handler, options);

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          listener.apply(element, args);
        };

        if (!listeners[event]) {
          listeners[event] = {};
        }

        if (listeners[event][listener]) {
          element.removeEventListener(event, listeners[event][listener], options);
        }

        listeners[event][listener] = _handler;
        element.listeners = listeners;
      }

      element.addEventListener(event, _handler, options);
    });
  }
  /**
   * Dispatch event on the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Object} data - The additional event data.
   * @returns {boolean} Indicate if the event is default prevented or not.
   */

  function dispatchEvent(element, type, data) {
    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors

    if (isFunction(Event) && isFunction(CustomEvent)) {
      event = new CustomEvent(type, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } else {
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(type, true, true, data);
    }

    return element.dispatchEvent(event);
  }
  /**
   * Get the offset base on the document.
   * @param {Element} element - The target element.
   * @returns {Object} The offset data.
   */

  function getOffset(element) {
    var box = element.getBoundingClientRect();
    return {
      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
      top: box.top + (window.pageYOffset - document.documentElement.clientTop)
    };
  }
  var location = WINDOW.location;
  var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
  /**
   * Check if the given URL is a cross origin URL.
   * @param {string} url - The target URL.
   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
   */

  function isCrossOriginURL(url) {
    var parts = url.match(REGEXP_ORIGINS);
    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
  }
  /**
   * Add timestamp to the given URL.
   * @param {string} url - The target URL.
   * @returns {string} The result URL.
   */

  function addTimestamp(url) {
    var timestamp = "timestamp=".concat(new Date().getTime());
    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
  }
  /**
   * Get transforms base on the given object.
   * @param {Object} obj - The target object.
   * @returns {string} A string contains transform values.
   */

  function getTransforms(_ref) {
    var rotate = _ref.rotate,
        scaleX = _ref.scaleX,
        scaleY = _ref.scaleY,
        translateX = _ref.translateX,
        translateY = _ref.translateY;
    var values = [];

    if (isNumber(translateX) && translateX !== 0) {
      values.push("translateX(".concat(translateX, "px)"));
    }

    if (isNumber(translateY) && translateY !== 0) {
      values.push("translateY(".concat(translateY, "px)"));
    } // Rotate should come first before scale to match orientation transform


    if (isNumber(rotate) && rotate !== 0) {
      values.push("rotate(".concat(rotate, "deg)"));
    }

    if (isNumber(scaleX) && scaleX !== 1) {
      values.push("scaleX(".concat(scaleX, ")"));
    }

    if (isNumber(scaleY) && scaleY !== 1) {
      values.push("scaleY(".concat(scaleY, ")"));
    }

    var transform = values.length ? values.join(' ') : 'none';
    return {
      WebkitTransform: transform,
      msTransform: transform,
      transform: transform
    };
  }
  /**
   * Get the max ratio of a group of pointers.
   * @param {string} pointers - The target pointers.
   * @returns {number} The result ratio.
   */

  function getMaxZoomRatio(pointers) {
    var pointers2 = _objectSpread2({}, pointers);

    var ratios = [];
    forEach(pointers, function (pointer, pointerId) {
      delete pointers2[pointerId];
      forEach(pointers2, function (pointer2) {
        var x1 = Math.abs(pointer.startX - pointer2.startX);
        var y1 = Math.abs(pointer.startY - pointer2.startY);
        var x2 = Math.abs(pointer.endX - pointer2.endX);
        var y2 = Math.abs(pointer.endY - pointer2.endY);
        var z1 = Math.sqrt(x1 * x1 + y1 * y1);
        var z2 = Math.sqrt(x2 * x2 + y2 * y2);
        var ratio = (z2 - z1) / z1;
        ratios.push(ratio);
      });
    });
    ratios.sort(function (a, b) {
      return Math.abs(a) < Math.abs(b);
    });
    return ratios[0];
  }
  /**
   * Get a pointer from an event object.
   * @param {Object} event - The target event object.
   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
   * @returns {Object} The result pointer contains start and/or end point coordinates.
   */

  function getPointer(_ref2, endOnly) {
    var pageX = _ref2.pageX,
        pageY = _ref2.pageY;
    var end = {
      endX: pageX,
      endY: pageY
    };
    return endOnly ? end : _objectSpread2({
      startX: pageX,
      startY: pageY
    }, end);
  }
  /**
   * Get the center point coordinate of a group of pointers.
   * @param {Object} pointers - The target pointers.
   * @returns {Object} The center point coordinate.
   */

  function getPointersCenter(pointers) {
    var pageX = 0;
    var pageY = 0;
    var count = 0;
    forEach(pointers, function (_ref3) {
      var startX = _ref3.startX,
          startY = _ref3.startY;
      pageX += startX;
      pageY += startY;
      count += 1;
    });
    pageX /= count;
    pageY /= count;
    return {
      pageX: pageX,
      pageY: pageY
    };
  }
  /**
   * Get the max sizes in a rectangle under the given aspect ratio.
   * @param {Object} data - The original sizes.
   * @param {string} [type='contain'] - The adjust type.
   * @returns {Object} The result sizes.
   */

  function getAdjustedSizes(_ref4) // or 'cover'
  {
    var aspectRatio = _ref4.aspectRatio,
        height = _ref4.height,
        width = _ref4.width;
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';
    var isValidWidth = isPositiveNumber(width);
    var isValidHeight = isPositiveNumber(height);

    if (isValidWidth && isValidHeight) {
      var adjustedWidth = height * aspectRatio;

      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {
        height = width / aspectRatio;
      } else {
        width = height * aspectRatio;
      }
    } else if (isValidWidth) {
      height = width / aspectRatio;
    } else if (isValidHeight) {
      width = height * aspectRatio;
    }

    return {
      width: width,
      height: height
    };
  }
  /**
   * Get the new sizes of a rectangle after rotated.
   * @param {Object} data - The original sizes.
   * @returns {Object} The result sizes.
   */

  function getRotatedSizes(_ref5) {
    var width = _ref5.width,
        height = _ref5.height,
        degree = _ref5.degree;
    degree = Math.abs(degree) % 180;

    if (degree === 90) {
      return {
        width: height,
        height: width
      };
    }

    var arc = degree % 90 * Math.PI / 180;
    var sinArc = Math.sin(arc);
    var cosArc = Math.cos(arc);
    var newWidth = width * cosArc + height * sinArc;
    var newHeight = width * sinArc + height * cosArc;
    return degree > 90 ? {
      width: newHeight,
      height: newWidth
    } : {
      width: newWidth,
      height: newHeight
    };
  }
  /**
   * Get a canvas which drew the given image.
   * @param {HTMLImageElement} image - The image for drawing.
   * @param {Object} imageData - The image data.
   * @param {Object} canvasData - The canvas data.
   * @param {Object} options - The options.
   * @returns {HTMLCanvasElement} The result canvas.
   */

  function getSourceCanvas(image, _ref6, _ref7, _ref8) {
    var imageAspectRatio = _ref6.aspectRatio,
        imageNaturalWidth = _ref6.naturalWidth,
        imageNaturalHeight = _ref6.naturalHeight,
        _ref6$rotate = _ref6.rotate,
        rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
        _ref6$scaleX = _ref6.scaleX,
        scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,
        _ref6$scaleY = _ref6.scaleY,
        scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
    var aspectRatio = _ref7.aspectRatio,
        naturalWidth = _ref7.naturalWidth,
        naturalHeight = _ref7.naturalHeight;
    var _ref8$fillColor = _ref8.fillColor,
        fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,
        _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
        imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,
        _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
        imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,
        _ref8$maxWidth = _ref8.maxWidth,
        maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,
        _ref8$maxHeight = _ref8.maxHeight,
        maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,
        _ref8$minWidth = _ref8.minWidth,
        minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,
        _ref8$minHeight = _ref8.minHeight,
        minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var maxSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var minSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as
    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90

    var destMaxSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var destMinSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);
    context.fillStyle = fillColor;
    context.fillRect(0, 0, width, height);
    context.save();
    context.translate(width / 2, height / 2);
    context.rotate(rotate * Math.PI / 180);
    context.scale(scaleX, scaleY);
    context.imageSmoothingEnabled = imageSmoothingEnabled;
    context.imageSmoothingQuality = imageSmoothingQuality;
    context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {
      return Math.floor(normalizeDecimalNumber(param));
    }))));
    context.restore();
    return canvas;
  }
  var fromCharCode = String.fromCharCode;
  /**
   * Get string from char code in data view.
   * @param {DataView} dataView - The data view for read.
   * @param {number} start - The start index.
   * @param {number} length - The read length.
   * @returns {string} The read result.
   */

  function getStringFromCharCode(dataView, start, length) {
    var str = '';
    length += start;

    for (var i = start; i < length; i += 1) {
      str += fromCharCode(dataView.getUint8(i));
    }

    return str;
  }
  var REGEXP_DATA_URL_HEAD = /^data:.*,/;
  /**
   * Transform Data URL to array buffer.
   * @param {string} dataURL - The Data URL to transform.
   * @returns {ArrayBuffer} The result array buffer.
   */

  function dataURLToArrayBuffer(dataURL) {
    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
    var binary = atob(base64);
    var arrayBuffer = new ArrayBuffer(binary.length);
    var uint8 = new Uint8Array(arrayBuffer);
    forEach(uint8, function (value, i) {
      uint8[i] = binary.charCodeAt(i);
    });
    return arrayBuffer;
  }
  /**
   * Transform array buffer to Data URL.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
   * @param {string} mimeType - The mime type of the Data URL.
   * @returns {string} The result Data URL.
   */

  function arrayBufferToDataURL(arrayBuffer, mimeType) {
    var chunks = []; // Chunk Typed Array for better performance (#435)

    var chunkSize = 8192;
    var uint8 = new Uint8Array(arrayBuffer);

    while (uint8.length > 0) {
      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9
      // eslint-disable-next-line prefer-spread
      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
      uint8 = uint8.subarray(chunkSize);
    }

    return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join('')));
  }
  /**
   * Get orientation value from given array buffer.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
   * @returns {number} The read orientation value.
   */

  function resetAndGetOrientation(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var orientation; // Ignores range error when the image does not have correct Exif information

    try {
      var littleEndian;
      var app1Start;
      var ifdStart; // Only handle JPEG image (start by 0xFFD8)

      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
        var length = dataView.byteLength;
        var offset = 2;

        while (offset + 1 < length) {
          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
            app1Start = offset;
            break;
          }

          offset += 1;
        }
      }

      if (app1Start) {
        var exifIDCode = app1Start + 4;
        var tiffOffset = app1Start + 10;

        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
          var endianness = dataView.getUint16(tiffOffset);
          littleEndian = endianness === 0x4949;

          if (littleEndian || endianness === 0x4D4D
          /* bigEndian */
          ) {
              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

                if (firstIFDOffset >= 0x00000008) {
                  ifdStart = tiffOffset + firstIFDOffset;
                }
              }
            }
        }
      }

      if (ifdStart) {
        var _length = dataView.getUint16(ifdStart, littleEndian);

        var _offset;

        var i;

        for (i = 0; i < _length; i += 1) {
          _offset = ifdStart + i * 12 + 2;

          if (dataView.getUint16(_offset, littleEndian) === 0x0112
          /* Orientation */
          ) {
              // 8 is the offset of the current tag's value
              _offset += 8; // Get the original orientation value

              orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value

              dataView.setUint16(_offset, 1, littleEndian);
              break;
            }
        }
      }
    } catch (error) {
      orientation = 1;
    }

    return orientation;
  }
  /**
   * Parse Exif Orientation value.
   * @param {number} orientation - The orientation to parse.
   * @returns {Object} The parsed result.
   */

  function parseOrientation(orientation) {
    var rotate = 0;
    var scaleX = 1;
    var scaleY = 1;

    switch (orientation) {
      // Flip horizontal
      case 2:
        scaleX = -1;
        break;
      // Rotate left 180Â°

      case 3:
        rotate = -180;
        break;
      // Flip vertical

      case 4:
        scaleY = -1;
        break;
      // Flip vertical and rotate right 90Â°

      case 5:
        rotate = 90;
        scaleY = -1;
        break;
      // Rotate right 90Â°

      case 6:
        rotate = 90;
        break;
      // Flip horizontal and rotate right 90Â°

      case 7:
        rotate = 90;
        scaleX = -1;
        break;
      // Rotate left 90Â°

      case 8:
        rotate = -90;
        break;

      default:
    }

    return {
      rotate: rotate,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var render = {
    render: function render() {
      this.initContainer();
      this.initCanvas();
      this.initCropBox();
      this.renderCanvas();

      if (this.cropped) {
        this.renderCropBox();
      }
    },
    initContainer: function initContainer() {
      var element = this.element,
          options = this.options,
          container = this.container,
          cropper = this.cropper;
      addClass(cropper, CLASS_HIDDEN);
      removeClass(element, CLASS_HIDDEN);
      var containerData = {
        width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),
        height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)
      };
      this.containerData = containerData;
      setStyle(cropper, {
        width: containerData.width,
        height: containerData.height
      });
      addClass(element, CLASS_HIDDEN);
      removeClass(cropper, CLASS_HIDDEN);
    },
    // Canvas (image wrapper)
    initCanvas: function initCanvas() {
      var containerData = this.containerData,
          imageData = this.imageData;
      var viewMode = this.options.viewMode;
      var rotated = Math.abs(imageData.rotate) % 180 === 90;
      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
      var aspectRatio = naturalWidth / naturalHeight;
      var canvasWidth = containerData.width;
      var canvasHeight = containerData.height;

      if (containerData.height * aspectRatio > containerData.width) {
        if (viewMode === 3) {
          canvasWidth = containerData.height * aspectRatio;
        } else {
          canvasHeight = containerData.width / aspectRatio;
        }
      } else if (viewMode === 3) {
        canvasHeight = containerData.width / aspectRatio;
      } else {
        canvasWidth = containerData.height * aspectRatio;
      }

      var canvasData = {
        aspectRatio: aspectRatio,
        naturalWidth: naturalWidth,
        naturalHeight: naturalHeight,
        width: canvasWidth,
        height: canvasHeight
      };
      canvasData.left = (containerData.width - canvasWidth) / 2;
      canvasData.top = (containerData.height - canvasHeight) / 2;
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      this.canvasData = canvasData;
      this.limited = viewMode === 1 || viewMode === 2;
      this.limitCanvas(true, true);
      this.initialImageData = assign({}, imageData);
      this.initialCanvasData = assign({}, canvasData);
    },
    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var viewMode = options.viewMode;
      var aspectRatio = canvasData.aspectRatio;
      var cropped = this.cropped && cropBoxData;

      if (sizeLimited) {
        var minCanvasWidth = Number(options.minCanvasWidth) || 0;
        var minCanvasHeight = Number(options.minCanvasHeight) || 0;

        if (viewMode > 1) {
          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

          if (viewMode === 3) {
            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        } else if (viewMode > 0) {
          if (minCanvasWidth) {
            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
          } else if (minCanvasHeight) {
            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
          } else if (cropped) {
            minCanvasWidth = cropBoxData.width;
            minCanvasHeight = cropBoxData.height;

            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        }

        var _getAdjustedSizes = getAdjustedSizes({
          aspectRatio: aspectRatio,
          width: minCanvasWidth,
          height: minCanvasHeight
        });

        minCanvasWidth = _getAdjustedSizes.width;
        minCanvasHeight = _getAdjustedSizes.height;
        canvasData.minWidth = minCanvasWidth;
        canvasData.minHeight = minCanvasHeight;
        canvasData.maxWidth = Infinity;
        canvasData.maxHeight = Infinity;
      }

      if (positionLimited) {
        if (viewMode > (cropped ? 0 : 1)) {
          var newCanvasLeft = containerData.width - canvasData.width;
          var newCanvasTop = containerData.height - canvasData.height;
          canvasData.minLeft = Math.min(0, newCanvasLeft);
          canvasData.minTop = Math.min(0, newCanvasTop);
          canvasData.maxLeft = Math.max(0, newCanvasLeft);
          canvasData.maxTop = Math.max(0, newCanvasTop);

          if (cropped && this.limited) {
            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
            canvasData.maxLeft = cropBoxData.left;
            canvasData.maxTop = cropBoxData.top;

            if (viewMode === 2) {
              if (canvasData.width >= containerData.width) {
                canvasData.minLeft = Math.min(0, newCanvasLeft);
                canvasData.maxLeft = Math.max(0, newCanvasLeft);
              }

              if (canvasData.height >= containerData.height) {
                canvasData.minTop = Math.min(0, newCanvasTop);
                canvasData.maxTop = Math.max(0, newCanvasTop);
              }
            }
          }
        } else {
          canvasData.minLeft = -canvasData.width;
          canvasData.minTop = -canvasData.height;
          canvasData.maxLeft = containerData.width;
          canvasData.maxTop = containerData.height;
        }
      }
    },
    renderCanvas: function renderCanvas(changed, transformed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;

      if (transformed) {
        var _getRotatedSizes = getRotatedSizes({
          width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
          height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
          degree: imageData.rotate || 0
        }),
            naturalWidth = _getRotatedSizes.width,
            naturalHeight = _getRotatedSizes.height;

        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
        canvasData.left -= (width - canvasData.width) / 2;
        canvasData.top -= (height - canvasData.height) / 2;
        canvasData.width = width;
        canvasData.height = height;
        canvasData.aspectRatio = naturalWidth / naturalHeight;
        canvasData.naturalWidth = naturalWidth;
        canvasData.naturalHeight = naturalHeight;
        this.limitCanvas(true, false);
      }

      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
        canvasData.left = canvasData.oldLeft;
      }

      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
        canvasData.top = canvasData.oldTop;
      }

      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
      this.limitCanvas(false, true);
      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      setStyle(this.canvas, assign({
        width: canvasData.width,
        height: canvasData.height
      }, getTransforms({
        translateX: canvasData.left,
        translateY: canvasData.top
      })));
      this.renderImage(changed);

      if (this.cropped && this.limited) {
        this.limitCropBox(true, true);
      }
    },
    renderImage: function renderImage(changed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;
      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
      assign(imageData, {
        width: width,
        height: height,
        left: (canvasData.width - width) / 2,
        top: (canvasData.height - height) / 2
      });
      setStyle(this.image, assign({
        width: imageData.width,
        height: imageData.height
      }, getTransforms(assign({
        translateX: imageData.left,
        translateY: imageData.top
      }, imageData))));

      if (changed) {
        this.output();
      }
    },
    initCropBox: function initCropBox() {
      var options = this.options,
          canvasData = this.canvasData;
      var aspectRatio = options.aspectRatio || options.initialAspectRatio;
      var autoCropArea = Number(options.autoCropArea) || 0.8;
      var cropBoxData = {
        width: canvasData.width,
        height: canvasData.height
      };

      if (aspectRatio) {
        if (canvasData.height * aspectRatio > canvasData.width) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      this.cropBoxData = cropBoxData;
      this.limitCropBox(true, true); // Initialize auto crop area

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than "minWidth/Height"

      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;
      this.initialCropBoxData = assign({}, cropBoxData);
    },
    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData,
          limited = this.limited;
      var aspectRatio = options.aspectRatio;

      if (sizeLimited) {
        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height

        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

        if (aspectRatio) {
          if (minCropBoxWidth && minCropBoxHeight) {
            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
          } else if (minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else if (minCropBoxHeight) {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }

          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
          } else {
            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
          }
        } // The minWidth/Height must be less than maxWidth/Height


        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
        cropBoxData.maxWidth = maxCropBoxWidth;
        cropBoxData.maxHeight = maxCropBoxHeight;
      }

      if (positionLimited) {
        if (limited) {
          cropBoxData.minLeft = Math.max(0, canvasData.left);
          cropBoxData.minTop = Math.max(0, canvasData.top);
          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
        } else {
          cropBoxData.minLeft = 0;
          cropBoxData.minTop = 0;
          cropBoxData.maxLeft = containerData.width - cropBoxData.width;
          cropBoxData.maxTop = containerData.height - cropBoxData.height;
        }
      }
    },
    renderCropBox: function renderCropBox() {
      var options = this.options,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData;

      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
        cropBoxData.left = cropBoxData.oldLeft;
      }

      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
        cropBoxData.top = cropBoxData.oldTop;
      }

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
      this.limitCropBox(false, true);
      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;

      if (options.movable && options.cropBoxMovable) {
        // Turn to move the canvas when the crop box is equal to the container
        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
      }

      setStyle(this.cropBox, assign({
        width: cropBoxData.width,
        height: cropBoxData.height
      }, getTransforms({
        translateX: cropBoxData.left,
        translateY: cropBoxData.top
      })));

      if (this.cropped && this.limited) {
        this.limitCanvas(true, true);
      }

      if (!this.disabled) {
        this.output();
      }
    },
    output: function output() {
      this.preview();
      dispatchEvent(this.element, EVENT_CROP, this.getData());
    }
  };

  var preview = {
    initPreview: function initPreview() {
      var element = this.element,
          crossOrigin = this.crossOrigin;
      var preview = this.options.preview;
      var url = crossOrigin ? this.crossOriginUrl : this.url;
      var alt = element.alt || 'The image to preview';
      var image = document.createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = url;
      image.alt = alt;
      this.viewBox.appendChild(image);
      this.viewBoxImage = image;

      if (!preview) {
        return;
      }

      var previews = preview;

      if (typeof preview === 'string') {
        previews = element.ownerDocument.querySelectorAll(preview);
      } else if (preview.querySelector) {
        previews = [preview];
      }

      this.previews = previews;
      forEach(previews, function (el) {
        var img = document.createElement('img'); // Save the original size for recover

        setData(el, DATA_PREVIEW, {
          width: el.offsetWidth,
          height: el.offsetHeight,
          html: el.innerHTML
        });

        if (crossOrigin) {
          img.crossOrigin = crossOrigin;
        }

        img.src = url;
        img.alt = alt;
        /**
         * Override img element styles
         * Add `display:block` to avoid margin top issue
         * Add `height:auto` to override `height` attribute on IE8
         * (Occur only when margin-top <= -height)
         */

        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';
        el.innerHTML = '';
        el.appendChild(img);
      });
    },
    resetPreview: function resetPreview() {
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        setStyle(element, {
          width: data.width,
          height: data.height
        });
        element.innerHTML = data.html;
        removeData(element, DATA_PREVIEW);
      });
    },
    preview: function preview() {
      var imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var cropBoxWidth = cropBoxData.width,
          cropBoxHeight = cropBoxData.height;
      var width = imageData.width,
          height = imageData.height;
      var left = cropBoxData.left - canvasData.left - imageData.left;
      var top = cropBoxData.top - canvasData.top - imageData.top;

      if (!this.cropped || this.disabled) {
        return;
      }

      setStyle(this.viewBoxImage, assign({
        width: width,
        height: height
      }, getTransforms(assign({
        translateX: -left,
        translateY: -top
      }, imageData))));
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        var originalWidth = data.width;
        var originalHeight = data.height;
        var newWidth = originalWidth;
        var newHeight = originalHeight;
        var ratio = 1;

        if (cropBoxWidth) {
          ratio = originalWidth / cropBoxWidth;
          newHeight = cropBoxHeight * ratio;
        }

        if (cropBoxHeight && newHeight > originalHeight) {
          ratio = originalHeight / cropBoxHeight;
          newWidth = cropBoxWidth * ratio;
          newHeight = originalHeight;
        }

        setStyle(element, {
          width: newWidth,
          height: newHeight
        });
        setStyle(element.getElementsByTagName('img')[0], assign({
          width: width * ratio,
          height: height * ratio
        }, getTransforms(assign({
          translateX: -left * ratio,
          translateY: -top * ratio
        }, imageData))));
      });
    }
  };

  var events = {
    bind: function bind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        addListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        addListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        addListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        addListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        addListener(element, EVENT_ZOOM, options.zoom);
      }

      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));

      if (options.zoomable && options.zoomOnWheel) {
        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
      }

      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));

      if (options.responsive) {
        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
      }
    },
    unbind: function unbind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        removeListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        removeListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        removeListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        removeListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        removeListener(element, EVENT_ZOOM, options.zoom);
      }

      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);

      if (options.zoomable && options.zoomOnWheel) {
        removeListener(cropper, EVENT_WHEEL, this.onWheel, {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
      }

      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);

      if (options.responsive) {
        removeListener(window, EVENT_RESIZE, this.onResize);
      }
    }
  };

  var handlers = {
    resize: function resize() {
      var options = this.options,
          container = this.container,
          containerData = this.containerData;
      var minContainerWidth = Number(options.minContainerWidth) || MIN_CONTAINER_WIDTH;
      var minContainerHeight = Number(options.minContainerHeight) || MIN_CONTAINER_HEIGHT;

      if (this.disabled || containerData.width <= minContainerWidth || containerData.height <= minContainerHeight) {
        return;
      }

      var ratio = container.offsetWidth / containerData.width; // Resize when width changed or height changed

      if (ratio !== 1 || container.offsetHeight !== containerData.height) {
        var canvasData;
        var cropBoxData;

        if (options.restore) {
          canvasData = this.getCanvasData();
          cropBoxData = this.getCropBoxData();
        }

        this.render();

        if (options.restore) {
          this.setCanvasData(forEach(canvasData, function (n, i) {
            canvasData[i] = n * ratio;
          }));
          this.setCropBoxData(forEach(cropBoxData, function (n, i) {
            cropBoxData[i] = n * ratio;
          }));
        }
      }
    },
    dblclick: function dblclick() {
      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
        return;
      }

      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
    },
    wheel: function wheel(event) {
      var _this = this;

      var ratio = Number(this.options.wheelZoomRatio) || 0.1;
      var delta = 1;

      if (this.disabled) {
        return;
      }

      event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)

      if (this.wheeling) {
        return;
      }

      this.wheeling = true;
      setTimeout(function () {
        _this.wheeling = false;
      }, 50);

      if (event.deltaY) {
        delta = event.deltaY > 0 ? 1 : -1;
      } else if (event.wheelDelta) {
        delta = -event.wheelDelta / 120;
      } else if (event.detail) {
        delta = event.detail > 0 ? 1 : -1;
      }

      this.zoom(-delta * ratio, event);
    },
    cropStart: function cropStart(event) {
      var buttons = event.buttons,
          button = event.button;

      if (this.disabled // Handle mouse event and pointer event and ignore touch event
      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)
      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu
      || event.ctrlKey)) {
        return;
      }

      var options = this.options,
          pointers = this.pointers;
      var action;

      if (event.changedTouches) {
        // Handle touch event
        forEach(event.changedTouches, function (touch) {
          pointers[touch.identifier] = getPointer(touch);
        });
      } else {
        // Handle mouse event and pointer event
        pointers[event.pointerId || 0] = getPointer(event);
      }

      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
        action = ACTION_ZOOM;
      } else {
        action = getData(event.target, DATA_ACTION);
      }

      if (!REGEXP_ACTIONS.test(action)) {
        return;
      }

      if (dispatchEvent(this.element, EVENT_CROP_START, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      } // This line is required for preventing page zooming in iOS browsers


      event.preventDefault();
      this.action = action;
      this.cropping = false;

      if (action === ACTION_CROP) {
        this.cropping = true;
        addClass(this.dragBox, CLASS_MODAL);
      }
    },
    cropMove: function cropMove(event) {
      var action = this.action;

      if (this.disabled || !action) {
        return;
      }

      var pointers = this.pointers;
      event.preventDefault();

      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      }

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          // The first parameter should not be undefined (#432)
          assign(pointers[touch.identifier] || {}, getPointer(touch, true));
        });
      } else {
        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
      }

      this.change(event);
    },
    cropEnd: function cropEnd(event) {
      if (this.disabled) {
        return;
      }

      var action = this.action,
          pointers = this.pointers;

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          delete pointers[touch.identifier];
        });
      } else {
        delete pointers[event.pointerId || 0];
      }

      if (!action) {
        return;
      }

      event.preventDefault();

      if (!Object.keys(pointers).length) {
        this.action = '';
      }

      if (this.cropping) {
        this.cropping = false;
        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
      }

      dispatchEvent(this.element, EVENT_CROP_END, {
        originalEvent: event,
        action: action
      });
    }
  };

  var change = {
    change: function change(event) {
      var options = this.options,
          canvasData = this.canvasData,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData,
          pointers = this.pointers;
      var action = this.action;
      var aspectRatio = options.aspectRatio;
      var left = cropBoxData.left,
          top = cropBoxData.top,
          width = cropBoxData.width,
          height = cropBoxData.height;
      var right = left + width;
      var bottom = top + height;
      var minLeft = 0;
      var minTop = 0;
      var maxWidth = containerData.width;
      var maxHeight = containerData.height;
      var renderable = true;
      var offset; // Locking aspect ratio in "free mode" by holding shift key

      if (!aspectRatio && event.shiftKey) {
        aspectRatio = width && height ? width / height : 1;
      }

      if (this.limited) {
        minLeft = cropBoxData.minLeft;
        minTop = cropBoxData.minTop;
        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
      }

      var pointer = pointers[Object.keys(pointers)[0]];
      var range = {
        x: pointer.endX - pointer.startX,
        y: pointer.endY - pointer.startY
      };

      var check = function check(side) {
        switch (side) {
          case ACTION_EAST:
            if (right + range.x > maxWidth) {
              range.x = maxWidth - right;
            }

            break;

          case ACTION_WEST:
            if (left + range.x < minLeft) {
              range.x = minLeft - left;
            }

            break;

          case ACTION_NORTH:
            if (top + range.y < minTop) {
              range.y = minTop - top;
            }

            break;

          case ACTION_SOUTH:
            if (bottom + range.y > maxHeight) {
              range.y = maxHeight - bottom;
            }

            break;

          default:
        }
      };

      switch (action) {
        // Move crop box
        case ACTION_ALL:
          left += range.x;
          top += range.y;
          break;
        // Resize crop box

        case ACTION_EAST:
          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_EAST);
          width += range.x;

          if (width < 0) {
            action = ACTION_WEST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_NORTH:
          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;

          if (height < 0) {
            action = ACTION_SOUTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_WEST:
          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_WEST);
          width -= range.x;
          left += range.x;

          if (width < 0) {
            action = ACTION_EAST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_SOUTH:
          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_SOUTH);
          height += range.y;

          if (height < 0) {
            action = ACTION_NORTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_NORTH_EAST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
          } else {
            check(ACTION_NORTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_NORTH_WEST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
            left += cropBoxData.width - width;
          } else {
            check(ACTION_NORTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_WEST:
          if (aspectRatio) {
            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_WEST);
            width -= range.x;
            left += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_EAST:
          if (aspectRatio) {
            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_EAST);
            width += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            top -= height;
          }

          break;
        // Move canvas

        case ACTION_MOVE:
          this.move(range.x, range.y);
          renderable = false;
          break;
        // Zoom canvas

        case ACTION_ZOOM:
          this.zoom(getMaxZoomRatio(pointers), event);
          renderable = false;
          break;
        // Create crop box

        case ACTION_CROP:
          if (!range.x || !range.y) {
            renderable = false;
            break;
          }

          offset = getOffset(this.cropper);
          left = pointer.startX - offset.left;
          top = pointer.startY - offset.top;
          width = cropBoxData.minWidth;
          height = cropBoxData.minHeight;

          if (range.x > 0) {
            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
          } else if (range.x < 0) {
            left -= width;
            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
          }

          if (range.y < 0) {
            top -= height;
          } // Show the crop box if is hidden


          if (!this.cropped) {
            removeClass(this.cropBox, CLASS_HIDDEN);
            this.cropped = true;

            if (this.limited) {
              this.limitCropBox(true, true);
            }
          }

          break;

        default:
      }

      if (renderable) {
        cropBoxData.width = width;
        cropBoxData.height = height;
        cropBoxData.left = left;
        cropBoxData.top = top;
        this.action = action;
        this.renderCropBox();
      } // Override


      forEach(pointers, function (p) {
        p.startX = p.endX;
        p.startY = p.endY;
      });
    }
  };

  var methods = {
    // Show the crop box manually
    crop: function crop() {
      if (this.ready && !this.cropped && !this.disabled) {
        this.cropped = true;
        this.limitCropBox(true, true);

        if (this.options.modal) {
          addClass(this.dragBox, CLASS_MODAL);
        }

        removeClass(this.cropBox, CLASS_HIDDEN);
        this.setCropBoxData(this.initialCropBoxData);
      }

      return this;
    },
    // Reset the image and crop box to their initial states
    reset: function reset() {
      if (this.ready && !this.disabled) {
        this.imageData = assign({}, this.initialImageData);
        this.canvasData = assign({}, this.initialCanvasData);
        this.cropBoxData = assign({}, this.initialCropBoxData);
        this.renderCanvas();

        if (this.cropped) {
          this.renderCropBox();
        }
      }

      return this;
    },
    // Clear the crop box
    clear: function clear() {
      if (this.cropped && !this.disabled) {
        assign(this.cropBoxData, {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        });
        this.cropped = false;
        this.renderCropBox();
        this.limitCanvas(true, true); // Render canvas after crop box rendered

        this.renderCanvas();
        removeClass(this.dragBox, CLASS_MODAL);
        addClass(this.cropBox, CLASS_HIDDEN);
      }

      return this;
    },

    /**
     * Replace the image's src and rebuild the cropper
     * @param {string} url - The new URL.
     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
     * @returns {Cropper} this
     */
    replace: function replace(url) {
      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.disabled && url) {
        if (this.isImg) {
          this.element.src = url;
        }

        if (hasSameSize) {
          this.url = url;
          this.image.src = url;

          if (this.ready) {
            this.viewBoxImage.src = url;
            forEach(this.previews, function (element) {
              element.getElementsByTagName('img')[0].src = url;
            });
          }
        } else {
          if (this.isImg) {
            this.replaced = true;
          }

          this.options.data = null;
          this.uncreate();
          this.load(url);
        }
      }

      return this;
    },
    // Enable (unfreeze) the cropper
    enable: function enable() {
      if (this.ready && this.disabled) {
        this.disabled = false;
        removeClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },
    // Disable (freeze) the cropper
    disable: function disable() {
      if (this.ready && !this.disabled) {
        this.disabled = true;
        addClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },

    /**
     * Destroy the cropper and remove the instance from the image
     * @returns {Cropper} this
     */
    destroy: function destroy() {
      var element = this.element;

      if (!element[NAMESPACE]) {
        return this;
      }

      element[NAMESPACE] = undefined;

      if (this.isImg && this.replaced) {
        element.src = this.originalUrl;
      }

      this.uncreate();
      return this;
    },

    /**
     * Move the canvas with relative offsets
     * @param {number} offsetX - The relative offset distance on the x-axis.
     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
     * @returns {Cropper} this
     */
    move: function move(offsetX) {
      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;
      var _this$canvasData = this.canvasData,
          left = _this$canvasData.left,
          top = _this$canvasData.top;
      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
    },

    /**
     * Move the canvas to an absolute point
     * @param {number} x - The x-axis coordinate.
     * @param {number} [y=x] - The y-axis coordinate.
     * @returns {Cropper} this
     */
    moveTo: function moveTo(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var canvasData = this.canvasData;
      var changed = false;
      x = Number(x);
      y = Number(y);

      if (this.ready && !this.disabled && this.options.movable) {
        if (isNumber(x)) {
          canvasData.left = x;
          changed = true;
        }

        if (isNumber(y)) {
          canvasData.top = y;
          changed = true;
        }

        if (changed) {
          this.renderCanvas(true);
        }
      }

      return this;
    },

    /**
     * Zoom the canvas with a relative ratio
     * @param {number} ratio - The target ratio.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoom: function zoom(ratio, _originalEvent) {
      var canvasData = this.canvasData;
      ratio = Number(ratio);

      if (ratio < 0) {
        ratio = 1 / (1 - ratio);
      } else {
        ratio = 1 + ratio;
      }

      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
    },

    /**
     * Zoom the canvas to an absolute ratio
     * @param {number} ratio - The target ratio.
     * @param {Object} pivot - The zoom pivot point coordinate.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
      var options = this.options,
          canvasData = this.canvasData;
      var width = canvasData.width,
          height = canvasData.height,
          naturalWidth = canvasData.naturalWidth,
          naturalHeight = canvasData.naturalHeight;
      ratio = Number(ratio);

      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
        var newWidth = naturalWidth * ratio;
        var newHeight = naturalHeight * ratio;

        if (dispatchEvent(this.element, EVENT_ZOOM, {
          ratio: ratio,
          oldRatio: width / naturalWidth,
          originalEvent: _originalEvent
        }) === false) {
          return this;
        }

        if (_originalEvent) {
          var pointers = this.pointers;
          var offset = getOffset(this.cropper);
          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
            pageX: _originalEvent.pageX,
            pageY: _originalEvent.pageY
          }; // Zoom from the triggering point of the event

          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
        } else {
          // Zoom from the center of the canvas
          canvasData.left -= (newWidth - width) / 2;
          canvasData.top -= (newHeight - height) / 2;
        }

        canvasData.width = newWidth;
        canvasData.height = newHeight;
        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Rotate the canvas with a relative degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotate: function rotate(degree) {
      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
    },

    /**
     * Rotate the canvas to an absolute degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotateTo: function rotateTo(degree) {
      degree = Number(degree);

      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
        this.imageData.rotate = degree % 360;
        this.renderCanvas(true, true);
      }

      return this;
    },

    /**
     * Scale the image on the x-axis.
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @returns {Cropper} this
     */
    scaleX: function scaleX(_scaleX) {
      var scaleY = this.imageData.scaleY;
      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
    },

    /**
     * Scale the image on the y-axis.
     * @param {number} scaleY - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scaleY: function scaleY(_scaleY) {
      var scaleX = this.imageData.scaleX;
      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
    },

    /**
     * Scale the image
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scale: function scale(scaleX) {
      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
      var imageData = this.imageData;
      var transformed = false;
      scaleX = Number(scaleX);
      scaleY = Number(scaleY);

      if (this.ready && !this.disabled && this.options.scalable) {
        if (isNumber(scaleX)) {
          imageData.scaleX = scaleX;
          transformed = true;
        }

        if (isNumber(scaleY)) {
          imageData.scaleY = scaleY;
          transformed = true;
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }
      }

      return this;
    },

    /**
     * Get the cropped area position and size data (base on the original image)
     * @param {boolean} [rounded=false] - Indicate if round the data values or not.
     * @returns {Object} The result cropped data.
     */
    getData: function getData() {
      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          x: cropBoxData.left - canvasData.left,
          y: cropBoxData.top - canvasData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
        var ratio = imageData.width / imageData.naturalWidth;
        forEach(data, function (n, i) {
          data[i] = n / ratio;
        });

        if (rounded) {
          // In case rounding off leads to extra 1px in right or bottom border
          // we should round the top-left corner and the dimension (#343).
          var bottom = Math.round(data.y + data.height);
          var right = Math.round(data.x + data.width);
          data.x = Math.round(data.x);
          data.y = Math.round(data.y);
          data.width = right - data.x;
          data.height = bottom - data.y;
        }
      } else {
        data = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      if (options.rotatable) {
        data.rotate = imageData.rotate || 0;
      }

      if (options.scalable) {
        data.scaleX = imageData.scaleX || 1;
        data.scaleY = imageData.scaleY || 1;
      }

      return data;
    },

    /**
     * Set the cropped area position and size with new data
     * @param {Object} data - The new data.
     * @returns {Cropper} this
     */
    setData: function setData(data) {
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData;
      var cropBoxData = {};

      if (this.ready && !this.disabled && isPlainObject(data)) {
        var transformed = false;

        if (options.rotatable) {
          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
            imageData.rotate = data.rotate;
            transformed = true;
          }
        }

        if (options.scalable) {
          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
            imageData.scaleX = data.scaleX;
            transformed = true;
          }

          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
            imageData.scaleY = data.scaleY;
            transformed = true;
          }
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }

        var ratio = imageData.width / imageData.naturalWidth;

        if (isNumber(data.x)) {
          cropBoxData.left = data.x * ratio + canvasData.left;
        }

        if (isNumber(data.y)) {
          cropBoxData.top = data.y * ratio + canvasData.top;
        }

        if (isNumber(data.width)) {
          cropBoxData.width = data.width * ratio;
        }

        if (isNumber(data.height)) {
          cropBoxData.height = data.height * ratio;
        }

        this.setCropBoxData(cropBoxData);
      }

      return this;
    },

    /**
     * Get the container size data.
     * @returns {Object} The result container data.
     */
    getContainerData: function getContainerData() {
      return this.ready ? assign({}, this.containerData) : {};
    },

    /**
     * Get the image position and size data.
     * @returns {Object} The result image data.
     */
    getImageData: function getImageData() {
      return this.sized ? assign({}, this.imageData) : {};
    },

    /**
     * Get the canvas position and size data.
     * @returns {Object} The result canvas data.
     */
    getCanvasData: function getCanvasData() {
      var canvasData = this.canvasData;
      var data = {};

      if (this.ready) {
        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
          data[n] = canvasData[n];
        });
      }

      return data;
    },

    /**
     * Set the canvas position and size with new data.
     * @param {Object} data - The new canvas data.
     * @returns {Cropper} this
     */
    setCanvasData: function setCanvasData(data) {
      var canvasData = this.canvasData;
      var aspectRatio = canvasData.aspectRatio;

      if (this.ready && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          canvasData.left = data.left;
        }

        if (isNumber(data.top)) {
          canvasData.top = data.top;
        }

        if (isNumber(data.width)) {
          canvasData.width = data.width;
          canvasData.height = data.width / aspectRatio;
        } else if (isNumber(data.height)) {
          canvasData.height = data.height;
          canvasData.width = data.height * aspectRatio;
        }

        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Get the crop box position and size data.
     * @returns {Object} The result crop box data.
     */
    getCropBoxData: function getCropBoxData() {
      var cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          left: cropBoxData.left,
          top: cropBoxData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
      }

      return data || {};
    },

    /**
     * Set the crop box position and size with new data.
     * @param {Object} data - The new crop box data.
     * @returns {Cropper} this
     */
    setCropBoxData: function setCropBoxData(data) {
      var cropBoxData = this.cropBoxData;
      var aspectRatio = this.options.aspectRatio;
      var widthChanged;
      var heightChanged;

      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          cropBoxData.left = data.left;
        }

        if (isNumber(data.top)) {
          cropBoxData.top = data.top;
        }

        if (isNumber(data.width) && data.width !== cropBoxData.width) {
          widthChanged = true;
          cropBoxData.width = data.width;
        }

        if (isNumber(data.height) && data.height !== cropBoxData.height) {
          heightChanged = true;
          cropBoxData.height = data.height;
        }

        if (aspectRatio) {
          if (widthChanged) {
            cropBoxData.height = cropBoxData.width / aspectRatio;
          } else if (heightChanged) {
            cropBoxData.width = cropBoxData.height * aspectRatio;
          }
        }

        this.renderCropBox();
      }

      return this;
    },

    /**
     * Get a canvas drawn the cropped image.
     * @param {Object} [options={}] - The config options.
     * @returns {HTMLCanvasElement} - The result canvas.
     */
    getCroppedCanvas: function getCroppedCanvas() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.ready || !window.HTMLCanvasElement) {
        return null;
      }

      var canvasData = this.canvasData;
      var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.

      if (!this.cropped) {
        return source;
      }

      var _this$getData = this.getData(),
          initialX = _this$getData.x,
          initialY = _this$getData.y,
          initialWidth = _this$getData.width,
          initialHeight = _this$getData.height;

      var ratio = source.width / Math.floor(canvasData.naturalWidth);

      if (ratio !== 1) {
        initialX *= ratio;
        initialY *= ratio;
        initialWidth *= ratio;
        initialHeight *= ratio;
      }

      var aspectRatio = initialWidth / initialHeight;
      var maxSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.maxWidth || Infinity,
        height: options.maxHeight || Infinity
      });
      var minSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.minWidth || 0,
        height: options.minHeight || 0
      }, 'cover');

      var _getAdjustedSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.width || (ratio !== 1 ? source.width : initialWidth),
        height: options.height || (ratio !== 1 ? source.height : initialHeight)
      }),
          width = _getAdjustedSizes.width,
          height = _getAdjustedSizes.height;

      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.width = normalizeDecimalNumber(width);
      canvas.height = normalizeDecimalNumber(height);
      context.fillStyle = options.fillColor || 'transparent';
      context.fillRect(0, 0, width, height);
      var _options$imageSmoothi = options.imageSmoothingEnabled,
          imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,
          imageSmoothingQuality = options.imageSmoothingQuality;
      context.imageSmoothingEnabled = imageSmoothingEnabled;

      if (imageSmoothingQuality) {
        context.imageSmoothingQuality = imageSmoothingQuality;
      } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage


      var sourceWidth = source.width;
      var sourceHeight = source.height; // Source canvas parameters

      var srcX = initialX;
      var srcY = initialY;
      var srcWidth;
      var srcHeight; // Destination canvas parameters

      var dstX;
      var dstY;
      var dstWidth;
      var dstHeight;

      if (srcX <= -initialWidth || srcX > sourceWidth) {
        srcX = 0;
        srcWidth = 0;
        dstX = 0;
        dstWidth = 0;
      } else if (srcX <= 0) {
        dstX = -srcX;
        srcX = 0;
        srcWidth = Math.min(sourceWidth, initialWidth + srcX);
        dstWidth = srcWidth;
      } else if (srcX <= sourceWidth) {
        dstX = 0;
        srcWidth = Math.min(initialWidth, sourceWidth - srcX);
        dstWidth = srcWidth;
      }

      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
        srcY = 0;
        srcHeight = 0;
        dstY = 0;
        dstHeight = 0;
      } else if (srcY <= 0) {
        dstY = -srcY;
        srcY = 0;
        srcHeight = Math.min(sourceHeight, initialHeight + srcY);
        dstHeight = srcHeight;
      } else if (srcY <= sourceHeight) {
        dstY = 0;
        srcHeight = Math.min(initialHeight, sourceHeight - srcY);
        dstHeight = srcHeight;
      }

      var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid "IndexSizeError"

      if (dstWidth > 0 && dstHeight > 0) {
        var scale = width / initialWidth;
        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
      } // All the numerical parameters should be integer for `drawImage`
      // https://github.com/fengyuanchen/cropper/issues/476


      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {
        return Math.floor(normalizeDecimalNumber(param));
      }))));
      return canvas;
    },

    /**
     * Change the aspect ratio of the crop box.
     * @param {number} aspectRatio - The new aspect ratio.
     * @returns {Cropper} this
     */
    setAspectRatio: function setAspectRatio(aspectRatio) {
      var options = this.options;

      if (!this.disabled && !isUndefined(aspectRatio)) {
        // 0 -> NaN
        options.aspectRatio = Math.max(0, aspectRatio) || NaN;

        if (this.ready) {
          this.initCropBox();

          if (this.cropped) {
            this.renderCropBox();
          }
        }
      }

      return this;
    },

    /**
     * Change the drag mode.
     * @param {string} mode - The new drag mode.
     * @returns {Cropper} this
     */
    setDragMode: function setDragMode(mode) {
      var options = this.options,
          dragBox = this.dragBox,
          face = this.face;

      if (this.ready && !this.disabled) {
        var croppable = mode === DRAG_MODE_CROP;
        var movable = options.movable && mode === DRAG_MODE_MOVE;
        mode = croppable || movable ? mode : DRAG_MODE_NONE;
        options.dragMode = mode;
        setData(dragBox, DATA_ACTION, mode);
        toggleClass(dragBox, CLASS_CROP, croppable);
        toggleClass(dragBox, CLASS_MOVE, movable);

        if (!options.cropBoxMovable) {
          // Sync drag mode to crop box when it is not movable
          setData(face, DATA_ACTION, mode);
          toggleClass(face, CLASS_CROP, croppable);
          toggleClass(face, CLASS_MOVE, movable);
        }
      }

      return this;
    }
  };

  var AnotherCropper = WINDOW.Cropper;

  var Cropper =
  /*#__PURE__*/
  function () {
    /**
     * Create a new Cropper.
     * @param {Element} element - The target element for cropping.
     * @param {Object} [options={}] - The configuration options.
     */
    function Cropper(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Cropper);

      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
        throw new Error('The first argument is required and must be an <img> or <canvas> element.');
      }

      this.element = element;
      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
      this.cropped = false;
      this.disabled = false;
      this.pointers = {};
      this.ready = false;
      this.reloading = false;
      this.replaced = false;
      this.sized = false;
      this.sizing = false;
      this.init();
    }

    _createClass(Cropper, [{
      key: "init",
      value: function init() {
        var element = this.element;
        var tagName = element.tagName.toLowerCase();
        var url;

        if (element[NAMESPACE]) {
          return;
        }

        element[NAMESPACE] = this;

        if (tagName === 'img') {
          this.isImg = true; // e.g.: "img/picture.jpg"

          url = element.getAttribute('src') || '';
          this.originalUrl = url; // Stop when it's a blank image

          if (!url) {
            return;
          } // e.g.: "http://example.com/img/picture.jpg"


          url = element.src;
        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
          url = element.toDataURL();
        }

        this.load(url);
      }
    }, {
      key: "load",
      value: function load(url) {
        var _this = this;

        if (!url) {
          return;
        }

        this.url = url;
        this.imageData = {};
        var element = this.element,
            options = this.options;

        if (!options.rotatable && !options.scalable) {
          options.checkOrientation = false;
        } // Only IE10+ supports Typed Arrays


        if (!options.checkOrientation || !window.ArrayBuffer) {
          this.clone();
          return;
        } // Detect the mime type of the image directly if it is a Data URL


        if (REGEXP_DATA_URL.test(url)) {
          // Read ArrayBuffer from Data URL of JPEG images directly for better performance
          if (REGEXP_DATA_URL_JPEG.test(url)) {
            this.read(dataURLToArrayBuffer(url));
          } else {
            // Only a JPEG image may contains Exif Orientation information,
            // the rest types of Data URLs are not necessary to check orientation at all.
            this.clone();
          }

          return;
        } // 1. Detect the mime type of the image by a XMLHttpRequest.
        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.


        var xhr = new XMLHttpRequest();
        var clone = this.clone.bind(this);
        this.reloading = true;
        this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:
        // http, https, data, chrome, chrome-extension.
        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy
        // in some browsers as IE11 and Safari.

        xhr.onabort = clone;
        xhr.onerror = clone;
        xhr.ontimeout = clone;

        xhr.onprogress = function () {
          // Abort the request directly if it not a JPEG image for better performance
          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {
            xhr.abort();
          }
        };

        xhr.onload = function () {
          _this.read(xhr.response);
        };

        xhr.onloadend = function () {
          _this.reloading = false;
          _this.xhr = null;
        }; // Bust cache when there is a "crossOrigin" property to avoid browser cache error


        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
          url = addTimestamp(url);
        }

        xhr.open('GET', url);
        xhr.responseType = 'arraybuffer';
        xhr.withCredentials = element.crossOrigin === 'use-credentials';
        xhr.send();
      }
    }, {
      key: "read",
      value: function read(arrayBuffer) {
        var options = this.options,
            imageData = this.imageData; // Reset the orientation value to its default value 1
        // as some iOS browsers will render image with its orientation

        var orientation = resetAndGetOrientation(arrayBuffer);
        var rotate = 0;
        var scaleX = 1;
        var scaleY = 1;

        if (orientation > 1) {
          // Generate a new URL which has the default orientation value
          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);

          var _parseOrientation = parseOrientation(orientation);

          rotate = _parseOrientation.rotate;
          scaleX = _parseOrientation.scaleX;
          scaleY = _parseOrientation.scaleY;
        }

        if (options.rotatable) {
          imageData.rotate = rotate;
        }

        if (options.scalable) {
          imageData.scaleX = scaleX;
          imageData.scaleY = scaleY;
        }

        this.clone();
      }
    }, {
      key: "clone",
      value: function clone() {
        var element = this.element,
            url = this.url;
        var crossOrigin = element.crossOrigin;
        var crossOriginUrl = url;

        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
          if (!crossOrigin) {
            crossOrigin = 'anonymous';
          } // Bust cache when there is not a "crossOrigin" property (#519)


          crossOriginUrl = addTimestamp(url);
        }

        this.crossOrigin = crossOrigin;
        this.crossOriginUrl = crossOriginUrl;
        var image = document.createElement('img');

        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }

        image.src = crossOriginUrl || url;
        image.alt = element.alt || 'The image to crop';
        this.image = image;
        image.onload = this.start.bind(this);
        image.onerror = this.stop.bind(this);
        addClass(image, CLASS_HIDE);
        element.parentNode.insertBefore(image, element.nextSibling);
      }
    }, {
      key: "start",
      value: function start() {
        var _this2 = this;

        var image = this.image;
        image.onload = null;
        image.onerror = null;
        this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,
        // such as Safari for iOS, Chrome for iOS, and in-app browsers.

        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);

        var done = function done(naturalWidth, naturalHeight) {
          assign(_this2.imageData, {
            naturalWidth: naturalWidth,
            naturalHeight: naturalHeight,
            aspectRatio: naturalWidth / naturalHeight
          });
          _this2.sizing = false;
          _this2.sized = true;

          _this2.build();
        }; // Most modern browsers (excepts iOS WebKit)


        if (image.naturalWidth && !isIOSWebKit) {
          done(image.naturalWidth, image.naturalHeight);
          return;
        }

        var sizingImage = document.createElement('img');
        var body = document.body || document.documentElement;
        this.sizingImage = sizingImage;

        sizingImage.onload = function () {
          done(sizingImage.width, sizingImage.height);

          if (!isIOSWebKit) {
            body.removeChild(sizingImage);
          }
        };

        sizingImage.src = image.src; // iOS WebKit will convert the image automatically
        // with its orientation once append it into DOM (#279)

        if (!isIOSWebKit) {
          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
          body.appendChild(sizingImage);
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        var image = this.image;
        image.onload = null;
        image.onerror = null;
        image.parentNode.removeChild(image);
        this.image = null;
      }
    }, {
      key: "build",
      value: function build() {
        if (!this.sized || this.ready) {
          return;
        }

        var element = this.element,
            options = this.options,
            image = this.image; // Create cropper elements

        var container = element.parentNode;
        var template = document.createElement('div');
        template.innerHTML = TEMPLATE;
        var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
        var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
        var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
        var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
        var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
        this.container = container;
        this.cropper = cropper;
        this.canvas = canvas;
        this.dragBox = dragBox;
        this.cropBox = cropBox;
        this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
        this.face = face;
        canvas.appendChild(image); // Hide the original image

        addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image

        container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden

        if (!this.isImg) {
          removeClass(image, CLASS_HIDE);
        }

        this.initPreview();
        this.bind();
        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
        addClass(cropBox, CLASS_HIDDEN);

        if (!options.guides) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
        }

        if (!options.center) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
        }

        if (options.background) {
          addClass(cropper, "".concat(NAMESPACE, "-bg"));
        }

        if (!options.highlight) {
          addClass(face, CLASS_INVISIBLE);
        }

        if (options.cropBoxMovable) {
          addClass(face, CLASS_MOVE);
          setData(face, DATA_ACTION, ACTION_ALL);
        }

        if (!options.cropBoxResizable) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
        }

        this.render();
        this.ready = true;
        this.setDragMode(options.dragMode);

        if (options.autoCrop) {
          this.crop();
        }

        this.setData(options.data);

        if (isFunction(options.ready)) {
          addListener(element, EVENT_READY, options.ready, {
            once: true
          });
        }

        dispatchEvent(element, EVENT_READY);
      }
    }, {
      key: "unbuild",
      value: function unbuild() {
        if (!this.ready) {
          return;
        }

        this.ready = false;
        this.unbind();
        this.resetPreview();
        this.cropper.parentNode.removeChild(this.cropper);
        removeClass(this.element, CLASS_HIDDEN);
      }
    }, {
      key: "uncreate",
      value: function uncreate() {
        if (this.ready) {
          this.unbuild();
          this.ready = false;
          this.cropped = false;
        } else if (this.sizing) {
          this.sizingImage.onload = null;
          this.sizing = false;
          this.sized = false;
        } else if (this.reloading) {
          this.xhr.onabort = null;
          this.xhr.abort();
        } else if (this.image) {
          this.stop();
        }
      }
      /**
       * Get the no conflict cropper class.
       * @returns {Cropper} The cropper class.
       */

    }], [{
      key: "noConflict",
      value: function noConflict() {
        window.Cropper = AnotherCropper;
        return Cropper;
      }
      /**
       * Change the default options.
       * @param {Object} options - The new default options.
       */

    }, {
      key: "setDefaults",
      value: function setDefaults(options) {
        assign(DEFAULTS, isPlainObject(options) && options);
      }
    }]);

    return Cropper;
  }();

  assign(Cropper.prototype, render, preview, events, handlers, change, methods);

  return Cropper;

}));


/***/ }),

/***/ 55:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.fileBaseUrl
    ? _c("div", { staticClass: "demo", attrs: { refs: _vm.num } }, [
        _c(
          "div",
          {
            staticClass: "show",
            style: "width:" + _vm.width + ";height:" + _vm.height
          },
          [
            _c(
              "div",
              {
                staticClass: "picture",
                style:
                  "backgroundImage:url(" +
                  _vm.imgurl(
                    _vm.defaultImg || (_vm.value && _vm.value.imageUrl)
                  ) +
                  ");width:" +
                  _vm.width +
                  ";height:" +
                  _vm.height +
                  ";line-height:" +
                  _vm.height,
                on: { click: _vm.chioce }
              },
              [
                (!_vm.value || !_vm.value.imageUrl) && !_vm.defaultImg
                  ? _c("div", { staticClass: "icon-upload-box" }, [
                      _c("i", { staticClass: "icon-upload" })
                    ])
                  : _vm._e()
              ]
            )
          ]
        ),
        _vm._v(" "),
        _c("div", [
          _c("div", { staticStyle: { "margin-top": "20px" } }, [
            _vm.type
              ? _c("input", {
                  staticStyle: { display: "none" },
                  attrs: { type: "file", id: _vm.type, accept: "image" },
                  on: { change: _vm.change }
                })
              : _c("input", {
                  staticStyle: { display: "none" },
                  attrs: { type: "file", id: "change", accept: "image" },
                  on: { change: _vm.change }
                })
          ])
        ]),
        _vm._v(" "),
        _c(
          "div",
          {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value: _vm.panel,
                expression: "panel"
              }
            ],
            staticClass: "container"
          },
          [
            _c(
              "div",
              {
                directives: [
                  {
                    name: "loading",
                    rawName: "v-loading",
                    value: _vm.loading,
                    expression: "loading"
                  }
                ],
                staticClass: "wrap"
              },
              [
                !_vm.type
                  ? _c("img", {
                      attrs: { id: "change1", src: _vm.url, alt: "Picture" }
                    })
                  : _c("img", {
                      attrs: { id: _vm.type + 1, src: _vm.url, alt: "Picture" }
                    }),
                _vm._v(" "),
                _c(
                  "div",
                  { staticStyle: { "margin-top": "10px" } },
                  [
                    _c(
                      "el-button",
                      {
                        attrs: {
                          type: "button",
                          size: "small",
                          disabled: _vm.loading,
                          icon: "el-icon-zoom-in"
                        },
                        on: {
                          click: function($event) {
                            _vm.scale(1)
                          }
                        }
                      },
                      [_vm._v("æ”¾å¤§")]
                    ),
                    _vm._v(" "),
                    _c(
                      "el-button",
                      {
                        attrs: {
                          type: "button",
                          size: "small",
                          disabled: _vm.loading,
                          icon: "el-icon-zoom-out"
                        },
                        on: {
                          click: function($event) {
                            _vm.scale(-1)
                          }
                        }
                      },
                      [_vm._v("ç¼©å°")]
                    ),
                    _vm._v(" "),
                    _c(
                      "el-button",
                      {
                        attrs: {
                          type: "button",
                          size: "small",
                          disabled: _vm.loading,
                          icon: "el-icon-refresh"
                        },
                        on: {
                          click: function($event) {
                            _vm.roteta("right")
                          }
                        }
                      },
                      [_vm._v("æ—‹è½¬")]
                    ),
                    _vm._v(" "),
                    _c(
                      "el-button",
                      {
                        staticClass: "pull-right",
                        attrs: {
                          type: "primary",
                          size: "small",
                          disabled: _vm.loading,
                          icon: "el-icon-circle-check-outline"
                        },
                        on: { click: _vm.crop }
                      },
                      [_vm._v("ç¡®å®š")]
                    ),
                    _vm._v(" "),
                    _c(
                      "el-button",
                      {
                        staticClass: "pull-right",
                        attrs: {
                          type: "button",
                          size: "small",
                          disabled: _vm.loading
                        },
                        on: { click: _vm.cancelCrop }
                      },
                      [_vm._v("å–æ¶ˆ")]
                    )
                  ],
                  1
                )
              ]
            )
          ]
        )
      ])
    : _vm._e()
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-loader/node_modules/vue-hot-reload-api")      .rerender("data-v-3493686e", esExports)
  }
}

/***/ }),

/***/ 6:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(19);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ 7:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ 719:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scripts_module_vue__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scripts_module_enums__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_ui_dsp_cropper_vue__ = __webpack_require__(50);
/* jshint esversion: 6 */
/* jshint esversion: 8 */





// å¼•ç”¨
var E = __webpack_require__(167); // ä½¿ç”¨ npm å®‰è£…
// åˆ›å»ºç¼–è¾‘å™¨
var editor;
var imgUrl;

let self = new __WEBPACK_IMPORTED_MODULE_0__scripts_module_vue__["default"]({
    el: '#app',
    delimiters: ['{[', ']}'],
    components: {
        'dsp-cropper': __WEBPACK_IMPORTED_MODULE_3__components_ui_dsp_cropper_vue__["a" /* default */]
    },
    data: {
        //ä»å›¾æ–‡ç®¡ç†è¿›æ¥çš„æ•°æ®
        appmsg: null,
        //æ˜¯ç¼–è¾‘çš„æ•°æ®    åŸå§‹  sourceData.newsPublish === '2' ä¸èƒ½å¯¹ä»–è¿›è¡Œåˆ é™¤ç§»åŠ¨
        sourceData: null,
        //è§†å›¾æ˜¾ç¤ºä»€ä¹ˆå’Œloading
        views: {
            //ä¿å­˜loading //å…¨å±€loading
            saveLoading: false,
            //å‘å¸ƒå¯¹è¯æ¡†
            issueDialog: false,
            //å°ç¨‹åºå¯¹è¯æ¡†
            xcxDialog: false
        },
        $validator: {
            rule: {
                information: {
                    title: { required: true },
                    mediaSourseUrl: { required: true },
                    'imageUrl.imageUrl': { required: true }
                },
                information2: {
                    appid: { required: true },
                    xcxurl: { required: true },
                    xcxway: { required: true },
                    cardTitle: { required: true },
                    cardimgUrl: { required: true },
                    text: { required: true },
                    imgimg: { required: true }
                }
            }
        },
        //ç¼–è¾‘å†…å®¹
        information: null,
        //ç»™åç«¯çš„æ•°æ®
        articlesList: [],
        //ç¼–è¾‘å†…å®¹æ¨¡ç‰ˆ   todo articleså¯¹è±¡zdyIdéœ€è¦ä¼ ç»™åç«¯ åŒç†éœ€è¦
        articles: {
            "title": '', //æ ‡é¢˜
            "imageUrl": '', //å°é¢å›¾ç‰‡å¯¹è±¡                            todo è¿™æ˜¯ä¸éœ€è¦ä¼ ç»™åç«¯çš„   æ‰å€Ÿå£è¿”å›æ—¶éœ€è¦å°†mediaSourseUrlèµ‹å€¼ç»™imageUrl
            "mediaSourseUrl": '', //å›¾æ–‡æ¶ˆæ¯çš„å°é¢å›¾ç‰‡ç´ æidï¼ˆå¿…é¡»æ˜¯æ°¸ä¹…mediaIDï¼‰
            "author": '', //ä½œè€…
            "digest": '', //å›¾æ–‡æ¶ˆæ¯çš„æ‘˜è¦ï¼Œä»…æœ‰å•å›¾æ–‡æ¶ˆæ¯æ‰æœ‰æ‘˜è¦ï¼Œå¤šå›¾æ–‡æ­¤å¤„ä¸ºç©ºã€‚å¦‚æœæœ¬å­—æ®µä¸ºæ²¡æœ‰å¡«å†™ï¼Œåˆ™é»˜è®¤æŠ“å–æ­£æ–‡å‰64ä¸ªå­—ã€‚
            "show_cover_pic": 0, //æ˜¯å¦æ˜¾ç¤ºå°é¢ï¼Œ0ä¸ºfalseï¼Œå³ä¸æ˜¾ç¤ºï¼Œ1ä¸ºtrueï¼Œå³æ˜¾ç¤º
            "content": '', //å›¾æ–‡æ¶ˆæ¯çš„å…·ä½“å†…å®¹ï¼Œæ”¯æŒHTMLæ ‡ç­¾ï¼Œå¿…é¡»å°‘äº2ä¸‡å­—ç¬¦ï¼Œå°äº1Mï¼Œä¸”æ­¤å¤„ä¼šå»é™¤JS,æ¶‰åŠå›¾ç‰‡urlå¿…é¡»æ¥æº "ä¸Šä¼ å›¾æ–‡æ¶ˆæ¯å†…çš„å›¾ç‰‡è·å–URL"æ¥å£è·å–ã€‚å¤–éƒ¨å›¾ç‰‡urlå°†è¢«è¿‡æ»¤ã€‚
            "content2": '', //å›¾æ–‡æ¶ˆæ¯çš„å…·ä½“å†…å®¹æ›¿ä»£å“
            "content_source_url": '', //	å›¾æ–‡æ¶ˆæ¯çš„åŸæ–‡åœ°å€ï¼Œå³ç‚¹å‡»â€œé˜…è¯»åŸæ–‡â€åçš„URL
            "need_open_comment": 0, //Uint32 æ˜¯å¦æ‰“å¼€è¯„è®ºï¼Œ0ä¸æ‰“å¼€ï¼Œ1æ‰“å¼€
            "only_fans_can_comment": 0 //Uint32 æ˜¯å¦ç²‰ä¸æ‰å¯è¯„è®ºï¼Œ0æ‰€æœ‰äººå¯è¯„è®ºï¼Œ1ç²‰ä¸æ‰å¯è¯„è®º
        },
        //å‘å¸ƒå¯¹è¯æ¡†æ•°æ®
        issueData: {
            title: '',
            isIndeterminate: false,
            //æ€»æ•°æ®
            userSortDict: null,
            //å•çº¬åº¦æ•°æ®ç”¨äºåˆ¤æ–­æ˜¯å¦å…¨é€‰
            ifcheckAll: null,
            checkedCities: [],
            //æ˜¯å¦ä¸ºå…¨é€‰
            checkAll: false
        },

        information2: {
            app: '',
            //å°ç¨‹åºappid
            appid: null,
            //å°ç¨‹åºè·¯å¾„
            xcxurl: null,
            //å±•ç¤ºæ–¹å¼
            xcxway: null,
            //æ–‡å­—å†…å®¹
            text: null,
            //å¡ç‰‡æ ‡é¢˜
            cardTitle: null,
            //å¡ç‰‡å›¾ç‰‡
            cardimgUrl: null,
            //å›¾ç‰‡
            imgimg: null
        }
    },
    methods: {
        changeApp(e) {
            this.information2.app = DSP.xcx.find(el => {
                return el.appId === e;
            });
        },
        imgurl(url) {
            if (url && url.indexOf('http:') > -1) {
                return url;
            } else {
                return DSP.globalConfig.fileBaseUrl + url;
            }
        },
        contentFormat(htms) {
            let htm = JSON.parse(JSON.stringify(htms));
            //ç‰¹æ®Šå­—ç¬¦
            const regeX = new RegExp('spanyes\';', 'gi');
            htm = htm.replace(regeX, 'span ');
            htm = htm.replace(/<style(([\s\S])*?)<\/style>/g, '');
            const reg = /<!--\[if(?:(?!<!\[endif\]-->)[\s\S])*<!\[endif\]-->/gi;
            htm = htm.replace(reg, '');
            //font ==> span
            const fontEnd = new RegExp('/font', 'gi');
            htm = htm.replace(fontEnd, '/span');
            const fontStart = new RegExp('<font', 'gi');
            htm = htm.replace(fontStart, '<span');
            //phelvetica ==ã€‹ div
            const phelveticaEnd = new RegExp('</phelvetica', 'gi');
            htm = htm.replace(phelveticaEnd, '</div');
            const phelveticaStart = new RegExp('<phelvetica', 'gi');
            htm = htm.replace(phelveticaStart, '<div');
            //sectionhelvetica ==ã€‹ div
            const sectionhelveticaStart = new RegExp('<sectionhelvetica', 'gi');
            htm = htm.replace(sectionhelveticaStart, '<div');
            const sectionhelveticaEnd = new RegExp('</sectionhelvetica', 'gi');
            htm = htm.replace(sectionhelveticaEnd, '</div');

            //ä¸€çº§æ ‡é¢˜H1
            const h1Start = new RegExp('<H2', 'gi');
            htm = htm.replace(h1Start, '<H2 style="font-size :24px;color:#303133;font-weight: bold;"');
            //äºŒçº§æ ‡é¢˜H2
            const h2Start = new RegExp('<H3', 'gi');
            htm = htm.replace(h2Start, '<H3 style="font-size :18px;color:#303133;font-weight: bold;"');
            //æ­£æ–‡éƒ¨åˆ†h3
            const h3Start = new RegExp('<H4', 'gi');
            htm = htm.replace(h3Start, '<H4 style="font-size :14px;color:#606266;font-weight: initial;"');
            const p4 = new RegExp('<p></p>', 'g');
            htm = htm.replace(p4, '');
            return htm;
        },
        //é…ç½®åˆ›å»ºç¼–è¾‘å™¨
        creatEditor() {
            let self = this;
            // åˆ›å»ºç¼–è¾‘å™¨
            editor = new E('#div1', '#editor');
            editor.customConfig.zIndex = 100;
            editor.customConfig.menus = ['head', // æ ‡é¢˜
            'bold', // ç²—ä½“
            'image', // æ’å…¥å›¾ç‰‡
            'undo', // æ’¤é”€
            'justify', // å¯¹é½æ–¹å¼
            'redo' // é‡å¤
            ];
            // editor.customConfig.uploadImgShowBase64 = true   // ä½¿ç”¨ base64 ä¿å­˜å›¾ç‰‡
            editor.customConfig.uploadImgParamsWithUrl = true;
            editor.customConfig.withCredentials = true;
            editor.customConfig.uploadImgMaxSize = 1024 * 512;
            // é™åˆ¶ä¸€æ¬¡æœ€å¤šä¸Šä¼  5 å¼ å›¾ç‰‡
            editor.customConfig.uploadImgMaxLength = 1;
            // è‡ªå®šä¹‰æ–‡ä»¶å
            editor.customConfig.uploadFileName = 'file';

            editor.customConfig.uploadImgTimeout = 180000;
            editor.customConfig.uploadImgServer = '/api/file-service/file/wechat/admin/upload'; // ä¸Šä¼ å›¾ç‰‡åˆ°æœåŠ¡å™¨


            editor.customConfig.uploadImgHooks = {
                before: function (xhr, editor, files) {
                    // å›¾ç‰‡ä¸Šä¼ ä¹‹å‰è§¦å‘
                    // xhr æ˜¯ XMLHttpRequst å¯¹è±¡ï¼Œeditor æ˜¯ç¼–è¾‘å™¨å¯¹è±¡ï¼Œfiles æ˜¯é€‰æ‹©çš„å›¾ç‰‡æ–‡ä»¶
                    imgUrl = URL.createObjectURL(files[0]);
                },
                success: function (xhr, editor, result) {
                    // å›¾ç‰‡ä¸Šä¼ å¹¶è¿”å›ç»“æœï¼Œå›¾ç‰‡æ’å…¥æˆåŠŸä¹‹åè§¦å‘
                    // xhr æ˜¯ XMLHttpRequst å¯¹è±¡ï¼Œeditor æ˜¯ç¼–è¾‘å™¨å¯¹è±¡ï¼Œresult æ˜¯æœåŠ¡å™¨ç«¯è¿”å›çš„ç»“æœ
                    // var url = result.data.url;
                    // alert(JSON.stringify(url));
                    // editor.txt.append(url);
                    // alert("æˆåŠŸ");
                },
                fail: function (xhr, editor, result) {
                    // å›¾ç‰‡ä¸Šä¼ å¹¶è¿”å›ç»“æœï¼Œä½†å›¾ç‰‡æ’å…¥é”™è¯¯æ—¶è§¦å‘
                    // xhr æ˜¯ XMLHttpRequst å¯¹è±¡ï¼Œeditor æ˜¯ç¼–è¾‘å™¨å¯¹è±¡ï¼Œresult æ˜¯æœåŠ¡å™¨ç«¯è¿”å›çš„ç»“æœ
                    alert("å¤±è´¥");
                },
                error: function (xhr, editor) {
                    // å›¾ç‰‡ä¸Šä¼ å‡ºé”™æ—¶è§¦å‘
                    // xhr æ˜¯ XMLHttpRequst å¯¹è±¡ï¼Œeditor æ˜¯ç¼–è¾‘å™¨å¯¹è±¡
                    alert("é”™è¯¯");
                },
                // å¦‚æœæœåŠ¡å™¨ç«¯è¿”å›çš„ä¸æ˜¯ {errno:0, data: [...]} è¿™ç§æ ¼å¼ï¼Œå¯ä½¿ç”¨è¯¥é…ç½®
                // ï¼ˆä½†æ˜¯ï¼ŒæœåŠ¡å™¨ç«¯è¿”å›çš„å¿…é¡»æ˜¯ä¸€ä¸ª JSON æ ¼å¼å­—ç¬¦ä¸²ï¼ï¼ï¼å¦åˆ™ä¼šæŠ¥é”™ï¼‰
                customInsert: function (insertImg, result, editor) {
                    // å›¾ç‰‡ä¸Šä¼ å¹¶è¿”å›ç»“æœï¼Œè‡ªå®šä¹‰æ’å…¥å›¾ç‰‡çš„äº‹ä»¶ï¼ˆè€Œä¸æ˜¯ç¼–è¾‘å™¨è‡ªåŠ¨æ’å…¥å›¾ç‰‡ï¼ï¼ï¼ï¼‰
                    // insertImg æ˜¯æ’å…¥å›¾ç‰‡çš„å‡½æ•°ï¼Œeditor æ˜¯ç¼–è¾‘å™¨å¯¹è±¡ï¼Œresult æ˜¯æœåŠ¡å™¨ç«¯è¿”å›çš„ç»“æœ
                    // ä¸¾ä¾‹ï¼šå‡å¦‚ä¸Šä¼ å›¾ç‰‡æˆåŠŸåï¼ŒæœåŠ¡å™¨ç«¯è¿”å›çš„æ˜¯ {url:'....'} è¿™ç§æ ¼å¼ï¼Œå³å¯è¿™æ ·æ’å…¥å›¾ç‰‡ï¼š
                    // var url = result.data[0];
                    let url = DSP.globalConfig.fileBaseUrl + result.data.relativePath;
                    __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].post(`/api/wechat-service/wechat/more/uploadImgMedia?imgUrl=${result.data.relativePath}&gzhId=${self.appmsg.appid.appid}`).then(res => {
                        if (res.code === '000' && res.data) {
                            insertImg(res.data);
                        } else {
                            alert("é”™è¯¯");
                        }
                    }).catch(err => {
                        alert("é”™è¯¯");
                    });
                }
            };

            editor.customConfig.onchange = function (html) {
                let str = '<div style="text-align: left">' + html + '</div>';
                self.information.content = self.contentFormat(str);
            };
            editor.create();
        },
        //è·å–å›¾æ–‡è¯¦æƒ… ç»™informationèµ‹å€¼ ç»™articlesListèµ‹å€¼
        getmsgid() {
            console.log(this.appmsg);
            let self = this;
            __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].get(`/api/wechat-service/wechat/more/queryNewArticle?newsId=${self.appmsg.msgid}`).then(res => {
                if (res.code === '000') {
                    self.sourceData = JSON.parse(JSON.stringify(res.data));
                    self.articlesList = self.sourceData.newsArticles;
                    self.articlesList.map(ele => {
                        ele.zdyId = ele.id;
                        ele.content2 = JSON.parse(JSON.stringify(ele.content));
                        let obj = {
                            imageUrl: ele.mediaSourseUrl
                        };
                        self.$set(ele, 'imageUrl', obj);
                    });
                    self.information = self.articlesList[0];
                    setTimeout(() => {
                        self.creatEditor();
                    }, 100);
                }
            });
        },
        //ç‚¹å‡»ä¿å­˜å¹¶å‘å¸ƒæŒ‰é’®  éªŒè¯æ•°æ®æ˜¯å¦æœ‰æ•ˆ æœ‰æ•ˆæ‰“å¼€å¯¹è¯æ¡†
        saveWx() {
            self.ifnull();
            this.$data.$validator.validateAll().then(pass => {
                if (pass) {
                    self.views.issueDialog = true;
                }
            });
        },
        //å‘å¸ƒå¯¹è¯æ¡†ä¿å­˜æŒ‰é’®
        issueDialogSave() {
            if (self.issueData.checkedCities.length < 1) {
                this.$message('è¯·é€‰æ‹©å‘å¸ƒç»™é‚£ç§ç±»å‹ç”¨æˆ·');
                return;
            }
            if (self.views.saveLoading) {
                return;
            }
            self.views.saveLoading = true;
            if (self.appmsg.msgid) {
                self.editUpload();
            } else {
                self.addUpload();
            }
        },
        //æ–°å»ºæ—¶ä¸Šä¼ å¹¶å‘å¸ƒ
        addUpload() {
            let obj = {
                str: self.issueData.checkedCities,
                newsArticles: self.articlesList,
                gzhId: this.appmsg.appid.appid
            };
            __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].post('/api/wechat-service/wechat/more/addNewsMaterialAndPublish', obj).then(res => {
                if (res.code === '000') {
                    window.location = '/wxpublic/appmsg';
                } else {
                    self.views.saveLoading = false;
                }
            }).catch(err => {
                self.views.saveLoading = false;
            });
        },
        //ä¿®æ”¹æ—¶ä¸Šä¼ å‘å¸ƒ
        editUpload() {
            let obj = {
                id: self.sourceData.id,
                configId: self.sourceData.configId,
                newsPublish: 2,
                newsArticles: self.articlesList,
                str: self.issueData.checkedCities,
                gzhId: this.appmsg.appid.appid
            };
            if (self.sourceData.mediaId) {
                obj.mediaId = self.sourceData.mediaId;
            }

            __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].put('/api/wechat-service/wechat/more/updateNewsMaterialAndPublish', obj).then(res => {
                if (res.code === '000') {
                    window.location = '/wxpublic/appmsg';
                } else {
                    self.views.saveLoading = false;
                }
            }).catch(err => {
                self.views.saveLoading = false;
            });
        },
        save() {
            self.ifnull();
            this.$data.$validator.validateAll('information').then(pass => {
                if (pass) {
                    //appmsg.msgidæœ‰å€¼æ˜¯ä¿®æ”¹
                    if (self.appmsg.msgid) {
                        self.editSave();
                    } else {
                        self.addSave();
                    }
                }
            });
        },
        xiagao() {
            // if(self.views.saveLoading){return;}
            // self.views.saveLoading = true;
            let obj = {
                id: self.sourceData.id,
                newsPublish: self.sourceData.newsPublish,
                newsArticles: self.articlesList,
                gzhId: this.appmsg.appid.appid
            };
            __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].put('/api/wechat-service/wechat/more/updateNewsMaterial', obj).then(res => {
                if (res.code === '000') {
                    // window.location = '/wxpublic/appmsg';
                } else {
                    self.views.saveLoading = false;
                }
            }).catch(err => {
                self.views.saveLoading = false;
            });
        },
        editSave() {
            let self = this;
            if (self.views.saveLoading) {
                return;
            }
            self.views.saveLoading = true;
            let obj = {
                id: self.sourceData.id,
                newsPublish: self.sourceData.newsPublish,
                newsArticles: self.articlesList,
                gzhId: this.appmsg.appid.appid
            };
            __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].put('/api/wechat-service/wechat/more/updateNewsMaterial', obj).then(res => {
                if (res.code === '000') {
                    window.location = '/wxpublic/appmsg';
                } else {
                    self.views.saveLoading = false;
                }
            }).catch(err => {
                self.views.saveLoading = false;
            });
        },
        //æ–°å¢å›¾æ–‡ä¿å­˜
        addSave() {
            if (self.views.saveLoading) {
                return;
            }
            self.views.saveLoading = true;
            let obj = {
                gzhId: this.appmsg.appid.appid,
                replyContentArticles: self.articlesList
            };
            __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].post('/api/wechat-service/wechat/more/addNewsMaterial', obj).then(res => {
                if (res.code === '000') {
                    window.location = '/wxpublic/appmsg';
                } else {
                    self.views.saveLoading = false;
                }
            }).catch(err => {
                self.views.saveLoading = false;
            });
        },
        //æ„å»ºzdyid ç”¨äºæ–°å»ºæ—¶ç¡®å®šå½“å‰é€‰ä¸­çš„å›¾æ–‡
        creationId() {
            let idStr = Date.now().toString(36);
            idStr += Math.random().toString(36).substr(3);
            return idStr;
        },
        //æ–°å¢å›¾æ–‡
        addMsg() {
            if (self.articlesList.length < 10) {
                let obj = JSON.parse(JSON.stringify(self.articles));
                obj.zdyId = self.creationId();
                self.articlesList.push(obj);
            }
        },
        //é€‰ä¸­é‚£ä¸ªå›¾æ–‡
        currentMsg(item) {
            setTimeout(() => {
                self.information = item;
                editor.txt.html(item.content);
            }, 100);
        },
        //éç©ºåˆ¤æ–­,æ„å»ºarticlesListæ•°æ®
        ifnull() {
            for (let item of self.articlesList) {
                if (item.imageUrl && item.imageUrl.imageUrl) {
                    item.mediaSourseUrl = item.imageUrl.imageUrl;
                }
                if (!item.title) {
                    self.information = item;
                    return 2;
                } else if (!item.imageUrl || item.imageUrl && !item.imageUrl.imageUrl) {
                    self.information = item;
                    return 2;
                }
            }
        },
        //åˆ é™¤æ–°å¢å›¾æ–‡cell
        delmsg(e) {
            //å¦‚æœæ˜¯å·²ç»å‘å¸ƒçš„ä¸èƒ½åˆ é™¤
            if (this.sourceData && this.sourceData.newsPublish > 1) {
                return;
            }
            this.$confirm('ç¡®å®šåˆ é™¤æ­¤ç¯‡å›¾æ–‡ï¼Ÿ', {
                confirmButtonText: 'ç¡®å®š',
                cancelButtonText: 'å–æ¶ˆ',
                type: 'warning'
            }).then(() => {
                if (self.articlesList[e].zdyId === self.information.zdyId) {
                    self.information = self.articlesList[e - 1];
                }
                self.articlesList.splice(e, 1);
            }).catch(err => {
                //
            });
        },
        //ç§»åŠ¨ typeï¼š upä¸Š downä¸‹
        move(i, type) {
            //å¦‚æœæ˜¯å·²ç»å‘å¸ƒçš„ä¸èƒ½ç§»åŠ¨
            if (this.sourceData && this.sourceData.newsPublish > 1) {
                return;
            }
            //è¦ç§»åŠ¨çš„æ•°æ®
            let se = this.articlesList[i];
            //è¦ç§»åŠ¨åˆ°çš„æ•°æ®
            let te = '';
            //è¦ç§»åŠ¨åˆ°çš„ä½ç½®
            let ti = '';
            if (type === 'up') {
                ti = i - 1;
                te = this.articlesList[i - 1];
            } else {
                ti = i + 1;
                te = this.articlesList[i + 1];
            }
            this.articlesList[i] = te;
            this.articlesList[ti] = se;
            this.articlesList = Object.assign([], this.articlesList);
        },
        //è·å–ç”¨æˆ·å›¾æ–‡æ¨é€åˆ†ç±»æ±‡æ€»
        getUserSortDict() {
            let self = this;
            __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].get(`/api/wechat-service/wechat/more/getUserSortDict?gzhId=${self.appmsg.appid.appid}`).then(res => {
                if (res.code === '000') {
                    if (res.data && res.data.city && res.data.city[0] && res.data.city[0].value === 'all') {
                        res.data.city.shift();
                    }
                    this.issueData.userSortDict = res.data;
                    this.issueData.ifcheckAll = [];
                    let obj = JSON.parse(JSON.stringify(res.data));
                    for (let i in obj) {
                        if (obj[i] instanceof Array) {
                            this.issueData.ifcheckAll = this.issueData.ifcheckAll.concat(obj[i]);
                        }
                    }
                    console.log(this.issueData.ifcheckAll);
                }
            });
            __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].get(`/api/wechat-service/wechat/more/queryContentArticleLogCount?gzhId=${self.appmsg.appid.appid}`).then(res => {
                this.issueData.title = res.data || '0';
            });
        },
        //å…¨é€‰
        handleCheckAllChange(val) {
            this.issueData.checkedCities = [];
            if (val) {
                this.issueData.ifcheckAll.map(el => {
                    this.issueData.checkedCities.push(el.value);
                });
            }
            this.issueData.isIndeterminate = false;
        },
        //å•é€‰
        handleCheckedCitiesChange(value) {
            //åˆ¤æ–­æ˜¯å…¨é€‰è¿˜æ˜¯å•é€‰
            this.issueData.checkAll = value.length === this.issueData.ifcheckAll.length;
            //æ˜¯å¦ä¸ºä¸­é—´æ€åº¦
            this.issueData.isIndeterminate = value.length > 0 && value.length < this.issueData.ifcheckAll.length;
        },
        //ç¡®å®šæ·»åŠ å°ç¨‹åº
        async qeding() {
            let self = this;
            const loading = this.$loading({
                lock: true,
                text: 'æ„å»ºæ•°æ®ä¸­',
                spinner: 'el-icon-loading',
                background: 'rgba(0, 0, 0, 0.7)'
            });
            let imgUrl = self.information2.cardimgUrl && self.information2.cardimgUrl.imageUrl; // å¡ç‰‡çš„å›¾ç‰‡çš„url
            if (imgUrl) {
                imgUrl = await __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].post(`/api/wechat-service/wechat/more/uploadImgMedia?imgUrl=${imgUrl}&gzhId=${self.appmsg.appid.appid}`);
                imgUrl = imgUrl && imgUrl.data;
            }
            let imgimg = self.information2.imgimg;
            if (imgimg) {
                imgimg = await __WEBPACK_IMPORTED_MODULE_2__scripts_module_axios__["default"].post(`/api/wechat-service/wechat/more/uploadImgMedia?imgUrl=${imgimg}&gzhId=${self.appmsg.appid.appid}`);
                imgimg = imgimg && imgimg.data;
            }
            setTimeout(() => {
                loading.close();
            }, 10);
            this.$data.$validator.validateAll('information2').then(pass => {
                if (pass) {
                    // è·å–åˆ°çš„å°ç¨‹åºå¯¹è±¡
                    var appid = self.information2.app.appId; // å°ç¨‹åºappid
                    var nickName = self.information2.app.name; // å°ç¨‹åºåå­—
                    var path = self.information2.xcxurl; // å¾…å®š å°ç¨‹åºçš„url
                    var title = self.information2.cardTitle; // å¡ç‰‡æ ‡é¢˜
                    // if(1===1){
                    //     return;
                    // }
                    let p = '';
                    if (self.information2.xcxway === 'text') {
                        p = `<a href="http://www.qq.com" data-miniprogram-appid="${appid}" data-miniprogram-path="${path}">${self.information2.text}</a>`;
                    } else if (self.information2.xcxway === 'card') {
                        p = `<iframe src=\"https://mp.weixin.qq.com/cgi-bin/readtemplate?t=tmpl/weapp_tmpl&appid=${appid}&nickName=${nickName}&path=${path}&title=${title}&imgUrl=${imgUrl}\" class=\"res_iframe weapp_app_iframe js_editor_weapp wxCard\" data-miniprogram-appid=\"${appid}\" data-miniprogram-nickname=\"${nickName}\" data-miniprogram-title=\"${title}\" data-miniprogram-imageUrl=\"${imgUrl}\" data-miniprogram-path=\"${path}\">
                        </iframe><p><mp-miniprogram data-miniprogram-appid=\"${appid}\" data-miniprogram-path=\"${path}\" data-miniprogram-title=\"${title}\" data-miniprogram-imageurl=\"${imgUrl}\"></mp-miniprogram></p >`;
                    } else if (self.information2.xcxway === 'img') {
                        p = `<a class=\"weapp_image_link"\ data-miniprogram-appid=\"${appid}\" data-miniprogram-path=\"${path}\" data-miniprogram-nickname=\"${nickName}\" href="" data-miniprogram-type="image" data-miniprogram-servicetype="" _href=""><img class="rich_pages" data-ratio="1.0422535211267605" src=\"${imgimg}\" data-type="jpeg"  style=""></a>`;
                    }
                    self.information.content += p;
                    self.$set(self.information, 'content2', JSON.parse(JSON.stringify(self.information.content)));
                    self.views.xcxDialog = false;
                }
            });
        },
        //
        handleAvatarSuccess(res, file) {
            var that = this;
            if (res.success) {
                that.information2.imgimg = res.data.relativePath;
            }
        },
        beforeAvatarUpload(file) {
            const isJPG = file.type === 'image/jpeg' || file.type === 'image/png';
            const isLt200kb = file.size / 1024 < 200;
            if (!isJPG) {
                this.$message.error('ä¸Šä¼ å¹¿å‘Šå›¾ç‰‡åªèƒ½æ˜¯ JPG / pngæ ¼å¼!');
            }
            if (!isLt200kb) {
                this.$message.error('ä¸Šä¼ å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡ 200kb!');
            }
            return isJPG && isLt200kb;
        }
    },

    mounted() {
        let self = this;
        let hash = window.location.hash;
        //é€šè¿‡hashå€¼ç¡®å®š æ˜¯æ–°å¢è¿˜æ˜¯ç¼–è¾‘ decodedæœ‰msgidæ˜¯ç¼–è¾‘ æ²¡æœ‰ä¸ºæ–°å¢   é€šè¿‡appid.id ç¡®å®š
        //decoded ={
        //      msgid:''        æ˜¯ç¼–è¾‘ æ²¡æœ‰ä¸ºæ–°å¢   æœ‰æ˜¯ç¼–è¾‘æ‰getmsgid()æ²¡æœ‰å°±æ˜¯æ–°å¢
        //      appid:''        æ˜¯é‚£ä¸ªå°ç¨‹åº
        // }
        //
        if (hash) {
            try {
                let decoded = self.$base64Decode(hash.slice(1));
                if (typeof decoded === 'object') {
                    self.appmsg = decoded;
                    if (decoded.msgid) {
                        self.getmsgid();
                    } else {
                        self.information = JSON.parse(JSON.stringify(self.articles));
                        //èµ‹å€¼zdyid
                        self.information.zdyId = self.creationId();
                        self.articlesList.push(self.information);
                        setTimeout(() => {
                            self.creatEditor();
                        }, 100);
                    }
                }
            } catch (error) {}
        }
        this.getUserSortDict();
    }

});

/***/ }),

/***/ 8:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ 9:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* jshint esversion: 6 */

/* harmony default export */ __webpack_exports__["default"] = ({
    //ç³»ç»Ÿé”™è¯¯
    SYSTEM_ERROR: {
        DEFAULT: 'æœªçŸ¥é”™è¯¯',
        '999': 'æœªçŸ¥é”™è¯¯',
        '800': 'æ•°æ®ä¿å­˜å¤±è´¥',
        '801': 'æ•°æ®ä¿®æ”¹å¤±è´¥',
        '802': 'æ•°æ®åˆ é™¤å¤±è´¥',
        '803': 'æ•°æ®æŸ¥è¯¢å¤±è´¥',
        '804': 'ã€804ã€‘è¿åæ•°æ®å”¯ä¸€çº¦æŸ',
        '810': 'ã€810ã€‘ç™»å½•ä¼šè¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•',
        '811': 'ã€811ã€‘ç”¨æˆ·æœªç™»å½•',
        '812': 'ã€812ã€‘ç”¨æˆ·æƒé™ä¸è¶³',
        '813': 'ã€813ã€‘éªŒè¯ç é”™è¯¯',
        '830': 'ã€830ã€‘æŠ±æ­‰ï¼Œç³»ç»ŸæœåŠ¡ç¹å¿™ï¼Œè¯·ç¨åé‡è¯•ï¼'
    },
    //ç½‘ç»œé”™è¯¯
    NETWORK_ERROR: {
        DEFAULT: 'ç½‘ç»œé€šä¿¡å¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•',
        '400': 'è¯·æ±‚å‚æ•°é”™è¯¯ï¼',
        '401': 'æƒé™ä¸è¶³ï¼ç³»ç»Ÿå·²è®°å½•æœ¬æ¬¡æ“ä½œï¼Œè¯·å‹¿å°è¯•è¶Šæƒæ“ä½œï¼',
        '403': 'ç¦æ­¢è®¿é—®ï¼',
        '404': 'è¯·æ±‚åœ°å€é”™è¯¯ï¼',
        '500': 'æŠ±æ­‰ï¼Œç³»ç»ŸæœåŠ¡ç¹å¿™ï¼Œè¯·ç¨åé‡è¯•ï¼',
        '502': 'æŠ±æ­‰ï¼Œç³»ç»ŸæœåŠ¡ç¹å¿™ï¼Œè¯·ç¨åé‡è¯•ï¼',
        '503': 'æŠ±æ­‰ï¼Œç³»ç»ŸæœåŠ¡ç¹å¿™ï¼Œè¯·ç¨åé‡è¯•ï¼',
        '504': 'è¯·æ±‚è¶…æ—¶ï¼Œæ‚¨çš„ç½‘ç»œç¯å¢ƒä¸ç¨³å®šï¼Œè¯·ç¨åé‡è¯•ï¼'
    }
});

/***/ })

/******/ });